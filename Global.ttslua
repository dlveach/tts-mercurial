--[[ *************************************************************************

Work items for converstion of beta to production version:

  - BUG: fix arcana scoring to final rules  TESTING?
  - BUG: score display on player area doesn't update as often as it should.

  - TODO: start options in UI start game panel
  - TODO: auto play alteration card if no discard power on it (starting cards and artifacts)
  - TESTING: save/load/rewind

Future possible stuff for greater enhancement
  --IN WORK: Think about a data structure to represent avaialable card positions.
          The 6 card locations, current card guid and any Acuity or Mana guids on card.
          Would make snap back possible and shifting much easier without using Physics.cast etc.
          Also lock them and add a "Take" button at this time.
            - Take buttons in xml done
            - data structure during game start setup done

  - IN WORK: HUD display???
        - players current spell power
        - players score
        - player's current unallocated dice
        - TODO: players mana & acuity?
        - players herocs count vs max
  --TODO: track take & play actions??? (with "Take" buttons on cards, enforce limits & requirements)
  --TODO: Automate alteration play actions. A big one!
  --IN WORK: automate spell cast???
        - calcuate winnings and display "Take" buttons on Heroics/Arcanas/Prestige
        - dialog for Myst if equilibrium attained.
  --TODO: automate assinging resources to spell cards???

****************************************************************************** ]]

env = {}
env.version = "1.0.2 production release"
env.test= {}
-- env.test.test_players = {"Green", "Blue", "Yellow", "Red"}
-- env.test.test_players = {"Yellow", "Red", "Blue"}
-- env.test.test_players = {"Green", "Blue"}
env.test.test_players = {"Green", "Blue"}
env.test.auto_switch = true
env.test.in_dev = true
env.test.trace = true
env.test.debug = true
env.test.force_fresh_save = true
env.game = {}
env.game.player_table_order = {"Red", "Blue", "Green", "Yellow"}  --clockwise
env.game.verbose = true
env.game.card_tooltips = true

--[[ Game is loading. ]]
function onLoad(saved_data)
  log("Mercurial version " .. env.version)
  log("Loading ...")
  for i=1,4 do
    local bar = getObjectFromGUID(C.guids.color_bars[i])
    if bar ~= nil then
      bar.interactable = false
      bar.UI.setAttribute("block_text_id", "text", "")
      bar.setInvisibleTo(Player.getColors())
    end
  end

  --set globals
  g_table_UI = getObjectFromGUID(C.guids.table_UI)
  GD = {}

  --handle game loading state
  if saved_data ~= "" then
    if env.test.trace then log("Global onLoad(): Saved load") end
    local restore_data = JSON.decode(saved_data)
    GD = restore_data
    restoreGameState()
  else
    if env.test.trace then log("Global onLoad(): Fresh load") end
    --persistent state data
    GD.states = {}
    GD.states.UI = {}
    GD.states.table_UI = {}
    GD.states.obj_vis = {}
    --persistent environment vars
    GD.env = {}
    GD.env.verbose = env.game.verbose
    GD.env.card_tooltips = env.game.card_tooltips
    --persistent game data
    GD.game = {}
    GD.game.started = false
    GD.game.spells_deck_guid = C.guids.spells_deck
    GD.game.alterations_deck_guid = C.guids.alterations_deck
    GD.game.heroics_deck_guid = C.guids.heroics_deck
    GD.game.artifacts_deck_guid = C.guids.artifacts_deck
    GD.game.players = {}
    GD.game.positions = {}
    GD.game.heroics = {}
    for i=1,6 do
      table.insert(GD.game.heroics,
        {
          pos=C.pos.heroics[i],
          card_id=0,
          card_guid="",
          mana_guid="",
          acuity_guid="",
        })
    end
    GD.game.alterations = {}
    for i=1,6 do
      table.insert(GD.game.alterations,
        {
          pos=C.pos.alterations[i],
          card_id=0,
          card_guid="",
          acuity_guids={},
        })
    end
    GD.game.spells = {}
    for i=1,6 do
      table.insert(GD.game.spells,
        {
          pos=C.pos.spells[i],
          card_id=0,
          card_guid="",
        })
    end
    for i=1,4 do
      GD.game.positions[i] = ""
    end
    if not(env.test.in_dev) then
      --TODO: anything??
    end
    --setup UI dialogs
    UI_setAttribute("outer_spell_cost_panel","visibility","Pink")
    UI_setAttribute("outer_spell_cost_panel","active",true)
    UI_setAttribute("alteration_card_panel","visibility","Pink")
    UI_setAttribute("alteration_card_panel","active",true)

    UI_setAttribute("startPanel", "active", true)
  end
  math.randomseed(os.time())
  log("Loading complete.")
end

--[[ Wrapper function for saving obj visiblity for game restore. ]]
function setInvisibleTo(guid, colors)
  if env.test.trace then log("setInvisibleTo(): "..guid) end
  assert(type(guid) == 'string', "guid must be a string")
  assert(colors)
  getObjectFromGUID(guid).setInvisibleTo(colors)
  GD.states.obj_vis[guid] = colors
end

--[[  Wrapper function for saving UI attributes for game restore. ]]
function UI_setAttribute(id, field, value)
  if env.test.trace and GD.env.verbose then log("UI_setAttribute()") end
  assert(type(id) == "string", "id must be a string")
  assert(type(field) == "string", "field must be a string")
  UI.setAttribute(id, field, value)
  GD.states.UI[id..":"..field] = value
end

--[[  Wrapper function for saving table UI attributes for game restore. ]]
function table_UI_setAttribute(id, field, value)
  if env.test.trace and GD.env.verbose then log("table_UI_setAttribute()") end
  if not(g_table_UI) then g_table_UI = getObjectFromGUID(C.guids.table_UI) end
  assert(type(id) == "string", "id must be a string")
  assert(type(field) == "string", "field must be a string")
  g_table_UI.UI.setAttribute(id, field, value)
  GD.states.table_UI[id..":"..field] = value
end

--[[ Wrapper function for hiding UI elements with animations. --]]
function UI_hide(id)
  UI.hide(id)
  --give it time to animate then set UI attribute for game save/load
  Wait.time(function() UI_setAttribute(id, "active", false) end, 1)
end

--[[ Wrapper function for showing UI elements with animations. --]]
function UI_show(id)
  UI.show(id)
  --give it time to animate then set UI attribute for game save/load
  Wait.time(function() UI_setAttribute(id, "active", true) end, 1)
end

--[[ Save game state ]]
function onSave()
  local data_to_save = GD
  local saved_data = JSON.encode(data_to_save)
  if env.test.force_fresh_save then
    saved_data = ""
  end
  return saved_data
end

--[[ Restore game state from saved load. ]]
function restoreGameState()
  if env.test.trace then log("restoreGameState()") end
  --restore object visiblity
  for g,colors in pairs(GD.states.obj_vis) do
    local obj = getObjectFromGUID(g)
    if obj then obj.setInvisibleTo(colors) end
  end
  --restore UI state
  for key,value in pairs(GD.states.UI) do
    local id = Split(key, ':')[1]
    local field = Split(key, ':')[2]
    UI.setAttribute(id, field, value)
  end

  --restore table UI state
  if not(g_table_UI) then g_table_UI = getObjectFromGUID(C.guids.table_UI) end
  for key,value in pairs(GD.states.table_UI) do
    local id = Split(key, ':')[1]
    local field = Split(key, ':')[2]
    g_table_UI.UI.setAttribute(id, field, value)
  end

  --TODO: move into table UI
  if GD.game.started then
    local btn = getObjectFromGUID(C.guids.recycle_spell_btn)
    btn.UI.setAttribute("recycle_spell_panel","active","true")
  end
end

--[[ Button handler for "Start Game".  Setup player order and
    enable class board selection. ]]
function startGameBtn()
  local seated = getSeatedPlayers()
  if(env.test.test_players) then
    seated = env.test.test_players
  end
  if env.test.debug then log("Seated players: "); log(seated) end
  local colors_ok = true;
  for _,c in ipairs(seated) do
    if not(contains(env.game.player_table_order,c)) then
      broadcastToAll("Seated player color "..c.." not present at this table.  Please choose another color.")
      colors_ok = false
    end
  end
  if not(colors_ok) then return end
  UI_hide("startPanel")
  --get random start player and assign player order in table clockwise order
  GD.game.player_count = #seated
  local start_color = seated[math.random(1, GD.game.player_count)]
  GD.game.player_order = {}
  GD.game.players = {}
  local order = ""
  local p = indexOf(env.game.player_table_order, start_color)
  for i=1, #env.game.player_table_order do
    local pcol = env.game.player_table_order[p]
    if contains(seated, pcol) then
      GD.game.players[pcol] = {}
      table.insert(GD.game.player_order, pcol)
      if order == "" then order = pcol
      else order = order .. ", " .. pcol end
    end
    p = p + 1
    if p > #env.game.player_table_order then p = 1 end --wrap around end
  end
  GD.game.start_player = indexOf(GD.game.player_order, start_color)
  if GD.env.verbose then print("Player order is " .. order) end
  if env.test.debug then log("Player order is " .. order) end
  --set up the table
  if (math.random(1, 10) > 5) then
    GD.game.myst_rune = C.guids.myst_rune_1
  else
    GD.game.myst_rune = C.guids.myst_rune_2
  end
  getObjectFromGUID(GD.game.heroics_deck_guid).shuffle()
  getObjectFromGUID(GD.game.spells_deck_guid).shuffle()
  getObjectFromGUID(GD.game.alterations_deck_guid).shuffle()
  getObjectFromGUID(GD.game.artifacts_deck_guid).shuffle()
  -- Enable class select buttons
  for class, guid in pairs(C.guids.player_boards) do
    local class_board = getObjectFromGUID(guid)
    assert(class_board)
    --class_board.call("enableClassSelectBtn")
    class_board.interactable = true
    class_board.setLock(false)
  end
  GD.game.assigned_boards_count = 0
  GD.game.current_player = #GD.game.player_order
  if env.test.debug then log("Active player is "..GD.game.player_order[GD.game.current_player]) end
  if GD.env.verbose then print("Active player is "..GD.game.player_order[GD.game.current_player]) end
  --display cast selection UI
  for i=1,4 do
    UI_setAttribute("selectClass_"..tostring(i).."_panel","color","rgba(0,0,0,0)")
    UI_setAttribute("selectClass_"..tostring(i).."_text","text","")
    UI_setAttribute("selectClassLocation_"..tostring(i).."_text","text","")
  end
  local i = 1
  for p=#GD.game.player_order,1,-1 do
    local pcol = GD.game.player_order[p]
    UI_setAttribute("selectClass_"..tostring(i).."_panel","color",pcol)
    UI_setAttribute("selectClass_"..tostring(i).."_text","text",pcol)
    UI_setAttribute("selectClassLocation_"..tostring(i).."_text","text",tostring(i))
    i=i+1
  end
  UI_setAttribute("selectClassBoardPanel","active","true")
  if env.test.auto_switch then
    autoSwitch(GD.game.player_order[GD.game.current_player])
  end
end

--[[TESTING ONLY: Facilitate testing.  Switch test player color to game active player color.]]
function autoSwitch(pcol)
  if env.test.trace then log("Global: autoSwitch() "..tostring(pcol)) end
  local players = Player.getPlayers()
  if #players == 1 then
    if env.test.debug then log("Test player current color: "..tostring(players[1].color)) end
    if pcol then
      if players[1].color ~= pcol then
        if env.test.debug then log("Switching color to pcol: "..tostring(pcol)) end
        players[1].changeColor(pcol)
      end
    else
      if players[1].color ~= GD.game.player_order[GD.game.current_player] then
        if env.test.debug then log("Switching color to: "..GD.game.player_order[GD.game.current_player]) end
        players[1].changeColor(GD.game.player_order[GD.game.current_player])
      end
    end
  end
end

--[[ Called from player board on class select.
    If player is unnassigned, set associations to player board.
    Otherwise show error message and return with no action.
    Calls back to player board to finish setup if successful. ]]
function setPlayerClass(params)
  if env.test.trace then log("Global: setPlayerClass()") end
  assert(params.player, "parameter 'player' missing")
  assert(params.guid, "parameter 'guid' missing")
  assert(params.position, "parameter 'position' missing")
  local position = params.position
  local pcol = params.player
  local error = false;
  local player = GD.game.players[pcol]
  if not(contains(GD.game.player_order, pcol)) then
    broadcastToAll("Player " .. pcol .. " is not a player in this game.")
    error = true
  elseif pcol ~= GD.game.player_order[GD.game.current_player] then
    broadcastToColor("Player " .. pcol .. " is not the current player.", pcol)
    error = true
  elseif player.class then
    broadcastToColor("Player " .. pcol .. " cannot select a second class.", pcol)
    error = true
  elseif GD.game.positions[position] ~= "" then
    broadcastToAll("Player position "..position.." already taken.")
    error = true
  end
  if error then
    getObjectFromGUID(params.guid).setPosition(Vector(params.home_position))
    return
  else
    local class_board = getObjectFromGUID(params.guid)
    assert(class_board, "ERROR: Global: setPlayerClass(): Missing board object")
    if GD.env.verbose then print("Player " .. pcol .. " selected class " .. class_board.getName()) end
    local setup = C.setup[class_board.getName()]
    assert(setup, "ERROR: Global:setPlayerClass() missing setup data for "..class_board.getName())
    GD.game.positions[position] = pcol
    player.class = class_board.getName()
    player.board_guid = class_board.getGUID()
    player.alteration_cards = {}
    player.heroics = {}
    player.active_spell = {}
    player.cast_spells = {}
    player.arcanas = {}
    player.prestige = 0
    player.actions = {}
    player.actions.takes = {} --{"any"|"spell"}
    player.actions.play = 0
    player.dice = {}
    for i=1,setup.start_dice do
      table.insert(player.dice, {value=math.random(1,6),allocated=false})
    end
    player.mana = setup.start_mana
    player.mana_assigned = 0
    player.acuity = setup.start_acuity
    player.sigils = { red = 0, blue = 0, green = 0, yellow = 0 }
    player.sigils[setup.board_sigil] = 1
    --deal start cards to player and assign them
    local start_deck = getObjectFromGUID(setup.start_deck)
    assert(start_deck,"ERROR: Global:setPlayerClass(): unable to get start deck for board "..tostring(class_board))
    local start_cards = start_deck.getObjects()
    for _,c in ipairs(start_cards) do
      table.insert(player.alteration_cards, c.guid)
    end
    start_deck.deal(#start_cards, pcol)
    local artifacts_deck = getObjectFromGUID(C.guids.artifacts_deck)
    assert(artifacts_deck,"ERROR: Global:setPlayerClass(): unable to get artifacts deck for board "..tostring(class_board))
    Wait.time(function()
      artifacts_deck.takeObject(
        {callback_function = function(o)
          table.insert(player.alteration_cards, o.guid)
          o.deal(1,pcol)
        end}
      )
    end, 0.5, setup.num_artifacts)
    --complete player assignment in board
    class_board.call("setPlayer", {["player"]=pcol, ["position"]=position})
    GD.game.assigned_boards_count = GD.game.assigned_boards_count + 1
    --update display for cast selection UI
    UI_setAttribute("selectClass_"..tostring(GD.game.assigned_boards_count).."_panel","color","Grey")
    UI_setAttribute("selectClass_"..tostring(GD.game.assigned_boards_count).."_text","text","Done")
  end
  --If all players assigned to boards, do final setup
  if GD.game.assigned_boards_count == GD.game.player_count then
    UI_setAttribute("selectClassBoardPanel","active","false")
    finalSetup()
  else
    local next = GD.game.current_player - 1
    if next == 0 then
      next = #GD.game.player_order  --TODO: is this necessary?  Always finishes on 1st player in order?
      log("WARN: wrapping in player order")
    end
    GD.game.current_player = next
    if GD.env.verbose then print("Active player is "..GD.game.player_order[GD.game.current_player]) end
    if env.test.auto_switch then autoSwitch(GD.game.player_order[GD.game.current_player]) end
  end
end

--[[ Final game setup after all players have selected a class. ]]
function finalSetup()
  if env.test.trace then log("Global: finalSetup()") end
  --cleanup unused boards
  for _,guid in pairs(C.guids.player_boards) do
    getObjectFromGUID(guid).call("setupBoard")
  end
  for i=1,4 do
    if GD.game.positions[i] == "" then
      getObjectFromGUID(C.guids.color_bars[i]).destruct()
    end
    local zone =getObjectFromGUID(C.guids.board_zones[i])
    if zone ~= nil then zone.destruct() end
  end
  --deal out starting cards
  local p = {
    ["position"] = {},
    ["flip"] = true,
    ["top"] = true,
    ["smooth"] = true
  }
  -- Place spell cards
  local deck = getSpellsDeck()
  for i=1,6 do
    p.position = GD.game.spells[i].pos
    p.callback_function = function(obj)
      GD.game.spells[i].card_id = tonumber(obj.getGMNotes())
      GD.game.spells[i].card_guid = obj.getGUID()
      Wait.condition(
        function() obj.setLock(true) end,
        function() return obj.resting end)
    end
    deck.takeObject(p)
  end

  -- Place Alteration cards
  deck = getAlterationsDeck()
  for i=1,6 do
    p.position = GD.game.alterations[i].pos
    p.callback_function = function(obj)
      GD.game.alterations[i].card_id = tonumber(obj.getGMNotes())
      GD.game.alterations[i].card_guid = obj.getGUID()
      if i <= GD.game.player_count then
        GD.game.alterations[i].acuity = 1
        table_UI_setAttribute("alterations_acuity_"..tostring(i).."_text","text","1")
      else
        GD.game.alterations[i].acuity = 0
        table_UI_setAttribute("alterations_acuity_"..tostring(i).."_text","text","0")
        table_UI_setAttribute("alterations_acuity_"..tostring(i).."_pnl","active","false")
      end
      Wait.condition(
        function() obj.setLock(true) end,
        function() return obj.resting end)
    end
    deck.takeObject(p)
  end
  table_UI_setAttribute("alterations_acuity_pnl","active","true")

  -- Place Heroic cards
  deck = getHeroicsDeck()
  for i=1,6 do
    p.position = GD.game.heroics[i].pos
    p.callback_function = function(obj)
      GD.game.heroics[i].card_id = tonumber(obj.getGMNotes())
      GD.game.heroics[i].card_guid = obj.getGUID()
      Wait.condition(
        function() obj.setLock(true) end,
        function() return obj.resting end)
    end
    deck.takeObject(p)
  end

  -- Place the previously random selected myst rune (if Mystcaller not taken)
  local mystcaller = false
  for _,p in pairs(GD.game.players) do
    if p.class == "Mystcaller" then mystcaller = true end
  end
  if not(mystcaller) then
    local myst_rune = getObjectFromGUID(GD.game.myst_rune)
    myst_rune.setPositionSmooth(C.pos.myst_rune)
    myst_rune.setRotation(C.rot.myst_rune)
    myst_rune.setLock(false)
  end

  -- Random flip arcanas
  for g,data in pairs(C.arcanas) do
    local arcana = getObjectFromGUID(g)
    if (math.random(1, 10) > 5) then arcana.flip() end
    Wait.condition(
      function()
        if arcana.is_face_down then
          arcana.setName(data.face_down.name)
        else
          arcana.setName(data.face_up.name)
        end
      end,
      function() return arcana.resting end
    )
  end

  -- Give extra acuity to players in turn order
  local p = GD.game.start_player
  local count = 1
  for n=1,GD.game.player_count-1 do
    if p > GD.game.player_count then p = 1 end --wrap around
    local pcol = GD.game.player_order[p]
    GD.game.players[pcol].acuity = GD.game.players[pcol].acuity + count
    count = count + 1
  end

  --Configure final scoring table and HUD for number of players
  local num_players = #GD.game.player_order
  for i=1,4 do
    if i > num_players then
      UI_setAttribute("score_table_row_"..tostring(i), "active", "false")
      UI_setAttribute("hud_row_"..tostring(i), "active", "false")
    else
      UI_setAttribute("hud_row_"..tostring(i).."_player", "text", GD.game.player_order[i])
      UI_setAttribute("hud_row_"..tostring(i).."_player", "color", GD.game.player_order[i])
    end
  end
  local table_size = 360 - ((4 - num_players) * 55)
  UI_setAttribute("score_panel", "height", tostring(table_size))
  local inner_hud_panel_size = 160 + num_players * 30
  local outer_hud_panel_size = inner_hud_panel_size + 20
  UI_setAttribute("inner_hud_panel","height",tostring(inner_hud_panel_size))
  UI_setAttribute("outer_hud_panel","height",tostring(outer_hud_panel_size))
  for _,pcol in ipairs(env.game.player_table_order) do
    for i=1,7 do
      UI_setAttribute(pcol.."_hud_die_"..tostring(i).."_image","actve","false")
    end
  end
  UI_setAttribute("outer_hud_panel","active","true")

  --done with final setup
  GD.game.started = true
  --TODO: figure out what to wait on, card data structures not yet set up.
  Wait.time(function()
    table_UI_setAttribute("alterations_buttons_pnl","active",true)
    table_UI_setAttribute("spells_buttons_pnl","active",true)
    startPlayerTurn(GD.game.player_order[GD.game.current_player])
  end,2)
end

--[[ Setup stuff at beginning of player turn. ]]
function startPlayerTurn(pcol)
  if env.test.trace then log("Global:startPlayerTurn() "..tostring(pcol)) end
  if env.test.debug then log(GD.game.players[pcol]) end
  if pcol ~= GD.game.player_order[GD.game.current_player] then return end
  local player = GD.game.players[pcol]
  --enable UI stuffs
  table_UI_setAttribute("recycle_spell_panel","active",true)
  enableAlterationButtons(true)
  --set spell card take buttons based on player's avaialable resources
  updateSpellButtons(pcol)
  --set up player actions
  player.actions.takes = {"any"}
  player.actions.play = 1
  getObjectFromGUID(GD.game.players[pcol].board_guid).call("enableActivePlayer")
  if GD.env.verbose then print("Active player is " .. GD.game.player_order[GD.game.current_player]) end
  updateHUD()
end

--[[ Set spell card take button states based on player's avaialable resources --]]
function updateSpellButtons(pcol)
  if env.test.trace then log("Global:updateSpellButtons() "..tostring(pcol)) end
  for i=1,6 do
    local s = false
    if GD.game.spells[i].card_id > 0 then s = checkSpellRequirements(i, pcol) end
    table_UI_setAttribute("spells_button_"..tostring(i).."_pnl","active",s)
  end
end

--[[ Hide all the spell buttons --]]
function hideSpellButtons()
  if env.test.trace then log("Global:hideSpellButtons()") end
  for i=1,6 do
    table_UI_setAttribute("spells_button_"..tostring(i).."_pnl","active",false)
  end
end

--[[ Set alteration card take button states as specified.  Defaults to true. --]]
function enableAlterationButtons(state)
  if env.test.trace then log("Global:enableAlterationButtons()") end
  for i=1,6 do
    local state = state and true
    if GD.game.alterations[i].card_id == 0 then state = false end
    table_UI_setAttribute("alterations_button_"..tostring(i).."_pnl","active",state)
  end
end

--[[ Check a spell card at a given location to see if a player can take it. --]]
function checkSpellRequirements(loc, pcol)
  if env.test.trace then log("Global:checkSpellRequirements() "..tostring(loc)..", "..tostring(pcol)) end
  local id = GD.game.spells[loc].card_id
  local mana = GD.game.players[pcol].mana
  if loc == 1 then mana = mana + 1 end  --discount
  local acuity = GD.game.players[pcol].acuity
  if loc == 2 then acuity = acuity + 1 end  --discount
  local flex_die = math.floor(mana / 2) + math.floor(acuity / 4)
  local dice = {}
  for _,d in ipairs(GD.game.players[pcol].dice) do
    if not(d.allocated) then
      local element = C.die_elements[d.value]
      if dice[element] then dice[element] = dice[element] + 1
      else dice[element] = 1 end
    end
  end
  local spell = spells[id]
  local flex = spell.flex
  local physical = spell.slots - flex
  if physical == 0 then
    if flex_die >= spell.slots then
      return true
    end
  end
  for _,element in ipairs(spell.dice) do
    if dice[element] then
      if dice[element] >= spell.slots then
        return true
      elseif dice[element] >= physical then
        if dice[element] + flex_die >= spell.slots then
          return true
        end
      end
    end
  end
  return false
end

--[[ Called from setNextPlayer (on turn "done") --]]
function refillCards()
  if env.test.trace then log("Global: refillCards()") end
  refillSpells()
  refillAlterations()
  refillHeroics()
end

--[[ Shift spell cards left to fill empty spaces, placing new cards in rightmost spot. --]]
function refillSpells()
  if env.test.trace then log("Global: refillSpells()") end
  local empty = 0
  for i=1,6 do
    if GD.game.spells[i].card_guid == "" then empty = empty + 1 end
  end
  for n=1,empty do
    for i=1,5 do
      if GD.game.spells[i].card_guid == "" then
        for j=i+1,6 do
          card = getObjectFromGUID(GD.game.spells[j].card_guid)
          if card ~= nil then
            card.setPosition(GD.game.spells[j-1].pos)
            GD.game.spells[j-1].card_id = GD.game.spells[j].card_id
            GD.game.spells[j-1].card_guid = GD.game.spells[j].card_guid
            GD.game.spells[j].card_id = 0
            GD.game.spells[j].card_guid = ""
          end
        end
      end
    end
  end
  --now fill empty spots with cards
  for i=6-(empty-1),6 do
    local deck = getSpellsDeck()
    if deck then
      local card
      if deck.tag == "Deck" then
        card = deck.takeObject({
          position = GD.game.spells[i].pos,
          flip = true,
          top = true,
          smooth = false,
          callback_function = function(obj)
            GD.game.spells[i].card_id = tonumber(obj.getGMNotes())
            GD.game.spells[i].card_guid = card.getGUID()
            Wait.condition(function() obj.setLock(true) end,
              function() return obj.resting end)
            end
        })
      elseif deck.tag == "Card" then
        card = deck
        GD.game.spells[i].card_id = tonumber(card.getGMNotes())
        GD.game.spells[i].card_guid = card.getGUID()
      else
        log("ERROR: Global: refillSpells() unknown spell deck object")
      end
    else
      log("WARN: spells deck is empty!")  --not sure this can ever happen, but warn anyway.
    end
  end
end

--[[ Place acuity on remaining cards to left of rightmost empty spot.
    Then shift cards left to fill empty spaces, placing new cards in rightmost spot.
    Move acuity with the cards. --]]
function refillAlterations()
  if env.test.trace then log("Global: refillAlterations()") end
  log("----- >>>> TODO: fix refillAlterations()")
  --TODO: see refillSpells()

  -- local p = {
  --   origin       = {},
  --   direction    = {0,1,0},
  --   type         = 3,
  --   size         = {1,2,2},
  --   max_distance = 0,
  --   debug        = true,
  -- }
  -- local deck = getAlterationsDeck()
  -- if not(deck) then
  --   log("--TODO: Global:refillAlterations() handle empty alteration deck!")
  --   return
  -- end
  -- --Set up current condition (find cards, empty spots and current acuity on cards)
  -- local spots = {}
  -- local acuity = {}
  -- local empty_spots = 0
  -- local rightmost_empty = 0
  -- for i=1,6 do
  --   acuity[i] = {}
  --   p.origin =  C.pos.alterations[i]
  --   local hits = Physics.cast(p)
  --   local empty = true
  --   if hits ~= nil then
  --     for _,hit in ipairs(hits) do
  --       if hit.hit_object.tag ~= "Surface" then
  --         if hit.hit_object.hasTag("Alteration") then
  --           spots[i] = hit.hit_object.getGUID()
  --           empty = false
  --         elseif hit.hit_object.hasTag("Acuity") then
  --           table.insert(acuity[i], hit.hit_object.getGUID())
  --         end
  --       end
  --     end
  --   end
  --   if empty then
  --     spots[i] = "-"
  --     empty_spots = empty_spots + 1
  --     rightmost_empty = i
  --   end
  -- end
  -- if env.test.debug then log("Rightmost empty is "..tostring(rightmost_empty)) end
  --
  -- --add acuity to remaining cards left of rightmost empty BEFORE shifting, update current acuity table
  -- local n = rightmost_empty-1
  -- local new_acuity = {}
  -- if n >= 1 then
  --   local bag = getObjectFromGUID(C.guids.acuity_bag)
  --   for i=1,n do
  --     if spots[i] ~= "-" then
  --       local pos = Vector(C.pos.alterations[i])
  --       pos.y = pos.y + 3
  --       pos = scatter(pos, {0.4,0,0.4}, {0.1,0,0.1})
  --       local o = bag.takeObject({
  --         callback_function = function(obj)
  --           obj.setPositionSmooth(pos, false, false)
  --         end })
  --       table.insert(new_acuity, o)
  --       table.insert(acuity[i], o.getGUID())
  --     end
  --   end
  -- end
  -- --recursively shift cards left into empty spots and fill right most empty spot(s)
  -- local function shift(empty_spots)
  --   for i=1,6 do
  --     if spots[i] == "-" then
  --       for j=i+1,6 do
  --         local pos = C.pos.alterations[j-1]
  --         card = getObjectFromGUID(spots[j])
  --         if card ~= nil then
  --           card.setPosition(pos)
  --           spots[j-1] = spots[j]
  --           spots[j] = "-"
  --           for _,g in ipairs(acuity[j]) do
  --             local o = getObjectFromGUID(g)
  --             local delta_x = C.pos.alterations[j][1] - C.pos.alterations[j-1][1]
  --             local o_pos = o.getPosition()
  --             o_pos.x = o_pos.x - delta_x
  --             o.setPositionSmooth(o_pos, false, true)
  --             table.insert(acuity[j-1], g)
  --           end
  --           acuity[j] = {}
  --         end
  --       end
  --     end
  --   end
  --   local card = deck.takeObject({
  --     ["position"] = C.pos.alterations[6],
  --     ["flip"] = true,
  --     ["top"] = true,
  --     ["smooth"] = false
  --   })
  --   spots[6] = card.getGUID()
  --   empty_spots = empty_spots - 1
  --   if empty_spots > 0 then
  --     Wait.time(function() shift(empty_spots) end, .5)
  --   end
  -- end
  --
  -- --After placing any new acuity, start shifting cards left to fill empty spaces.
  -- if empty_spots > 0 then
  --   if #new_acuity > 0 then
  --     --New acuity placed so wait until all are resting before shifting
  --     Wait.condition(function() shift(empty_spots) end,
  --       function()
  --         for _,o in ipairs(new_acuity) do
  --           if not(o.resting) then return false end
  --         end
  --         return true
  --       end)
  --   else
  --     shift(empty_spots)
  --   end
  -- end
end

--[[ Refill the Heroics card positions. --]]
function refillHeroics()
  if env.test.trace then log("Global: refillHeroics()") end
  --only one spot should be empty during play.
  local deck = getHeroicsDeck()
  if deck then
    if deck.tag == "Deck" then
      local p = {
        ["position"] = {},
        ["flip"] = true,
        ["top"] = true,
        ["smooth"] = true
      }
      for i=1,6 do
        if GD.game.heroics[i].card_guid == "" then
          p.position = GD.game.heroics[i].pos
          p.callback_function = function(obj)
            GD.game.heroics[i].card_id = tonumber(obj.getGMNotes())
            GD.game.heroics[i].card_guid = obj.getGUID()
            Wait.condition(
              function() obj.setLock(true) end,
              function() return obj.resting end)
          end
          deck.takeObject(p)
          return
        end
      end
    else
      --last card in heroics deck. shouldn't happen but handle case anyway
      log("WARN: placing last Heroic card in deck")
      local card = deck
      for i=1,6 do
        if GD.game.heroics[i].card_guid == "" then
          card.setPosition(GD.game.heroics[i].pos)
          if card.is_face_down then card.flip() end
          Wait.condition(
            function() card.setLock(true) end,
            function() return card.resting end)
          return
        end
      end
    end
  else
    log("WARN: Heroic deck is empty.")
  end
end

--[[ Set the next player in player_order.
  Wraps to first player if last is current. ]]
function setNextPlayer()
  if env.test.trace then log("Global: setNextPlayer()") end
  if GD.game.current_player == #GD.game.player_order then
    GD.game.current_player = 1
  else
    GD.game.current_player = GD.game.current_player + 1
  end
  refillCards()
  local pcol = GD.game.player_order[GD.game.current_player]
  local board = getObjectFromGUID(GD.game.players[pcol].board_guid)
  board.call("enableActivePlayer", true)
  if env.test.auto_switch then autoSwitch(GD.game.player_order[GD.game.current_player]) end
  if GD.env.verbose then print("Active player is " .. GD.game.player_order[GD.game.current_player]) end
  --TODO: figure out how to wait for refillCards()
  Wait.time(function() startPlayerTurn(pcol) end,2)
end

--[[ Special case needed by Mystcaller board only. ]]
function getMystRuneGuid()
  return GD.game.myst_rune
end

--[[ Used by player boards during scoring --]]
function getPlayerCount()
  return #GD.game.player_order
end

--[[ Return player class board guid. --]]
function getPlayerClassBoardGUID(params)
  assert(params)
  local pdata = GD.game.players[params.player_color]
  if pdata ~= nil then
    return pdata.board_guid
  else
    log("Global: ERROR: unable to get player data")
    return ""
  end
end

--[[ Used only when player types a number on a die to change it.  Trigger update spell power for player. --]]
-- function onObjectNumberTyped(o, pcol, n)
--   if o.hasTag("Dice") and n >= 1 and n <= 6 then
--     local board = getObjectFromGUID(GD.game.players[pcol].board_guid)
--     Wait.time(function() board.call("updateSpellPower", {}) end, 0.5)
--   end
-- end
--[[ Don't allow player's to deal cards by typing a number on them. --]]
function onObjectNumberTyped(o, pcol, n)
  if env.test.debug then log("Prevented player "..pcol.." from typing number on object "..o.getGUID()) end
  return true
end

--[[ When die are randomized (re-rolled) by a player then trigger HUD update. ]]
-- function onObjectRandomize(obj, player_color)
--   if obj.hasTag("Dice") then
--     Wait.condition(function() updateHUD(player_color) end, function() return obj.resting end)
--   end
-- end

--[[ Used only to trigger a wait on dice by the appropriate player board. --]]
-- function onObjectRandomize(o, pcol)
--   if o.hasTag("Dice") then
--     local board = getObjectFromGUID(GD.game.players[pcol].board_guid)
--     board.call("waitOnDiceRoll", {})
--   end
-- end

--[[ Check Alteration cards as they enter player's hand.  Assign ownership if they are not owned. ]]
--TODO: remove this, OBE
-- function onObjectEnterZone(zone, obj)
--   if zone.tag == "Hand" then
--     if obj.hasTag("Alteration") then
--       for _,pcol in ipairs(GD.game.player_order) do
--         if contains(GD.game.players[pcol].alteration_cards, obj.getGUID()) then
--           return
--         end
--       end
--       local pcol = zone.getData()["FogColor"]
--       -- if not(contains(GD.game.players[pcol].alteration_cards, obj.getGUID())) then
--       table.insert(GD.game.players[pcol].alteration_cards, obj.getGUID())
--       if env.test.debug then log("Alteration card "..obj.getGUID().." first entered hand zone and assigned to player "..pcol) end
--       if #alterations[tonumber(obj.getGMNotes())].sigils > 0 then
--         getObjectFromGUID(GD.game.players[pcol].board_guid).call("updateScore")
--       end
--       -- end
--     end
--   end
-- end

--[[ Handle objects dropped in game.  Only certain object tags supported.  --]]
function onObjectDrop(player_color, obj)
  if GD.game.started then
    local fn
    local params = {guid = obj.getGUID()}
    if obj.hasTag("Spell") then fn = "spellDrop"
    -- elseif obj.hasTag("Acuity") then fn = "acuityDrop"
    -- elseif obj.hasTag("Dice") then fn = "diceDrop"
    elseif obj.hasTag("Alteration") then
      if contains(Player[player_color].getHandObjects(), obj) then return end --ignore moving in hand
      if contains(GD.game.players[player_color].alteration_cards, obj.getGUID()) then
        local index = tonumber(obj.getGMNotes())
        obj.setLock(true)
        showAlterationDlg(index, player_color)
        -- if alterations[tonumber(obj.getGMNotes())].discard then
        --   UI.setAttribute("alterationDiscardPanel","hidden",obj.getGUID())
        --   UI_setAttribute("alterationDiscardPanel","active","true")
        -- else
        --   params.action = "play"
        --   fn = "playAlteration"
        -- end
      end
    end
    -- if fn then
    --   if env.test.trace then log("Global: onObjectDrop() -> "..tostring(fn)) end
    --   local player_board = getObjectFromGUID(GD.game.players[player_color].board_guid)
    --   player_board.call(fn, params)
    -- end
  end
end

--[[ Handler for the alteration card action dialog. ]]
function alterationActionBtn(player, button, id)
  if env.test.trace then log("Global: alterationActionBtn() "..tostring(player.color)..", "..tostring(id)) end
  if player.color ~= GD.game.player_order[GD.game.current_player] then return end
  local action = Split(id,'_')[2]
  local success = true
  local g = UI.getAttribute("alterationDiscardPanel","hidden")
  if action == "play" or action == "discard" then
    local player_board = getObjectFromGUID(GD.game.players[player.color].board_guid)
    success = player_board.call("playAlteration", {guid=g,action=action})
  elseif action == "cancel" then
    local card = getObjectFromGUID(g)
    card.deal(1, player.color)
  else
    log("ERROR: Global: alterationActionBtn(): unknown action")
    return
  end
  if success then UI_setAttribute("alterationDiscardPanel","active","false") end
end

--[[ Show the initial Alteration card dialog when playier plays an alteration card. ]]
function showAlterationDlg(card_index, pcol)
  if env.test.trace then log("Global: showAlterationDlg() "..tostring(card_index)..", "..pcol) end
  local index = card_index or 1
  --show initial dialog set up for selection an action
  local card = alterations[index]
  assert(card, "showAlterationDlg(): can't find card data")
  if card.primary then
    UI_setAttribute("alteration_primary_action_txt","text","PRIMARY: "..card.primary.actions[1].desc)
    local or_state = false
    if #card.primary.actions > 1 then
      UI_setAttribute("alteration_primary_or_action_txt","text","OR: "..card.primary.actions[2].desc)
      or_state = true
    end
    UI_setAttribute("alteration_primary_or_action_pnl","active",or_state)
  else
    UI_setAttribute("alteration_primary_action_txt","text","undefined")
    UI_setAttribute("alteration_primary_or_action_txt","text","undefined")
  end
  if card.secondary then
    UI_setAttribute("alteration_secondary_action_txt","text","SECONDARY: "..card.secondary.desc)
  else
    UI_setAttribute("alteration_secondary_action_txt","text","undefined")
  end
  UI_setAttribute("alteration_discard_action_pnl","active",card.discard == true)
  UI_setAttribute("alteration_card_img","image","Alt-"..tostring(index))
  UI_setAttribute("alteration_pay_acuity_tbl","active",false)
  UI_setAttribute("alteration_convert_dice_tbl","active",false)
  UI_setAttribute("alteration_select_action_tbl","active",true)
  UI_setAttribute("alteration_done_pnl","active",false)
  UI_setAttribute("alteration_cancel_pnl","active",true)
  UI_setAttribute("alteration_card_panel","visibility",pcol)
  -- set up data structure
  GD.game.alteration_action = {}
  local alt = GD.game.alteration_action
  alt.player_color = pcol
  alt.card = simpleDeepCopy(card)
  alt.action = ""
  alt.acuity_paid = 0
  alt.from_dice = {}
  alt.to_dice = {}
  if env.test.debug then log(alt) end
end

function updateAlterationDlg()
  if env.test.trace then log("Global: alterationDlgHandler()") end

end

function alterationDlgHandler(player, button, id)
  if env.test.trace then log("Global: alterationDlgHandler() "..player.color..", "..tostring(id)..", "..tostring(button)) end
  if player.color ~= GD.game.player_order[GD.game.current_player] then return end
  local action = Split(id,"_")[2]
  local alt = GD.game.alteration_action

  if action == "primary" then
    log("executing primary action(s) for card "..tostring(alt.card.id))
    if alt.card.primary.requirements then
      for i,r in ipairs(alt.card.primary.requirements) do
        log("TODO: check primary action requirement "..tostring(i))
        log(r)
      end
    end
    for i,a in ipairs(alt.card.primary.actions) do
      log("TODO: "..a.desc)
    end
  elseif action == "secondary" then
    log("executing secondary action for card "..tostring(alt.card.id))
    log("TODO: "..alt.card.secondary.desc)
  elseif action == "discard" then
    log("executing discard action for card "..tostring(alt.card.id))
    log("TODO: check acuity > 0 and execute discard")
  elseif action == "done" then
    log("TODO: alteration action done button")
  elseif action == "cancel" then
    local c = getObjectFromGUID(alt.card.guid)
    assert(c, "ERROR: alterationDlgHandler(): unable to locate card object "..tostring(alt.card.guid))
    c.setLock(false)
    c.deal(1,player.color)
    GD.game.alteration_action = {}
    UI_setAttribute("alteration_card_panel","visibility","Pink")
  else
    log("ERROR: alterationDlgHandler() unknown action")
  end

  --TESTING
  -- if id == "alteration_card_img" then
  --   local index = tonumber(UI.getAttribute("alteration_card_img","hidden"))
  --   if not(index) then index = 1 end
  --   if button == "-1" then
  --     if index < 44 then showAlterationDlg(index + 1, player.color) end
  --   elseif button == "-2" then
  --     if index > 1 then showAlterationDlg(index - 1, player.color) end
  --   end
  -- end
  --/TESTING
end

--[[ Handler for Recycle Leftmost Spell button. ]]
function recycleSpellBtn(player, button, id)
  if env.test.trace then log("Global: recycleSpellBtn() "..tostring(player.color)) end
  if player.color ~= GD.game.player_order[GD.game.current_player] then return end
  -- get leftmost spell card
  local card = findObject(C.pos.spells[1], {"Card"}, {1,1,1}, env.test.debug)
  if not(card) then
    broadcastToColor("No spell card in position 1 to recycle.", player.color)
    return
  end
  -- flip face down
  if not(card.is_face_down) then card.flip() end
  -- put on bottom of spell deck
  local deck = getSpellsDeck()
  if deck then
    if deck.tag == "Deck" then
      Wait.condition(function() deck.putObject(card) end, function() return card.resting end)
    elseif deck.tag == "Card" then
      Wait.condition(function()
          local pos = deck.getPosition()
          deck.setPosition(Vector(pos.x, pos.y + 3, pos.z))
          card.setPosition(pos)
        end,
        function() return card.resting end)
      GD.game.spells_deck_guid = getSpellDeck().getGUID()
    else
      log("Global: Error: recycleSpellBtn() unknown spell deck object")
    end
  else
    card.setPosition(C.spells_deck_position)
    GD.game.spells_deck_guid = card.getGUID()
  end
  -- give player one acuity
  local board = getObjectFromGUID(GD.game.players[player.color].board_guid)
  -- board.call("dealItems", {["item_type"]="acuity",["amount"]=1})
  GD.game.players[player.color].acuity = GD.game.players[player.color].acuity + 1
end

--[[ Handler for the take Heroic button. ]]
function takeHeroicBtn(player, button, id)
  if env.test.trace then log("Global: heroicsBtn() "..tostring(player.color)..", "..tostring(id)) end
  if player.color ~= GD.game.player_order[GD.game.current_player] then return end
  local index = tonumber(Split(id,"_")[3])
  local card = getObjectFromGUID(GD.game.heroics[index].card_guid)
  assert(card, "ERROR: Global:takeHeroicBtn() could not locate card")

  --TODO:
end

--[[ Handler for the take Alteration button. ]]
function takeAlterationBtn(player, button, id)
  if env.test.trace then log("Global: takeAlterationBtn() "..tostring(player.color)..", "..tostring(id)) end
  if player.color ~= GD.game.player_order[GD.game.current_player] then return end
  local index = tonumber(Split(id,"_")[3])
  local card = getObjectFromGUID(GD.game.alterations[index].card_guid)
  assert(card, "ERROR: Global:takeAlterationBtn() could not locate card")
  local board = getObjectFromGUID(GD.game.players[player.color].board_guid)
  for _,g in ipairs(GD.game.alterations[index].acuity_guids) do
    board.call("placeObjByGUID",{guid=g})
  end
  table.insert(GD.game.players[player.color].alteration_cards, card.getGUID())
  card.deal(1,player.color)
  Wait.time(function()
    updateHUD()
    updateSpellButtons(player.color)
  end, 1)
  --TODO:
    -- decrement player take actions`
    -- hide take buttons if no more`
end

--[[ Handler for the take Spell button. ]]
function takeSpellBtn(player, button, id)
  if env.test.trace then log("Global: takeSpellBtn() "..tostring(player.color)..", "..tostring(id)) end
  if player.color ~= GD.game.player_order[GD.game.current_player] then return end
  local card_index = tonumber(Split(id,"_")[3])
  showPaySpellDlg(card_index, player.color)
end

--[[ setup persistent data for dialog and show it. --]]
function showPaySpellDlg(card_index, pcol)
  if env.test.trace then log("Global: showPaySpellDlg() "..tostring(pcol)..", "..tostring(card_index)) end
  local card = getObjectFromGUID(GD.game.spells[card_index].card_guid)
  assert(card,"showPaySpellDlg(): missing spell card object")
  local spell = spells[tonumber(card.getGMNotes())]
  local player = GD.game.players[pcol]
  assert(spell,"showPaySpellDlg() missing spell card data")
  assert(player, "showPaySpellDlg() missing player data")
  local pos = card.getPosition()
  pos.y = pos.y + 2
  card.setPosition(pos)
  card.setLock(true)
  GD.game.spell_cost = {
    card_index = card_index,
    player_color = pcol,
    element = "",
    available_dice = {},
    assigned_dice = {},
    available_mana = player.mana,
    assigned_mana = 0,
    available_acuity = player.acuity,
    assigned_acuity = 0,
    flex_spots = spell.flex,
    fixed_spots = spell.slots - spell.flex,
    slots = {},
    filled = 0,
    mana_discount = 0,
    acuity_discount = 0,
    excess_mana = 0,
    excess_acuity = 0,
  }
  local dlg = GD.game.spell_cost
  if card_index == 1 then dlg.mana_discount = 1
  elseif card_index == 2 then dlg.acuity_discount = 1 end
  --availble dice
  for i,die in ipairs(player.dice) do
    if not(die.allocated) then
      local e = C.die_elements[die.value]
      if contains(spell.dice, e) then
        table.insert(dlg.available_dice, {
          index=i,
          element=e,
        })
      end
    end
  end
  for i=1,dlg.flex_spots do
    table.insert(dlg.slots, {
      filled = false,
      die = 0,
      flex = true,
      mana = 0,
      acuity = 0,
    })
  end
  for i=1,dlg.fixed_spots do
    table.insert(dlg.slots, {
      filled = false,
      die = 0,
      flex = false,
    })
  end
  --TODO: pre-populate selections with matching fixed die if possible?
  for i=1,5 do
    UI.setClass("spell_assigned_die_"..tostring(i).."_img","die_image_inactive")
  end
  updateSpellCostDlg()
  local card_image = "Spell-"..card.getGMNotes()
  if env.test.debug then
    log("---- Clearing card image")
    UI_setAttribute("spell_cost_card_img","image","")  --HACK: trying to force image load
    Wait.time(function()
      log("---- Setting card image: "..card_image)
      UI_setAttribute("spell_cost_card_img","image",card_image)
    end,1)
  else
    UI_setAttribute("spell_cost_card_img","image",card_image)
  end
  UI_setAttribute("outer_spell_cost_panel","active",true)
  hideSpellButtons()
  enableAlterationButtons(false)
end

--[[ Update the spell cost dialog with latest data.  ]]
function updateSpellCostDlg()
  if env.test.trace then log("Global: updateSpellCostDlg") end
  local dlg = GD.game.spell_cost
  --availble resources
  UI_setAttribute("spell_cost_mana_txt","text",tostring(dlg.available_mana))
  UI_setAttribute("spell_cost_acuity_txt","text",tostring(dlg.available_acuity))
  for i,die in ipairs(dlg.available_dice) do
    UI_setAttribute("spell_cost_die_"..tostring(i).."_img","image",die.element)
    UI.setClass("spell_cost_die_"..tostring(i).."_img","die_image_active")
  end
  for i=(#dlg.available_dice+1),7 do
    UI.setClass("spell_cost_die_"..tostring(i).."_img","die_image_inactive")
  end
  --selected resources
  UI_setAttribute("spell_assigned_mana_txt","text",tostring(dlg.assigned_mana))
  UI_setAttribute("spell_assigned_acuity_txt","text",tostring(dlg.assigned_acuity))
  for i,slot in ipairs(dlg.slots) do
    if slot.filled then
      if slot.die > 0 then
        UI_setAttribute("spell_assigned_die_"..tostring(i).."_img","image",dlg.element)
        UI.setClass("spell_assigned_die_"..tostring(i).."_img","die_image_active")
      else
        UI_setAttribute("spell_assigned_die_"..tostring(i).."_img","image","Filled-flex")
        UI.setClass("spell_assigned_die_"..tostring(i).."_img","die_image_active")
      end
    else
      if slot.flex then
        --TODO: use unfilled flex slot image
        UI_setAttribute("spell_assigned_die_"..tostring(i).."_img","image","Empty-flex")
        UI.setClass("spell_assigned_die_"..tostring(i).."_img","die_image_active")
      else
        UI_setAttribute("spell_assigned_die_"..tostring(i).."_img","image","Empty-fixed")
        UI.setClass("spell_assigned_die_"..tostring(i).."_img","die_image_active")
      end
    end
  end
  local state = false
  if dlg.filled == dlg.flex_spots + dlg.fixed_spots then
    if dlg.excess_mana == 0 and dlg.excess_acuity == 0 then
      state = true
    end
  end
  UI_setAttribute("spell_cost_assign_pnl","active",state)
end

--[[ Handler for pay spell cost dialog --]]
function spellCostHandler(player, button, id)
  if env.test.trace then log("Global: spellCostHandler() "..tostring(player.color)..", "..tostring(id)) end
  if player.color ~= GD.game.player_order[GD.game.current_player] then return end
  local dlg = GD.game.spell_cost
  --////////////////////////////
  local function updateSlots()
    --initialize the table of slots
    dlg.filled = 0
    for i=1,#dlg.slots do
      dlg.slots[i].filled = false
      dlg.slots[i].die = 0
      if dlg.slots[i].flex then
        dlg.slots[i].mana = 0
        dlg.slots[i].acuity = 0
      end
    end
    --fill with fixed die first
    for i,die in ipairs(dlg.assigned_dice) do
      local s = dlg.slots[#dlg.slots - (i-1)] --fill in reverse order
      s.filled = true
      s.die = die.index
      dlg.filled = dlg.filled + 1
    end
    --fill flex slots with mana next
    local mana_discount = dlg.mana_discount
    local mana_used = 0
    for i,slot in ipairs(dlg.slots) do
      if not(slot.filled) and slot.flex then
        if mana_discount > 0 then
          slot.mana = slot.mana + 1
          mana_discount = 0  --use only once
        end
        for n=1,2 do
          if dlg.assigned_mana > mana_used then
            mana_used = mana_used + 1
            slot.mana = slot.mana + 1
          end
        end
        if math.floor((slot.mana*2 + slot.acuity) / 2) >= 2 then
          slot.filled = true
          dlg.filled = dlg.filled + 1
        end
      end
    end
    --fill flex slots with acuity last
    local acuity_discount = dlg.acuity_discount
    local acuity_used = 0
    for i,slot in ipairs(dlg.slots) do
      if not(slot.filled) and slot.flex then
        for n=1,4 do
          if acuity_discount > 0 then
            slot.acuity = slot.acuity + 1
            acuity_discount = 0  --use only once
          end
          if dlg.assigned_acuity > acuity_used then
            acuity_used = acuity_used + 1 --first mana spot in slot
            slot.acuity = slot.acuity + 1
          end
        end
        if math.floor((slot.mana*2 + slot.acuity) / 2) >= 2 then
          slot.filled = true
          dlg.filled = dlg.filled + 1
        end
      end
    end
  end
  --////////////////////////////
  local action = Split(id,"_")[3]
  if action == "cancel" then
    UI_setAttribute("outer_spell_cost_panel","active",false)
    GD.game.spell_cost = {}
    local card = getObjectFromGUID(GD.game.spells[dlg.card_index].card_guid)
    assert(card,"spellCostHandler(): missing spell card object")
    card.setLock(false)
    Wait.frames(function()
      Wait.condition(function() card.setLock(true) end, function() return card.resting end)
    end,1)
    updateSpellButtons(player.color)
    enableAlterationButtons()
  elseif action == "assign" then
    --count up only assigned acuity and/or mana to pay, accounting for discounts
    local mana = 0
    local acuity = 0
    for _,slot in ipairs(dlg.slots) do
      if slot.flex and slot.die == 0 then
        mana = mana + slot.mana
        acuity = acuity + slot.acuity
      end
    end
    if mana > 0 then mana = mana - dlg.mana_discount end
    if acuity > 0 then acuity = acuity - dlg.acuity_discount end
    if env.test.debug then
      log(dlg)
      log("Player payes "..tostring(mana).." Mana")
      log("Player payes "..tostring(acuity).." Acuity")
      for _,die in ipairs(dlg.assigned_dice) do
        log("Player pays die at index: "..tostring(die.index)..", "..die.element)
      end
    end
    local p = GD.game.players[player.color]
    local board = getObjectFromGUID(p.board_guid)
    assert(board, "ERROR: spellCostHandler(): assign: missing board")
    local card = getObjectFromGUID(GD.game.spells[dlg.card_index].card_guid)
    assert(card,"spellCostHandler(): assign: missing spell card object")
    card.setLock(false)
    board.call("placeObjByGUID", {guid=card.getGUID()})
    board.call("setUI",{id="next_player_pnl",field="active",value=true})
    GD.game.spells[dlg.card_index].card_id = 0
    GD.game.spells[dlg.card_index].card_guid = ""
    p.mana = p.mana - mana
    p.acuity = p.acuity - acuity
    for  _,die in ipairs(dlg.assigned_dice) do
      p.dice[die.index].allocated = true
    end
    local index = #p.actions.takes
    for i,take in ipairs(p.actions.takes) do
      if take == "spell" then index=i; break end --priortize remove spell take
    end
    table.remove(p.actions.takes, index)
    UI_setAttribute("outer_spell_cost_panel","active",false)
    if #p.actions.takes == 0 then
      hideSpellButtons()
      enableAlterationButtons(false)
    else
      local alt_take, spell_take = false, false
      for i,take in ipairs(p.actions.takes) do
        if take == "spell" then spell_take = true end
        if take == "any" then alt_take = true; spell_take = true end
      end
      if not(alt_take) then enableAlterationButtons(false) end
      if spell_take then updateSpellbuttons(player.color)
      else hideSpellButtons() end
    end
    GD.game.spell_cost = {}
    updateHUD()
  elseif action == "mana" then
    local type = Split(id,"_")[2]
    if type == "cost" then
      if dlg.available_mana == 0 then return end --no more mana
      if dlg.filled == #dlg.slots then return end --slots full
      if dlg.filled - #dlg.assigned_dice >= dlg.flex_spots then return end -- no more flex spots
      dlg.assigned_mana = dlg.assigned_mana + 1
      dlg.available_mana = dlg.available_mana - 1
      updateSlots()
    elseif type == "assigned" then
      -- log("------ decrement mana")
      if dlg.assigned_mana == 0 then return end --no more mana assigned
      dlg.assigned_mana = dlg.assigned_mana - 1
      dlg.available_mana = dlg.available_mana + 1
      updateSlots()
    else
      log("ERROR: spellCostHandler() unknown mana action type")
      return
    end
    updateSpellCostDlg()
  elseif action == "acuity" then
    local type = Split(id,"_")[2]
    if type == "cost" then
      if dlg.available_acuity == 0 then return end --no more mana
      if dlg.filled == #dlg.slots then return end --slots full
      if dlg.filled - #dlg.assigned_dice >= dlg.flex_spots then return end -- no more flex spots
      dlg.assigned_acuity = dlg.assigned_acuity + 1
      dlg.available_acuity = dlg.available_acuity - 1
      updateSlots()
    elseif type == "assigned" then
      if dlg.assigned_acuity == 0 then return end --no more acuity assigned
      dlg.assigned_acuity = dlg.assigned_acuity - 1
      dlg.available_acuity = dlg.available_acuity + 1
      updateSlots()
    else
      log("ERROR: spellCostHandler() unknown acuity action type")
      return
    end
    updateSpellCostDlg()
  elseif action == "die" then
    local type = Split(id,"_")[2]
    if type == "cost" then
      local i = tonumber(Split(id,"_")[4])
      local die = dlg.available_dice[i]
      if dlg.element ~= "" and die.element ~= dlg.element then
        broadcastToColor("Cannot mix element types on a spell card", player.color)
        return
      end
      if dlg.filled == #dlg.slots then return end --slots full
      if dlg.element == "" then dlg.element = die.element end
      table.insert(dlg.assigned_dice, {
        index=die.index,
        element=die.element,
        value=die.value,
      })
      table.remove(dlg.available_dice,i)
      updateSlots()
    elseif type == "assigned" then
      local i = tonumber(Split(id,"_")[4])
      if dlg.slots[i].die == 0 then return end --ignore spot without die
      if dlg.filled == 0 then return end --ignore if empty
      local die = dlg.assigned_dice[#dlg.assigned_dice]
      table.insert(dlg.available_dice, {
        index=die.index,
        element=die.element,
        value=die.value,
      })
      table.remove(dlg.assigned_dice,#dlg.assigned_dice)
      if #dlg.assigned_dice == 0 then dlg.element = "" end
      updateSlots()
    else
      log("ERROR: spellCostHandler() unknown die action type")
      return
    end
    updateSpellCostDlg()
  end
end

--[[ Handle objects picked up in game.
    Only for Spell card tags.  Used to support the decal label used
    on spells with both types of spell power.
--]]
function onObjectPickUp(player_color, obj)
  if GD.game.started then
    if obj.hasTag("Spell") then
      -- Clear any decals and buttons on a spell card when picked up
      if obj.getDecals() ~= nil then
        obj.setDecals({})
      end
      if obj.getButtons() ~= nil then
        obj.clearButtons()
      end
    end
  end
end

--[[ Handle cards leaving decks.
    Sets tooltip description if enabled.
    Update guid in LUT (just in case)
    Set name to GMNotes id just for debugging if enabled.
--]]
function onObjectLeaveContainer(container, obj)
  if container.tag == "Deck" then
    if obj.hasTag("Alteration") then
      local data = alterations[tonumber(obj.getGMNotes())]
      if GD.env.card_tooltips then
        local txt = ""
        if data.primary then
          txt = "PRIMARY: "
          for i,a in ipairs(data.primary.actions) do
            if i > 1 then txt = txt .. " OR: " end
            txt = txt .. a.desc
          end
        end
        if data.secondary then
          txt = txt .. "\nSECONDARY: "..data.secondary.desc
        end
        if data.discard then
          txt = txt .. "\nDISCARD: Spend one Acuity and then take another card."
        end
        obj.setDescription(txt)
        data.guid = obj.getGUID()
      end
      if env.test.debug then obj.setName(data.id)
      else obj.setName("") end
    elseif obj.hasTag("Spell") then
      local data = spells[tonumber(obj.getGMNotes())]
      if GD.env.card_tooltips then obj.setDescription(data.desc) end
      if env.test.debug then obj.setName(data.id)
      else obj.setName("") end
      data.guid = obj.getGUID()
    elseif obj.hasTag("Heroic") then
      local data = heroics[tonumber(obj.getGMNotes())]
      if GD.env.card_tooltips then obj.setDescription(data.desc) end
      if env.test.debug then obj.setName(data.id)
      else obj.setName("") end
      data.guid = obj.getGUID()
    end
  end
end

--[[ Locate Heroics deck.
  Update to new GUID if deck guid changed (or only one card)
  Return deck object if found (will be single card if only one left).
  Log error and return nil if no more heroics.]]                            --TODO: convert to findObject()
function getHeroicsDeck()
  if env.test.trace then log("Global: getHeroicsDeck()") end
  local deck = getObjectFromGUID(GD.game.heroics_deck_guid)
  if deck then return deck end
  -- No deck object so use cast to find it
  local p = simpleDeepCopy(C.default_cast_params)
  p.origin = C.heroics_deck_pos
  local hits = Physics.cast({p})
  if hits then
    for _,hit in pairs(hits) do
      if hit.hit_object.tag == "Deck" then
        GD.game.heroics_deck_guid = hit.hit_object.getGUID()
        return hit.hit_object
      elseif hit.hit_object.tag == "Card" then
        log("WARN: Global: getHeroicsDeck(): returning last card")
        return hit.hit_object
      end
    end
  end
  log("ERROR: Global: getHeroicsDeck(): No deck found")
  return nil
end

--[[ Locate Alterations deck.
  Update to new GUID if deck guid changed (or only one card)
  Return deck object if found (will be single card if only one left).
  Log error and return nil if no card or deck.]]
function getAlterationsDeck()
  if env.test.trace then log("Global: getAlterationsDeck()") end
  local deck = getObjectFromGUID(GD.game.alterations_deck_guid)
  if deck then return deck end
  -- No deck object so find it
  local deck = findObject(C.alterations_deck_pos, {"Deck","Card"}, env.test.debug)
  if not(deck) then log("WARN: Global: getAlterationsDeck(): No deck found")
  else GD.game.alterations_deck_guid = deck.getGUID() end
  return deck
end

--[[ Locate Spells deck.
  Update to new GUID if deck guid changed (or only one card)
  Return deck object if found (will be single card if only one left).
  Log error and return nil if no more heroics.]]
function getSpellsDeck()
  if env.test.trace then log("Global: getSpellsDeck()") end
  local deck = getObjectFromGUID(GD.game.spells_deck_guid)
  if deck then return deck end
  -- No deck object so find it
  local deck = findObject(C.spells_deck_pos, {"Deck","Card"}, env.test.debug)
  if not(deck) then log("WARN: Global: getSpellsDeck(): No deck found")
  else GD.game.spells_deck_guid = deck.getGUID() end
  return deck
end

--[[ Update HUD UI with current data.
    player_color: (opt) if supplied update only this players info
--]]
function updateHUD(player_color)
  if env.test.trace then log("Global: updateHUD() "..tostring(player_color)) end
  local max_heroics = 4
  if GD.game.player_count == 3 then  max_heroics = 3
  elseif GD.game.player_count == 4 then max_heroics = 2 end
  local function updatePlayerHUD(i, pcol)
    local board = getObjectFromGUID(GD.game.players[pcol].board_guid)
    local score = board.call("getCurrentScore")
    local spell = board.call("getCurrentSpellPower")
    local heroics = board.call("getCurrentHeroics")
    UI_setAttribute("hud_row_"..tostring(i).."_spell", "text", tostring(spell.power))
    if spell.type ~= "None" then
      UI_setAttribute("hud_row_"..tostring(i).."_image", "image", tostring(spell.type))
      UI_setAttribute("hud_row_"..tostring(i).."_image", "active", "true")
    else
      UI_setAttribute("hud_row_"..tostring(i).."_image", "active", "false")
    end
    UI_setAttribute("hud_row_"..tostring(i).."_heroics", "text", tostring(heroics).." / "..tostring(max_heroics))
    UI_setAttribute("hud_row_"..tostring(i).."_score", "text", tostring(score))
    for i,d in ipairs(GD.game.players[pcol].dice) do
      local id = pcol.."_hud_die_"..tostring(i).."_image"
      if d.allocated then
        UI.setClass(id, "die_image_inactive")
      else
        UI.setAttribute(id,"image",C.die_elements[d.value])
        UI.setClass(id, "die_image_active")
      end
    end
    UI_setAttribute(pcol.."_hud_mana_text","text",tostring(GD.game.players[pcol].mana))
    UI_setAttribute(pcol.."_hud_acuity_text","text",tostring(GD.game.players[pcol].acuity))
  end
  if player_color ~= nil then
    updatePlayerHUD(indexOf(GD.game.player_order, player_color), player_color)
  else
    for i,pcol in ipairs(GD.game.player_order) do
      updatePlayerHUD(i, pcol)
    end
  end
end

--[[ Final game scoring.
  tiebreaker: first #arcanas, then #spells --]]
function finalScore()
  if env.test.trace then log("Global: finalScore()") end
  local scores = {}
  for color,pinfo in pairs(GD.game.players) do
    local pdata = {}
    pdata.player = color
    pdata.class = pinfo.class
    local board = getObjectFromGUID(pinfo.board_guid)
    board.call("updateScore", {})
    local bd=board.getTable("GD")
    local values = bd.board.scoring.values
    pdata.total = 0
    pdata.heroics = values.heroics
    pdata.total = pdata.total + values.heroics
    pdata.sigils = values.sigils
    pdata.total = pdata.total + values.sigils
    pdata.prestige = values.prestige
    pdata.total = pdata.total + values.prestige
    pdata.arcanas = values.arcanas
    pdata.total = pdata.total + values.arcanas
    pdata.num_arcanas = sizeOf(bd.board.scoring.arcanas)
    pdata.num_spells = sizeOf(bd.board.scoring.spells)
    local new_data = simpleDeepCopy(pdata)
    if #scores == 0 then
      table.insert(scores, new_data)
    else
      local found = false
      for i=1,#scores do
        if new_data.total > scores[i].total then
          table.insert(scores, i, new_data)
          found = true
          break
        elseif new_data.total == scores[i].total then
          --first tie breaker
          if new_data.num_arcanas > scores[i].num_arcanas then
            print(new_data.player.." wins 1st tie breaker with "..scores[i].player.." on #arcanas")
            table.insert(scores, i, new_data)
            found = true
            break
          elseif new_data.num_arcanas == scores[i].num_arcanas then
            --second tie breaker
            if new_data.num_spells > scores[i].num_spells then
              print(new_data.player.." wins 2nd tie breaker with "..scores[i].player.." on #spells")
              table.insert(scores, i, new_data)
              found = true
              break
            else
              print(new_data.player.." and "..scores[i].player.." still tied after all tie breakers.")
            end
          end
        end
      end
      if not(found) then
        table.insert(scores, #scores + 1, new_data)
      end
    end
  end
  --update the score display and show it
  log("score:")
  log(scores)
  local i = 1
  for _,data in ipairs(scores) do
    UI_setAttribute("score_table_row_"..tostring(i).."_text_1", "text", data.player)
    UI_setAttribute("score_table_row_"..tostring(i).."_text_2", "text", data.class)
    UI_setAttribute("score_table_row_"..tostring(i).."_text_3", "text", data.heroics)
    UI_setAttribute("score_table_row_"..tostring(i).."_text_4", "text", data.sigils)
    UI_setAttribute("score_table_row_"..tostring(i).."_text_5", "text", data.prestige)
    UI_setAttribute("score_table_row_"..tostring(i).."_text_6", "text", data.arcanas)
    UI_setAttribute("score_table_row_"..tostring(i).."_text_7", "text", data.total)
    i = i + 1
  end
  broadcastToAll(scores[1].player.." wins the game!!!")
  UI_show("score_panel")
end

--[[ ******** UTILITY ******** --]]

-- function simpleDeepCopy(orig)
--     local orig_type = type(orig)
--     local copy
--     if orig_type == 'table' then
--         copy = {}
--         for orig_key, orig_value in next, orig, nil do
--             copy[simpleDeepCopy(orig_key)] = simpleDeepCopy(orig_value)
--         end
--         setmetatable(copy, simpleDeepCopy(getmetatable(orig)))
--     else -- number, string, boolean, etc
--         copy = orig
--     end
--     return copy
-- end

--[[ Get obj position (DEVELOPMENT ONLY) ]]
function savePosition(g)
  local o = getObjectFromGUID(g)
  Notes.setNotes(tostring(o.getPosition()))
end

--[[ Get obj rotation (DEVELOPMENT ONLY) ]]
function saveRotation(g)
  local o = getObjectFromGUID(g)
  Notes.setNotes(tostring(o.getRotation()))
end

-- require("tts-lib/utils")
#include ~/github/tts-lib/utils.ttslua
#include ~/github/tts-mercurial/Constants.ttslua
#include ~/github/tts-mercurial/Cards.ttslua
