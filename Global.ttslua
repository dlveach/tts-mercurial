

env = {}
env.version = "0.1"
env.test= {}
env.test.test_players = {"Green", "Blue", "Yellow", "White"}
--env.test.test_players = {"Yellow", "White"}
env.test.auto_switch = true
env.test.in_dev = true
env.test.trace = true
env.test.debug = true
env.test.force_fresh_save = false
env.game = {}
env.game.player_table_order = {"White", "Yellow", "Green", "Blue"}
env.game.verbose = true

C = {}
C.guids = {}
C.guids.mystcaller_base = "2c961c"
C.guids.player_boards = {}
C.guids.player_boards.mystcaller = "be09eb"
C.guids.player_boards.elementalist = "e47526"
C.guids.player_boards.archanist = "625f56"
C.guids.player_boards.enchanter = "69525a"
C.guids.player_boards.chaosmancer = "d453e1"
C.guids.spell_deck = "85f568"
C.guids.alterations_deck = "2d1923"
C.guids.heroics_deck = "edf655"
C.guids.artifacts_deck = "675a94"
C.guids.mana_bag = "a39f6e"
C.guids.acuity_bag = "5561d3"
C.guids.prestige_bag = "d5b6a6"
C.guids.arcana_tile_1 = "8f529c"
C.guids.arcana_tile_2 = "5f944b"
C.guids.arcana_tile_3 = "a94aad"
C.guids.myst_rune_1 = "3444cf"
C.guids.myst_rune_2 = "8b61f9"
C.guids.fill_alterations_btn = "c19ef3"
C.pos = {}
C.rot = {}
C.pos.spells = {}
C.pos.spells[0] = { -5.681618, 0.973605, -17.186279 }
C.pos.spells[1] = { -2.8328, 0.973605, -17.190039 }
C.pos.spells[2] = { -0.016532, 0.973605, -17.200249 }
C.pos.spells[3] = { 2.795382, 0.973605, -17.228243 }
C.pos.spells[4] = { 5.660338, 0.973605, -17.234106 }
C.pos.spells[5] = { 8.457616, 0.973605, -17.247536 }
C.pos.alterations = {}
C.pos.alterations[0] = { -5.677478, 0.973605, -8.856833 }
C.pos.alterations[1] = { -2.828662, 0.973605, -8.860592 }
C.pos.alterations[2] = { -0.012393, 0.973605, -8.870802 }
C.pos.alterations[3] = { 2.799521, 0.973605, -8.898796 }
C.pos.alterations[4] = { 5.664477, 0.973605, -8.904659 }
C.pos.alterations[5] = { 8.461753, 0.973605, -8.918089 }
C.pos.heroics = {}
C.pos.heroics[0] = { -5.681297, 0.973605, -0.209943 }
C.pos.heroics[1] = { -2.832476, 0.973605, -0.213703 }
C.pos.heroics[2] = { -0.016209, 0.973605, -0.223913 }
C.pos.heroics[3] = { 2.795707, 0.973605, -0.251907 }
C.pos.heroics[4] = { 5.660657, 0.973605, -0.257771 }
C.pos.heroics[5] = { 8.457934, 0.973605, -0.2712 }
C.pos.myst_rune = { 12.057961, 0.96, 5.3963 }
C.rot.myst_rune = { 0.000035, 270.16687, 0.000004 }

--[[ Game is loading. ]]
function onLoad(saved_data)
  log("Mercurial version " .. env.version .. " loading")
  GD = {}
  if saved_data ~= "" then
    if env.test.trace then log("Global onLoad(): Saved load") end
    local restore_data = JSON.decode(saved_data)
    GD = restore_data
    restoreGameState()
  else
    if env.test.trace then log("Global onLoad(): Fresh load") end
    GD.states = {}
    GD.states.UI = {}
    GD.states.obj_vis = {}
    GD.game = {}
    GD.game.started = false
    GD.game.spells_deck_guid = C.guids.spell_deck
    GD.game.alterations_deck_guid = C.guids.alterations_deck
    GD.game.heroics_deck_guid = C.guids.heroics_deck
    GD.game.artifacts_deck_guid = C.guids.artifacts_deck
    GD.game.players = {}
    if not(env.test.in_dev) then
      --TODO??
    end
    getObjectFromGUID(C.guids.spell_deck).shuffle()
    getObjectFromGUID(C.guids.alterations_deck).shuffle()
    getObjectFromGUID(C.guids.heroics_deck).shuffle()
    getObjectFromGUID(C.guids.artifacts_deck).shuffle()
    UI_setAttribute("startPanel", "active", true)
    local btn = getObjectFromGUID(C.guids.fill_alterations_btn)
    setInvisibleTo(btn.getGUID(), env.game.player_table_order)
  end
  math.randomseed(os.time())
  --start the refill alterations watcher
  Timer.create({
    identifier     = "Alterations_watcher",
    function_name  = "checkFillAlterations",
    delay          = 2,
    repetitions    = 0,
  })
end

--[[ Wrapper function for saving obj visiblity for game restore. ]]
function setInvisibleTo(guid, colors)
  if env.test.trace then log("setInvisibleTo(): "..guid) end
  assert(type(guid) == 'string', "guid must be a string")
  assert(colors)
  getObjectFromGUID(guid).setInvisibleTo(colors)
  GD.states.obj_vis[guid] = colors
end
  
--[[  Wrapper function for saving UI attributes for game restore. ]]
function UI_setAttribute(id, field, value)
  if env.test.trace and env.game.verbose then log("UI_setAttribute()") end
  assert(type(id) == "string", "id must be a string")
  assert(type(field) == "string", "field must be a string")
  UI.setAttribute(id, field, value)
  GD.states.UI[id..":"..field] = value
end
  
--[[ Save game state ]]
function onSave()
  local data_to_save = GD
  local saved_data = JSON.encode(data_to_save)
  if env.test.force_fresh_save then
    saved_data = ""
  end
  return saved_data
end

--[[ Restore game state from saved load. ]]
function restoreGameState()
  if env.test.trace then log("restoreGameState()") end
  --restore object visiblity
  for g,colors in pairs(GD.states.obj_vis) do
    local obj = getObjectFromGUID(g)
    if obj then obj.setInvisibleTo(colors) end
  end
  --restore UI state
  for key,value in pairs(GD.states.UI) do
    local id = Split(key, ':')[1]
    local field = Split(key, ':')[2]
    UI.setAttribute(id, field, value)
  end
end

--[[ Button handler for "Start Game".  Setup player order and
    enable class board selection. ]]
function startGameBtn()
  UI_setAttribute("startPanel", "active", false)
  GD.game.player_order = {}
  GD.game.players = {}
  local seated = getSeatedPlayers()
  if(env.test.test_players) then
    seated = env.test.test_players
  end
  --getSeatedPlayers() is random, use table order
  for _,pcol in ipairs(env.game.player_table_order) do
    if contains(seated, pcol) then
      GD.game.players[pcol] = {}
      table.insert(GD.game.player_order, pcol)
    end
  end
  GD.game.player_count = #GD.game.player_order
  GD.game.start_player = math.random(1, #GD.game.player_order)
  GD.game.current_player = GD.game.start_player
  if (math.random(1, 10) > 5) then
    GD.game.myst_rune = C.guids.myst_rune_1
  else
    GD.game.myst_rune = C.guids.myst_rune_2
  end
  if env.game.verbose then 
    local order = GD.game.player_order[GD.game.start_player]
    local p = GD.game.start_player
    for i=1, #GD.game.player_order - 1 do
      p = p + 1
      if p > #GD.game.player_order then p = 1 end
      order = order .. ", " .. GD.game.player_order[p]
    end
    print("Player order is " .. order)
  end
  -- Enable class select buttons
  for class, guid in pairs(C.guids.player_boards) do
    local class_board = getObjectFromGUID(guid)
    assert(class_board)
    class_board.call("enableClassSelectBtn")
  end
  GD.game.assigned_boards_count = 0
  broadcastToAll("In reverse player order players select one mage class to comlpete setup.")
end

--[[ Called from player board on class select.
    If player is unnassigned, set associations to player board.
    Otherwise show error message and return with no action.
    Calls back to player board to finish setup if successful. ]]
function setPlayerClass(params)  
  if env.test.trace then log("Global: setPlayerClass()") end
  assert(params.player)
  assert(params.guid)
  local pcol = params.player
  if not(contains(GD.game.player_order, pcol)) then
    broadcastToAll("Player " .. pcol .. " is not a player in this game.")
    return
  elseif GD.game.players[pcol].class then
    broadcastToColor("Player " .. pcol .. " cannot select a second class.", pcol)
    return
  else
    local class_board = getObjectFromGUID(params.guid)
    assert(class_board)
    if env.game.verbose then print("Player " .. pcol .. " selected class " .. class_board.getName()) end
    GD.game.players[pcol].class = class_board.getName()
    GD.game.players[pcol].board_guid = class_board.getGUID()
    --complete player assignment in board
    class_board.call("setPlayer", {["player"]=pcol})  
    GD.game.assigned_boards_count = GD.game.assigned_boards_count + 1
  end
  --If all players assigned to boards, do final setup    
  if GD.game.assigned_boards_count == GD.game.player_count then finalSetup() end
end

--[[ Final game setup after all players have selected a class. ]]
function finalSetup()
  if env.test.trace then log("Global: finalSetup()") end
  --cleanup unused boards
  for _,guid in pairs(C.guids.player_boards) do
    getObjectFromGUID(guid).call("setupBoard")
  end  
  --deal out starting cards
  local p = {
    ["position"] = {},
    ["flip"] = true,
    ["top"] = true,
    ["smooth"] = true
  }
  local deck = getObjectFromGUID(C.guids.spell_deck)
  for i=0,5 do --TODO: fix zero index
    p.position = C.pos.spells[i]
    deck.takeObject(p)
  end
  deck = getObjectFromGUID(C.guids.alterations_deck)
  for i=0,5 do  --TODO: fix zero index
    p.position = C.pos.alterations[i]
    deck.takeObject(p)
  end
  local card = 1
  Wait.time(function() 
    if card > 6 then return end -- safety
    placeHeroic(Vector(C.pos.heroics[card - 1]), 1)  --TODO: fix zero index
    card = card + 1
  end, .25, 6)
 -- Place acuity on alterations per player count
  local acuity_bag = getObjectFromGUID(C.guids.acuity_bag)
  for i=1, GD.game.player_count do
    local pos = Vector(C.pos.alterations[i-1])  --TODO: fix zero index
    pos.y = pos.y + 1
    acuity_bag.takeObject({ callback_function = function(obj) obj.setPositionSmooth(pos, false, false) end }) 
  end
  -- Place the previously random selected myst rune (if Mystcaller not taken)
  local mystcaller = false
  for _,p in pairs(GD.game.players) do
    if p.class == "Mystcaller" then mystcaller = true end
  end
  if not(mystcaller) then
    local myst_rune = getObjectFromGUID(GD.game.myst_rune)
    myst_rune.setPositionSmooth(C.pos.myst_rune)
    myst_rune.setRotation(C.rot.myst_rune)
  end
  -- Random flip arcanas
  if (math.random(1, 10) > 5) then getObjectFromGUID(C.guids.arcana_tile_1).flip() end
  if (math.random(1, 10) > 5) then getObjectFromGUID(C.guids.arcana_tile_2).flip() end
  if (math.random(1, 10) > 5) then getObjectFromGUID(C.guids.arcana_tile_3).flip() end
  -- Give extra acuity to players in turn order 
  local player = GD.game.start_player 
  local count = 1
  Wait.time(
    function()
      player = player + 1
      if player > GD.game.player_count then player = 1 end --wrap around
      player_color = GD.game.player_order[player]
      if env.game.verbose then print("Dealing " .. count .. " extra acuity to player " .. count+1 .. " - " .. player_color) end
      local board = getObjectFromGUID(GD.game.players[player_color].board_guid)
      board.call("dealAcuity", {["amount"]=count})
      count = count + 1
    end, 
    .5, 
    GD.game.player_count-1
  )
  local pcol = GD.game.player_order[GD.game.current_player]
  local board = getObjectFromGUID(GD.game.players[pcol].board_guid)
  board.call("enableActivePlayer")
  if env.game.verbose then print("Active player is " .. GD.game.player_order[GD.game.current_player]) end
  local btn = getObjectFromGUID(C.guids.fill_alterations_btn)
  btn.UI.setAttribute("button_panel", "active", "true")
  GD.game.started = true
end

--[[ Place a heroic card and the bonus bits on it.
    Recursive to add delay for placing bits.   --]]
function placeHeroic(location, iteration)
  if iteration > 4 then return end
  local acuity_bag = getObjectFromGUID(C.guids.acuity_bag)
  local mana_bag = getObjectFromGUID(C.guids.mana_bag)
  local pos = Vector(location)
  if iteration == 1 then
    getObjectFromGUID(C.guids.heroics_deck).takeObject({
      ["position"] = pos,
      ["flip"] = true,
      ["top"] = true,
      ["smooth"] = false
    })
  elseif iteration == 2 then
    pos.y = 1
    mana_bag.takeObject({ callback_function = function(obj) obj.setPositionSmooth(pos, false, false) end })
  elseif iteration == 3 then
    pos.y = 2
    pos.z = pos.z - 1
    acuity_bag.takeObject({ callback_function = function(obj) obj.setPositionSmooth(pos, false, false) end })
  elseif iteration == 4 then
    pos.y = 3
    pos.z = pos.z + 1
    acuity_bag.takeObject({ callback_function = function(obj) obj.setPositionSmooth(pos, false, false) end })
  end
  iteration = iteration + 1
  Wait.frames(function() placeHeroic(location, iteration) end, 10)
end  

--[[ Called from setNextPlayer (on turn "done") --]]
function refillCards()
  if env.test.trace then log("Global: refillCards()") end
  refillSpells()
  refillAlterations()
  refillHeroics()
end

--[[ Shift spell cards left to fill empty spaces, placing new cards in rightmost spot. --]]
function refillSpells()
  if env.test.trace then log("Global: refillSpells()") end
  local p = {
    origin       = {},
    direction    = {0,1,0},
    type         = 3,
    size         = {2.4,2,4.2},
    max_distance = 0,
    debug        = false,    
  }  
  local deck = getObjectFromGUID(C.guids.spell_deck)
  local spots = {}
  local empty_spots = 0
  for i=0,5 do  --TODO: fix 0 index
    p.origin =  C.pos.spells[i]
    local hits = Physics.cast(p)
    local empty = true
    if hits ~= nil then
      for _,hit in ipairs(hits) do
        if hit.hit_object.tag ~= "Surface" then
          if hit.hit_object.hasTag("Spell") then
            spots[i] = hit.hit_object.getGUID()
            empty = false
          end
        end
      end
    end
    if empty then 
      spots[i] = "-"
      empty_spots = empty_spots + 1
    end
  end
  --recursively shift cards left into empty spots and fill last spot
  local function shift(empty_spots)
    for i=0,5 do
      if spots[i] == "-" then
        for j=i+1,5 do
          local pos = C.pos.spells[j-1]
          card = getObjectFromGUID(spots[j])
          if card ~= nil then 
            card.setPosition(pos)
            spots[j-1] = spots[j]
            spots[j] = "-"
          end
        end
      end
    end
    local card = deck.takeObject({
      ["position"] = C.pos.spells[5],
      ["flip"] = true,
      ["top"] = true,
      ["smooth"] = false
    })
    spots[5] = card.getGUID()
    empty_spots = empty_spots - 1
    if empty_spots > 0 then
      Wait.frames(function() shift(empty_spots) end, 1)
    end
  end
  if empty_spots > 0 then
    shift(empty_spots)
  end
end

--[[ Timer watchdog.  Sstarted in onLoad(). 
    If any Alteration positions are empty, show fill button. 
    Otherwise hide it.  --]]
    --TODO: consider using a script zone??? 
function checkFillAlterations()
  if not(GD.game.started) then return end
  local p = {
    origin       = {},
    direction    = {0,1,0},
    type         = 3,
    size         = {2.4,2,4.2},
    max_distance = 0,
    debug        = false,    
  }  
  local btn = getObjectFromGUID(C.guids.fill_alterations_btn)
  for i=0,5 do  --TODO: fix 0 index
    p.origin =  C.pos.alterations[i]
    local hits = Physics.cast(p)
    local empty = true
    if hits ~= nil then
      for _,hit in ipairs(hits) do
        if hit.hit_object.tag ~= "Surface" then
          if hit.hit_object.hasTag("Alteration") then
            empty = false
          end
        end
      end
    end
    if empty then 
      btn.UI.setAttribute("button_panel", "active", "true")
      return
    end
  end
  btn.UI.setAttribute("button_panel", "active", "false")
end

--[[ Handler for fill alterations button.   --]]
function refillAlterationsBtn(player, button, id)
  if env.test.trace then log("Global: refillAlterationsBtn() pressed by "..player.color) end
  local btn = getObjectFromGUID(C.guids.fill_alterations_btn)
  btn.UI.setAttribute("button_panel", "active", "false")
  refillAlterations()
end

--[[ Shift spell cards left to fill empty spaces, placing new cards in rightmost spot. 
    Move any acuity with cards.  If leftmost card was not taken, add acuity to it. --]]
function refillAlterations()
  if env.test.trace then log("Global: refillAlterations()") end
  local p = {
    origin       = {},
    direction    = {0,1,0},
    type         = 3,
    size         = {2.4,2,4.2},
    max_distance = 0,
    debug        = false,    
  }  
  local deck = getObjectFromGUID(C.guids.alterations_deck)
  local spots = {}
  local acuity = {}
  local empty_spots = 0
  for i=0,5 do  --TODO: fix 0 index
    acuity[i] = {}
    p.origin =  C.pos.alterations[i]
    local hits = Physics.cast(p)
    local empty = true
    if hits ~= nil then
      for _,hit in ipairs(hits) do
        if hit.hit_object.tag ~= "Surface" then
          if hit.hit_object.hasTag("Alteration") then
            spots[i] = hit.hit_object.getGUID()
            empty = false
          elseif hit.hit_object.hasTag("Acuity") then
            table.insert(acuity[i], hit.hit_object.getGUID())
          end
        end
      end
    end
    if empty then 
      spots[i] = "-"
      empty_spots = empty_spots + 1
    end
  end
  --add acuity to left most spot if not empty and a card taken
  if spots[0] ~= "-" and empty_spots > 0 then 
    local bag = getObjectFromGUID(C.guids.acuity_bag)
    local pos = Vector(C.pos.alterations[0])  --TODO: fix zero index
    pos.y = pos.y + 3
    pos = scatter(pos, {1,0,1.5})
    bag.takeObject({ callback_function = function(obj) obj.setPositionSmooth(pos, false, false) end }) 
  end
  --recursively shift cards left into empty spots and fill last spot
  local function shift(empty_spots)
    for i=0,5 do  --TODO: fix zero index
      if spots[i] == "-" then
        for j=i+1,5 do
          local pos = C.pos.alterations[j-1]
          card = getObjectFromGUID(spots[j])
          if card ~= nil then 
            card.setPosition(pos)
            spots[j-1] = spots[j]
            spots[j] = "-"
            for _,g in ipairs(acuity[j]) do
              local o = getObjectFromGUID(g)
              local delta_x = C.pos.alterations[j][1] - C.pos.alterations[j-1][1]
              local o_pos = o.getPosition()
              o_pos.x = o_pos.x - delta_x
              log(o_pos)
              o.setPositionSmooth(o_pos, false, true)
              table.insert(acuity[j-1], g)
            end
            acuity[j] = {} 
          end
        end
      end
    end
    local card = deck.takeObject({
      ["position"] = C.pos.alterations[5],
      ["flip"] = true,
      ["top"] = true,
      ["smooth"] = false
    })
    spots[5] = card.getGUID()
    empty_spots = empty_spots - 1
    if empty_spots > 0 then
      Wait.time(function() shift(empty_spots) end, 1)
    end
  end
  if empty_spots > 0 then
    shift(empty_spots)
  end
end

--[[ Refill the Heroics card positions. --]]
function refillHeroics()
  if env.test.trace then log("Global: refillHeroics()") end
  local p = {
    origin       = {},
    direction    = {0,1,0},
    type         = 3,
    size         = {2.4,2,4.2},
    max_distance = 0,
    debug        = false,    
  }  
  local deck = getObjectFromGUID(C.guids.heroics_deck)
  local empty_spots = {}
  for i=0,5 do  --TODO: fix 0 index
    p.origin =  C.pos.heroics[i]
    local hits = Physics.cast(p)
    local empty = true
    if hits ~= nil then
      for _,hit in ipairs(hits) do
        if hit.hit_object.tag ~= "Surface" then
          if hit.hit_object.hasTag("Heroic") then empty = false end
        end
      end
    end
    if empty then  table.insert(empty_spots, C.pos.heroics[i]) end
  end
  --fill the spot(s).  Recursive to add delay between.
  local function fillSpot()
    if empty_spots[1] == nil then return end 
    placeHeroic(Vector(empty_spots[1]), 1) 
    table.remove(empty_spots, 1)
    Wait.frames(function() fillSpot() end, 30)    
  end
  if #empty_spots > 0 then
    fillSpot()
  end
end

--[[ Set the next player in player_order.  
  Wraps to first player if last is current. ]]
function setNextPlayer()
  if env.test.trace then log("Global: setNextPlayer()") end
  if GD.game.current_player == #GD.game.player_order then
    GD.game.current_player = 1
  else
    GD.game.current_player = GD.game.current_player + 1
  end
  refillCards()
  local pcol = GD.game.player_order[GD.game.current_player]
  local board = getObjectFromGUID(GD.game.players[pcol].board_guid)
  board.call("enableActivePlayer")
  if env.game.verbose then print("Active player is " .. GD.game.player_order[GD.game.current_player]) end
end

--[[ Special case needed by Mystcaller board only. ]]
function getMystRuneGuid()
  return GD.game.myst_rune
end

--[[ ******** UTILITY ******** --]]

--[[ Get obj position (DEVELOPMENT ONLY) ]]
function savePosition(g)
  local o = getObjectFromGUID(g)
  Notes.setNotes(tostring(o.getPosition()))
end

--[[ Get obj rotation (DEVELOPMENT ONLY) ]]
  function saveRotation(g)
  local o = getObjectFromGUID(g)
  Notes.setNotes(tostring(o.getRotation()))
end

require("tts-lib/utils")
