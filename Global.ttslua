--[[ *************************************************************************

Work items for converstion of beta to production version:

  - BUG: fix arcana scoring to final rules
  - BUG: score display on player area doesn't update as often as it should.

  - TODO: start options in UI start game panel
  - TODO: auto play alteration card if no discard power on it (starting cards and artifacts)
  - TESTING: save/load/rewind

Future possible stuff for greater enhancement
  --TODO: Think about a data structure to represent avaialable Alteration card positions.
          The 6 card locations, current card guid and any Acuity guids on card.
          Would make snap back possible and shifting much easier without using Physics.cast etc.
          Also lock them and add a "Take" button at this time.
  - IN WORK: HUD display???
        - players current spell power
        - players score
        - player's current unallocated dice
        - players mana & acuity?
        - players herocs count vs max
  --TODO: track take & play actions??? (with "Take" buttons on cards, enforce limits & requirements)
  --TODO: Automate alteration play actions. A big one!
  --IN WORK: automate spell cast???
        - calcuate winnings and display "Take" buttons on Heroics/Arcanas/Prestige
        - dialog for Myst if equilibrium attained.
  --TODO: automate assinging resources to spell cards???

****************************************************************************** ]]

env = {}
env.version = "1.0 production release"
env.test= {}
-- env.test.test_players = {"Green", "Blue", "Yellow", "Red"}
-- env.test.test_players = {"Yellow", "Red", "Blue"}
-- env.test.test_players = {"Green", "Blue"}
env.test.test_players = {"Green", "Blue"}
env.test.auto_switch = true
env.test.in_dev = true
env.test.trace = true
env.test.debug = true
env.test.force_fresh_save = true
env.game = {}
env.game.player_table_order = {"Red", "Blue", "Green", "Yellow"}  --clockwise
env.game.verbose = true
env.game.card_tooltips = true

--[[ Game is loading. ]]
function onLoad(saved_data)
  log("Mercurial version " .. env.version)
  log("Loading ...")
  if not(env.test.in_dev) then
    local dice_bag = getObjectFromGUID(C.guids.dice_bag)
    dice_bag.interactable = false
    dice_bag.setInvisibleTo(Player.getColors())
  end
  for i=1,4 do
    local bar = getObjectFromGUID(C.guids.color_bars[i])
    if bar ~= nil then
      bar.interactable = false
      bar.UI.setAttribute("block_text_id", "text", "")
      bar.setInvisibleTo(Player.getColors())
    end
  end
  GD = {}
  if saved_data ~= "" then
    if env.test.trace then log("Global onLoad(): Saved load") end
    local restore_data = JSON.decode(saved_data)
    GD = restore_data
    restoreGameState()
  else
    if env.test.trace then log("Global onLoad(): Fresh load") end
    GD.states = {}
    GD.states.UI = {}
    GD.states.obj_vis = {}
    GD.game = {}
    GD.game.started = false
    GD.game.spells_deck_guid = C.guids.spells_deck
    GD.game.alterations_deck_guid = C.guids.alterations_deck
    GD.game.heroics_deck_guid = C.guids.heroics_deck
    GD.game.artifacts_deck_guid = C.guids.artifacts_deck
    GD.game.players = {}
    GD.game.positions = {}
    GD.env = {}
    GD.env.verbose = env.game.verbose
    GD.env.card_tooltips = env.game.card_tooltips
    for i=1,4 do
      GD.game.positions[i] = ""
    end
    if not(env.test.in_dev) then
      --TODO??
    end
    UI_setAttribute("startPanel", "active", true)
    setInvisibleTo(C.guids.recycle_spell_btn, Player.getColors())
  end
  math.randomseed(os.time())
  log("Loading complete.")
end

--[[ Wrapper function for saving obj visiblity for game restore. ]]
function setInvisibleTo(guid, colors)
  if env.test.trace then log("setInvisibleTo(): "..guid) end
  assert(type(guid) == 'string', "guid must be a string")
  assert(colors)
  getObjectFromGUID(guid).setInvisibleTo(colors)
  GD.states.obj_vis[guid] = colors
end

--[[  Wrapper function for saving UI attributes for game restore. ]]
function UI_setAttribute(id, field, value)
  if env.test.trace and GD.env.verbose then log("UI_setAttribute()") end
  assert(type(id) == "string", "id must be a string")
  assert(type(field) == "string", "field must be a string")
  UI.setAttribute(id, field, value)
  GD.states.UI[id..":"..field] = value
end

--[[ Wrapper function for hiding UI elements with animations. --]]
function UI_hide(id)
  UI.hide(id)
  --give it time to animate then set UI attribute for game save/load
  Wait.time(function() UI_setAttribute(id, "active", false) end, 1)
end

--[[ Wrapper function for showing UI elements with animations. --]]
function UI_show(id)
  UI.show(id)
  --give it time to animate then set UI attribute for game save/load
  Wait.time(function() UI_setAttribute(id, "active", true) end, 1)
end

--[[ Save game state ]]
function onSave()
  local data_to_save = GD
  local saved_data = JSON.encode(data_to_save)
  if env.test.force_fresh_save then
    saved_data = ""
  end
  return saved_data
end

--[[ Restore game state from saved load. ]]
function restoreGameState()
  if env.test.trace then log("restoreGameState()") end
  --restore object visiblity
  for g,colors in pairs(GD.states.obj_vis) do
    local obj = getObjectFromGUID(g)
    if obj then obj.setInvisibleTo(colors) end
  end
  --restore UI state
  for key,value in pairs(GD.states.UI) do
    local id = Split(key, ':')[1]
    local field = Split(key, ':')[2]
    UI.setAttribute(id, field, value)
  end
  if GD.game.started then
    local btn = getObjectFromGUID(C.guids.recycle_spell_btn)
    btn.UI.setAttribute("recycle_spell_panel","active","true")
  end
end

--[[ Button handler for "Start Game".  Setup player order and
    enable class board selection. ]]
function startGameBtn()
  local seated = getSeatedPlayers()
  if(env.test.test_players) then
    seated = env.test.test_players
  end
  if env.test.debug then log("Seated players: "); log(seated) end
  local colors_ok = true;
  for _,c in ipairs(seated) do
    if not(contains(env.game.player_table_order,c)) then
      broadcastToAll("Seated player color "..c.." not present at this table.  Please choose another color.")
      colors_ok = false
    end
  end
  if not(colors_ok) then return end
  UI_hide("startPanel")
  --get random start player and assign player order in table clockwise order
  GD.game.player_count = #seated
  local start_color = seated[math.random(1, GD.game.player_count)]
  GD.game.player_order = {}
  GD.game.players = {}
  local order = ""
  local p = indexOf(env.game.player_table_order, start_color)
  for i=1, #env.game.player_table_order do
    local pcol = env.game.player_table_order[p]
    if contains(seated, pcol) then
      GD.game.players[pcol] = {}
      table.insert(GD.game.player_order, pcol)
      if order == "" then order = pcol
      else order = order .. ", " .. pcol end
    end
    p = p + 1
    if p > #env.game.player_table_order then p = 1 end --wrap around end
  end
  GD.game.start_player = indexOf(GD.game.player_order, start_color)
  if GD.env.verbose then print("Player order is " .. order) end
  if env.test.debug then log("Player order is " .. order) end
  --set up the table
  if (math.random(1, 10) > 5) then
    GD.game.myst_rune = C.guids.myst_rune_1
  else
    GD.game.myst_rune = C.guids.myst_rune_2
  end
  getObjectFromGUID(GD.game.heroics_deck_guid).shuffle()
  getObjectFromGUID(GD.game.spells_deck_guid).shuffle()
  getObjectFromGUID(GD.game.alterations_deck_guid).shuffle()
  getObjectFromGUID(GD.game.artifacts_deck_guid).shuffle()
  -- Enable class select buttons
  for class, guid in pairs(C.guids.player_boards) do
    local class_board = getObjectFromGUID(guid)
    assert(class_board)
    --class_board.call("enableClassSelectBtn")
    class_board.interactable = true
    class_board.setLock(false)
  end
  GD.game.assigned_boards_count = 0
  GD.game.current_player = #GD.game.player_order
  if env.test.debug then log("Active player is "..GD.game.player_order[GD.game.current_player]) end
  if GD.env.verbose then print("Active player is "..GD.game.player_order[GD.game.current_player]) end
  --display cast selection UI
  for i=1,4 do
    UI_setAttribute("selectClass_"..tostring(i).."_panel","color","rgba(0,0,0,0)")
    UI_setAttribute("selectClass_"..tostring(i).."_text","text","")
    UI_setAttribute("selectClassLocation_"..tostring(i).."_text","text","")
  end
  local i = 1
  for p=#GD.game.player_order,1,-1 do
    local pcol = GD.game.player_order[p]
    UI_setAttribute("selectClass_"..tostring(i).."_panel","color",pcol)
    UI_setAttribute("selectClass_"..tostring(i).."_text","text",pcol)
    UI_setAttribute("selectClassLocation_"..tostring(i).."_text","text",tostring(i))
    i=i+1
  end
  UI_setAttribute("selectClassBoardPanel","active","true")
  if env.test.auto_switch then autoSwitch(GD.game.player_order[GD.game.current_player]) end

end

--[[TESTING ONLY: Facilitate testing.  Switch test player color to game active player color.]]
function autoSwitch(pcol)
  if env.test.trace then log("Global: autoSwitch() "..tostring(pcol)) end
  local players = Player.getPlayers()
  if #players == 1 then
    if env.test.debug then log("Test player current color: "..tostring(players[1].color)) end
    if pcol then
      if players[1].color ~= pcol then
        if env.test.debug then log("Switching color to pcol: "..tostring(pcol)) end
        players[1].changeColor(pcol)
      end
    else
      if players[1].color ~= GD.game.player_order[GD.game.current_player] then
        if env.test.debug then log("Switching color to: "..GD.game.player_order[GD.game.current_player]) end
        players[1].changeColor(GD.game.player_order[GD.game.current_player])
      end
    end
  end
end

--[[ Called from player board on class select.
    If player is unnassigned, set associations to player board.
    Otherwise show error message and return with no action.
    Calls back to player board to finish setup if successful. ]]
function setPlayerClass(params)
  if env.test.trace then log("Global: setPlayerClass()") end
  assert(params.player, "parameter 'player' missing")
  assert(params.guid, "parameter 'guid' missing")
  assert(params.position, "parameter 'position' missing")
  local position = params.position
  local pcol = params.player
  local error = false;
  if not(contains(GD.game.player_order, pcol)) then
    broadcastToAll("Player " .. pcol .. " is not a player in this game.")
    error = true
  elseif pcol ~= GD.game.player_order[GD.game.current_player] then
    broadcastToColor("Player " .. pcol .. " is not the current player.", pcol)
    error = true
  elseif GD.game.players[pcol].class then
    broadcastToColor("Player " .. pcol .. " cannot select a second class.", pcol)
    error = true
  elseif GD.game.positions[position] ~= "" then
    broadcastToAll("Player position "..position.." already taken.")
    error = true
  end
  if error then
    getObjectFromGUID(params.guid).setPosition(Vector(params.home_position))
    return
  else
    local class_board = getObjectFromGUID(params.guid)
    assert(class_board, "ERROR: Global: setPlayerClass(): Missing board object")
    if GD.env.verbose then print("Player " .. pcol .. " selected class " .. class_board.getName()) end
    GD.game.positions[position] = pcol
    GD.game.players[pcol].class = class_board.getName()
    GD.game.players[pcol].board_guid = class_board.getGUID()
    GD.game.players[pcol].alteration_cards = {}
    --complete player assignment in board
    class_board.call("setPlayer", {["player"]=pcol, ["position"]=position})
    GD.game.assigned_boards_count = GD.game.assigned_boards_count + 1
    --update display for cast selection UI
    UI_setAttribute("selectClass_"..tostring(GD.game.assigned_boards_count).."_panel","color","Grey")
    UI_setAttribute("selectClass_"..tostring(GD.game.assigned_boards_count).."_text","text","Done")
  end
  --If all players assigned to boards, do final setup
  if GD.game.assigned_boards_count == GD.game.player_count then
    UI_setAttribute("selectClassBoardPanel","active","false")
    finalSetup()
  else
    local next = GD.game.current_player - 1
    if next == 0 then
      next = #GD.game.player_order  --TODO: is this necessary?  Always finishes on 1st player in order?
      log("WARN: wrapping in player order")
    end
    GD.game.current_player = next
    if GD.env.verbose then print("Active player is "..GD.game.player_order[GD.game.current_player]) end
    if env.test.auto_switch then autoSwitch(GD.game.player_order[GD.game.current_player]) end
  end
end

--[[ Final game setup after all players have selected a class. ]]
function finalSetup()
  if env.test.trace then log("Global: finalSetup()") end
  --cleanup unused boards
  for _,guid in pairs(C.guids.player_boards) do
    getObjectFromGUID(guid).call("setupBoard")
  end
  for i=1,4 do
    if GD.game.positions[i] == "" then
      getObjectFromGUID(C.guids.color_bars[i]).destruct()
    end
    local zone =getObjectFromGUID(C.guids.board_zones[i])
    if zone ~= nil then zone.destruct() end
  end
  --deal out starting cards
  local p = {
    ["position"] = {},
    ["flip"] = true,
    ["top"] = true,
    ["smooth"] = true
  }
  local deck = getObjectFromGUID(GD.game.spells_deck_guid)
  for i=1,6 do
    p.position = C.pos.spells[i]
    deck.takeObject(p)
  end
  setInvisibleTo(C.guids.recycle_spell_btn, {})
  local btn = getObjectFromGUID(C.guids.recycle_spell_btn)
  btn.UI.setAttribute("recycle_spell_panel","active","true")
  deck = getObjectFromGUID(GD.game.alterations_deck_guid)
  for i=1,6 do
    p.position = C.pos.alterations[i]
    deck.takeObject(p)
  end
  local card = 1
  Wait.time(function()
    if card > 6 then return end -- safety
    placeHeroic(Vector(C.pos.heroics[card]), 1)
    card = card + 1
  end, .25, 6)
 -- Place acuity on alterations per player count
 local acuity_bag = getObjectFromGUID(C.guids.acuity_bag)
  for i=1, GD.game.player_count do
    local pos = Vector(C.pos.alterations[i])
    pos.y = pos.y + 1
    acuity_bag.takeObject({ callback_function = function(obj) obj.setPositionSmooth(pos, false, false) end })
  end
  -- Place the previously random selected myst rune (if Mystcaller not taken)
  local mystcaller = false
  for _,p in pairs(GD.game.players) do
    if p.class == "Mystcaller" then mystcaller = true end
  end
  if not(mystcaller) then
    local myst_rune = getObjectFromGUID(GD.game.myst_rune)
    myst_rune.setPositionSmooth(C.pos.myst_rune)
    myst_rune.setRotation(C.rot.myst_rune)
  end

  -- Random flip arcanas
  for g,data in pairs(C.arcanas) do
    log("random flip arcana "..g)
    local arcana = getObjectFromGUID(g)
    if (math.random(1, 10) > 5) then arcana.flip() end
    Wait.condition(
      function()
        if arcana.is_face_down then
          arcana.setName(data.face_down.name)
        else
          arcana.setName(data.face_up.name)
        end
      end,
      function() return arcana.resting end
    )
  end

  -- Give extra acuity to players in turn order
  local player = GD.game.start_player
  local count = 1
  Wait.time(
    function()
      player = player + 1
      if player > GD.game.player_count then player = 1 end --wrap around
      player_color = GD.game.player_order[player]
      if GD.env.verbose then print("Dealing " .. count .. " extra acuity to player " .. count+1 .. " - " .. player_color) end
      local board = getObjectFromGUID(GD.game.players[player_color].board_guid)
      board.call("dealItems", {["item_type"]="acuity",["amount"]=count})
      count = count + 1
    end,
    .5,
    GD.game.player_count-1
  )
  local pcol = GD.game.player_order[GD.game.current_player]
  local board = getObjectFromGUID(GD.game.players[pcol].board_guid)
  board.call("enableActivePlayer")
  if GD.env.verbose then print("Active player is " .. GD.game.player_order[GD.game.current_player]) end

  --Configure final scoring table and HUD for number of players
  local num_players = #GD.game.player_order
  for i=1,4 do
    if i > num_players then
      UI_setAttribute("score_table_row_"..tostring(i), "active", "false")
      UI_setAttribute("hud_row_"..tostring(i), "active", "false")
    else
      UI_setAttribute("hud_row_"..tostring(i).."_player", "text", GD.game.player_order[i])
      UI_setAttribute("hud_row_"..tostring(i).."_player", "color", GD.game.player_order[i])
    end
  end
  local table_size = 360 - ((4 - num_players) * 55)
  UI_setAttribute("score_panel", "height", tostring(table_size))
  local inner_hud_panel_size = 120 + num_players * 30
  local outer_hud_panel_size = inner_hud_panel_size + 20
  UI_setAttribute("inner_hud_panel","height",tostring(inner_hud_panel_size))
  UI_setAttribute("outer_hud_panel","height",tostring(outer_hud_panel_size))
  for _,pcol in ipairs(env.game.player_table_order) do
    for i=1,7 do
      UI_setAttribute(pcol.."_hud_die_"..tostring(i).."_image","actve","false")
    end
  end
  UI_setAttribute("outer_hud_panel","active","true")
  --done with final setup
  GD.game.started = true
end

--[[ Place a heroic card and the bonus bits on it.
    Recursive to add delay for placing bits.   --]]
function placeHeroic(location, iteration)
  if iteration > 3 then return end  -- safety, should not happen
  local pos = Vector(location)
  if iteration == 1 then
    local deck = getHeroicsDeck()
    if deck then
      deck.takeObject({
        ["position"] = pos,
        ["flip"] = true,
        ["top"] = true,
        ["smooth"] = false
      })
    else return end
  elseif iteration == 2 then
    pos.y = 1
    local mana_bag = getObjectFromGUID(C.guids.mana_bag)
    mana_bag.takeObject({ callback_function = function(obj) obj.setPositionSmooth(pos, false, false) end })
  elseif iteration == 3 then
    pos.y = 2
    pos.z = pos.z - 0.5
    local acuity_bag = getObjectFromGUID(C.guids.acuity_bag)
    acuity_bag.takeObject({ callback_function = function(obj) obj.setPositionSmooth(pos, false, false) end })
    return
  end
  iteration = iteration + 1
  Wait.frames(function() placeHeroic(location, iteration) end, 10)
end

--[[ Called from setNextPlayer (on turn "done") --]]
function refillCards()
  if env.test.trace then log("Global: refillCards()") end
  refillSpells()
  refillAlterations()
  refillHeroics()
end

--[[ Shift spell cards left to fill empty spaces, placing new cards in rightmost spot. --]]
function refillSpells()
  if env.test.trace then log("Global: refillSpells()") end
  local p = {
    origin       = {},
    direction    = {0,1,0},
    type         = 3,
    size         = {1,2,2},
    max_distance = 0,
    debug        = false,
  }
  -- local deck = getObjectFromGUID(C.guids.spells_deck)
  local spots = {}
  local empty_spots = 0
  for i=1,6 do
    p.origin =  C.pos.spells[i]
    local hits = Physics.cast(p)
    local empty = true
    if hits ~= nil then
      for _,hit in ipairs(hits) do
        if hit.hit_object.tag ~= "Surface" then
          if hit.hit_object.hasTag("Spell") then
            spots[i] = hit.hit_object.getGUID()
            empty = false
          end
        end
      end
    end
    if empty then
      spots[i] = "-"
      empty_spots = empty_spots + 1
    end
  end
  --recursively shift cards left into empty spots and fill last spot
  local function shift(empty_spots)
    for i=1,6 do
      if spots[i] == "-" then
        for j=i+1,6 do
          local pos = C.pos.spells[j-1]
          card = getObjectFromGUID(spots[j])
          if card ~= nil then
            card.setPosition(pos)
            spots[j-1] = spots[j]
            spots[j] = "-"
          end
        end
      end
    end
    local deck = getSpellsDeck()
    if deck then
      local card
      if deck.tag == "Deck" then
        card = deck.takeObject({
          ["position"] = C.pos.spells[6],
          ["flip"] = true,
          ["top"] = true,
          ["smooth"] = false
        })
      elseif deck.tag == "Card" then
        card = deck
      else
        log("ERROR: Global: refillSpells() unknown spell deck object")
      end
      spots[6] = card.getGUID()
    else
      log("WARN: spells deck is empty!")  --not sure this can ever happen, but warn anyway.
    end
    empty_spots = empty_spots - 1
    if empty_spots > 0 then
      Wait.frames(function() shift(empty_spots) end, .5)
    end
  end
  if empty_spots > 0 then
    shift(empty_spots)
  end
end

--[[ Place acuity on remaining cards to left of rightmost empty spot.
    Then shift cards left to fill empty spaces, placing new cards in rightmost spot.
    Move acuity with the cards. --]]
function refillAlterations()
  if env.test.trace then log("Global: refillAlterations()") end
  local p = {
    origin       = {},
    direction    = {0,1,0},
    type         = 3,
    size         = {1,2,2},
    max_distance = 0,
    debug        = true,
  }
  local deck = getAlterationsDeck()
  if not(deck) then
    log("--TODO: Global:refillAlterations() handle empty alteration deck!")
    return
  end
  --Set up current condition (find cards, empty spots and current acuity on cards)
  local spots = {}
  local acuity = {}
  local empty_spots = 0
  local rightmost_empty = 0
  for i=1,6 do
    acuity[i] = {}
    p.origin =  C.pos.alterations[i]
    local hits = Physics.cast(p)
    local empty = true
    if hits ~= nil then
      for _,hit in ipairs(hits) do
        if hit.hit_object.tag ~= "Surface" then
          if hit.hit_object.hasTag("Alteration") then
            spots[i] = hit.hit_object.getGUID()
            empty = false
          elseif hit.hit_object.hasTag("Acuity") then
            table.insert(acuity[i], hit.hit_object.getGUID())
          end
        end
      end
    end
    if empty then
      spots[i] = "-"
      empty_spots = empty_spots + 1
      rightmost_empty = i
    end
  end
  if env.test.debug then log("Rightmost empty is "..tostring(rightmost_empty)) end

  --add acuity to remaining cards left of rightmost empty BEFORE shifting, update current acuity table
  local n = rightmost_empty-1
  local new_acuity = {}
  if n >= 1 then
    local bag = getObjectFromGUID(C.guids.acuity_bag)
    for i=1,n do
      if spots[i] ~= "-" then
        local pos = Vector(C.pos.alterations[i])
        pos.y = pos.y + 3
        pos = scatter(pos, {0.4,0,0.4}, {0.1,0,0.1})
        local o = bag.takeObject({
          callback_function = function(obj)
            obj.setPositionSmooth(pos, false, false)
          end })
        table.insert(new_acuity, o)
        table.insert(acuity[i], o.getGUID())
      end
    end
  end
  --recursively shift cards left into empty spots and fill right most empty spot(s)
  local function shift(empty_spots)
    for i=1,6 do
      if spots[i] == "-" then
        for j=i+1,6 do
          local pos = C.pos.alterations[j-1]
          card = getObjectFromGUID(spots[j])
          if card ~= nil then
            card.setPosition(pos)
            spots[j-1] = spots[j]
            spots[j] = "-"
            for _,g in ipairs(acuity[j]) do
              local o = getObjectFromGUID(g)
              local delta_x = C.pos.alterations[j][1] - C.pos.alterations[j-1][1]
              local o_pos = o.getPosition()
              o_pos.x = o_pos.x - delta_x
              o.setPositionSmooth(o_pos, false, true)
              table.insert(acuity[j-1], g)
            end
            acuity[j] = {}
          end
        end
      end
    end
    local card = deck.takeObject({
      ["position"] = C.pos.alterations[6],
      ["flip"] = true,
      ["top"] = true,
      ["smooth"] = false
    })
    spots[6] = card.getGUID()
    empty_spots = empty_spots - 1
    if empty_spots > 0 then
      Wait.time(function() shift(empty_spots) end, .5)
    end
  end

  --After placing any new acuity, start shifting cards left to fill empty spaces.
  if empty_spots > 0 then
    if #new_acuity > 0 then
      --New acuity placed so wait until all are resting before shifting
      Wait.condition(function() shift(empty_spots) end,
        function()
          for _,o in ipairs(new_acuity) do
            if not(o.resting) then return false end
          end
          return true
        end)
    else
      shift(empty_spots)
    end
  end
end

--[[ Refill the Heroics card positions. --]]
function refillHeroics()
  if env.test.trace then log("Global: refillHeroics()") end
  local p = {
    origin       = {},
    direction    = {0,1,0},
    type         = 3,
    size         = {1,2,2},
    max_distance = 0,
    debug        = false,
  }
  local deck = getObjectFromGUID(GD.game.heroics_deck_guid)
  local empty_spots = {}
  for i=1,6 do
    p.origin =  C.pos.heroics[i]
    local hits = Physics.cast(p)
    local empty = true
    if hits ~= nil then
      for _,hit in ipairs(hits) do
        if hit.hit_object.tag ~= "Surface" then
          if hit.hit_object.hasTag("Heroic") then empty = false end
        end
      end
    end
    if empty then  table.insert(empty_spots, C.pos.heroics[i]) end
  end
  --fill the spot(s).  Recursive to add delay between.
  local function fillSpot()
    if empty_spots[1] == nil then return end
    placeHeroic(Vector(empty_spots[1]), 1)
    table.remove(empty_spots, 1)
    Wait.time(function() fillSpot() end, .5)
  end
  if #empty_spots > 0 then
    fillSpot()
  end
end

--[[ Set the next player in player_order.
  Wraps to first player if last is current. ]]
function setNextPlayer()
  if env.test.trace then log("Global: setNextPlayer()") end
  if GD.game.current_player == #GD.game.player_order then
    GD.game.current_player = 1
  else
    GD.game.current_player = GD.game.current_player + 1
  end
  refillCards()
  local pcol = GD.game.player_order[GD.game.current_player]
  local board = getObjectFromGUID(GD.game.players[pcol].board_guid)
  board.call("enableActivePlayer")
  if env.test.auto_switch then autoSwitch(GD.game.player_order[GD.game.current_player]) end
  if GD.env.verbose then print("Active player is " .. GD.game.player_order[GD.game.current_player]) end
end

--[[ Special case needed by Mystcaller board only. ]]
function getMystRuneGuid()
  return GD.game.myst_rune
end

--[[ Used by player boards during scoring --]]
function getPlayerCount()
  return #GD.game.player_order
end

--[[ Return player class board guid. --]]
function getPlayerClassBoardGUID(params)
  assert(params)
  local pdata = GD.game.players[params.player_color]
  if pdata ~= nil then
    return pdata.board_guid
  else
    log("Global: ERROR: unable to get player data")
    return ""
  end
end

--[[ Used only when player types a number on a die to change it.  Trigger update spell power for player. --]]
function onObjectNumberTyped(o, pcol, n)
  if o.hasTag("Dice") and n >= 1 and n <= 6 then
    local board = getObjectFromGUID(GD.game.players[pcol].board_guid)
    Wait.time(function() board.call("updateSpellPower", {}) end, 0.5)
  end
end

--[[ When die are randomized (re-rolled) by a player then trigger HUD update. ]]
function onObjectRandomize(obj, player_color)
  if obj.hasTag("Dice") then
    Wait.condition(function() updateHUD(player_color) end, function() return obj.resting end)
  end
end

--[[ Used only to trigger a wait on dice by the appropriate player board. --]]
function onObjectRandomize(o, pcol)
  if o.hasTag("Dice") then
    local board = getObjectFromGUID(GD.game.players[pcol].board_guid)
    board.call("waitOnDiceRoll", {})
  end
end

--[[ Check Alteration cards as they entern player's hand.  Assign ownership if they are not owned. ]]
function onObjectEnterZone(zone, obj)
  if zone.tag == "Hand" then
    if obj.hasTag("Alteration") then
      local pcol = zone.getData()["FogColor"]
      if not(contains(GD.game.players[pcol].alteration_cards, obj.getGUID())) then
        table.insert(GD.game.players[pcol].alteration_cards, obj.getGUID())
        if env.test.debug then log("Alteration card "..obj.getGUID().." first entered hand zone and assigned to player "..pcol) end
        if #alterations[tonumber(obj.getGMNotes())].sigils > 0 then
          getObjectFromGUID(GD.game.players[pcol].board_guid).call("updateScore")
        end
      end
    end
  end
end

--[[ Handle objects dropped in game.  Only certain object tags supported.  --]]
function onObjectDrop(player_color, obj)
  if GD.game.started then
    local fn
    local params = {guid = obj.getGUID()}
    if obj.hasTag("Spell") then fn = "spellDrop"
    elseif obj.hasTag("Acuity") then fn = "acuityDrop"
    elseif obj.hasTag("Dice") then fn = "diceDrop"
    elseif obj.hasTag("Alteration") then
      if contains(Player[player_color].getHandObjects(), obj) then return end --ignore moving in hand
      if contains(GD.game.players[player_color].alteration_cards, obj.getGUID()) then
        if alterations[tonumber(obj.getGMNotes())].discard then
          UI.setAttribute("alterationDiscardPanel","hidden",obj.getGUID())
          UI_setAttribute("alterationDiscardPanel","active","true")
        else
          params.action = "play"
          fn = "playAlteration"
        end
      end
    end
    if fn then
      if env.test.trace then log("Global: onObjectDrop() -> "..tostring(fn)) end
      local player_board = getObjectFromGUID(GD.game.players[player_color].board_guid)
      player_board.call(fn, params)
    end
  end
end

--[[ Handler for the alteration card action dialog. ]]
function alterationActionBtn(player, button, id)
  if env.test.trace then log("Global: alterationActionBtn() "..tostring(player.color)..", "..tostring(id)) end
  if player.color ~= GD.game.player_order[GD.game.current_player] then return end
  local action = Split(id,'_')[2]
  local success = true
  local g = UI.getAttribute("alterationDiscardPanel","hidden")
  if action == "play" or action == "discard" then
    local player_board = getObjectFromGUID(GD.game.players[player.color].board_guid)
    success = player_board.call("playAlteration", {guid=g,action=action})
  elseif action == "cancel" then
    local card = getObjectFromGUID(g)
    card.deal(1, player.color)
  else
    log("ERROR: Global: alterationActionBtn(): unknown action")
    return
  end
  if success then UI_setAttribute("alterationDiscardPanel","active","false") end
end

--[[ Handler for Recycle Leftmost Spell button. ]]
function recycleSpellBtn(player, button, id)
  if env.test.trace then log("Global: recycleSpellBtn() "..tostring(player.color)) end
  if player.color ~= GD.game.player_order[GD.game.current_player] then return end
  -- get leftmost spell card
  local card = findObject(C.pos.spells[1], {"Card"}, {1,1,1}, env.test.debug)
  if not(card) then
    broadcastToColor("No spell card in position 1 to recycle.", player.color)
    return
  end
  -- flip face down
  if not(card.is_face_down) then card.flip() end
  -- put on bottom of spell deck
  local deck = getSpellsDeck()
  if deck then
    if deck.tag == "Deck" then
      Wait.condition(function() deck.putObject(card) end, function() return card.resting end)
    elseif deck.tag == "Card" then
      Wait.condition(function()
          local pos = deck.getPosition()
          deck.setPosition(Vector(pos.x, pos.y + 3, pos.z))
          card.setPosition(pos)
        end,
        function() return card.resting end)
      GD.game.spells_deck_guid = getSpellDeck().getGUID()
    else
      log("Global: Error: recycleSpellBtn() unknown spell deck object")
    end
  else
    card.setPosition(C.spells_deck_position)
    GD.game.spells_deck_guid = card.getGUID()
  end
  -- give player one acuity
  local board = getObjectFromGUID(GD.game.players[player.color].board_guid)
  board.call("dealItems", {["item_type"]="acuity",["amount"]=1})
end

--[[ Handler for the take Heroic button. ]]
function takeHeroicBtn(player, button, id)
  if env.test.trace then log("Global: takeHeroicBtn() "..tostring(player.color)..", "..tostring(id)) end

  --TODO:

end

--[[ Handle objects picked up in game.  Only certain object tags supported.  --]]
function onObjectPickUp(player_color, obj)
  if GD.game.started then
    if obj.hasTag("Spell") then
      -- Clear any decals and buttons on a spell card when picked up
      if obj.getDecals() ~= nil then
        obj.setDecals({})
      end
      if obj.getButtons() ~= nil then
        obj.clearButtons()
      end
    end
  end
end

--[[ Handle cards leaving decks.  Set tooltip description if enabled. ]]
function onObjectLeaveContainer(container, obj)
  if container.tag == "Deck" then
    if obj.hasTag("Alteration") then
      local data = alterations[tonumber(obj.getGMNotes())]
      if GD.env.card_tooltips then obj.setDescription(data.desc) end
      if env.test.debug then obj.setName(data.id)
      else obj.setName("") end
    elseif obj.hasTag("Spell") then
      local data = spells[tonumber(obj.getGMNotes())]
      if GD.env.card_tooltips then obj.setDescription(data.desc) end
      if env.test.debug then obj.setName(data.id)
      else obj.setName("") end
    elseif obj.hasTag("Heroic") then
      local data = heroics[tonumber(obj.getGMNotes())]
      if GD.env.card_tooltips then obj.setDescription(data.desc) end
      if env.test.debug then obj.setName(data.id)
      else obj.setName("") end
    end
  end
end

--[[ Locate Heroics deck.
  Update to new GUID if deck guid changed (or only one card)
  Return deck object if found (will be single card if only one left).
  Log error and return nil if no more heroics.]]                            --TODO: convert to findObject()
function getHeroicsDeck()
  if env.test.trace then log("Global: getHeroicsDeck()") end
  local deck = getObjectFromGUID(GD.game.heroics_deck_guid)
  if deck then return deck end
  -- No deck object so use cast to find it
  local p = simpleDeepCopy(C.default_cast_params)
  p.origin = C.heroics_deck_pos
  local hits = Physics.cast({p})
  if hits then
    for _,hit in pairs(hits) do
      if hit.hit_object.tag == "Deck" then
        GD.game.heroics_deck_guid = hit.hit_object.getGUID()
        return hit.hit_object
      elseif hit.hit_object.tag == "Card" then
        log("WARN: Global: getHeroicsDeck(): returning last card")
        return hit.hit_object
      end
    end
  end
  log("ERROR: Global: getHeroicsDeck(): No deck found")
  return nil
end

--[[ Locate Alterations deck.
  Update to new GUID if deck guid changed (or only one card)
  Return deck object if found (will be single card if only one left).
  Log error and return nil if no card or deck.]]
function getAlterationsDeck()
  if env.test.trace then log("Global: getAlterationsDeck()") end
  local deck = getObjectFromGUID(GD.game.alterations_deck_guid)
  if deck then return deck end
  -- No deck object so find it
  local deck = findObject(C.alterations_deck_pos, {"Deck","Card"}, env.test.debug)
  if not(deck) then log("WARN: Global: getAlterationsDeck(): No deck found")
  else GD.game.alterations_deck_guid = deck.getGUID() end
  return deck
end

--[[ Locate Spells deck.
  Update to new GUID if deck guid changed (or only one card)
  Return deck object if found (will be single card if only one left).
  Log error and return nil if no more heroics.]]
function getSpellsDeck()
  if env.test.trace then log("Global: getSpellsDeck()") end
  local deck = getObjectFromGUID(GD.game.spells_deck_guid)
  if deck then return deck end
  -- No deck object so find it
  local deck = findObject(C.spells_deck_pos, {"Deck","Card"}, env.test.debug)
  if not(deck) then log("WARN: Global: getSpellsDeck(): No deck found")
  else GD.game.spells_deck_guid = deck.getGUID() end
  return deck
end

--[[ Update HUD UI with current data.
    player_color: (opt) if supplied update only this players info
--]]
function updateHUD(player_color)
  if env.test.trace then log("Global: updateHUD() "..tostring(player_color)) end
  local max_heroics = 4
  if GD.game.player_count == 3 then  max_heroics = 3
  elseif GD.game.player_count == 4 then max_heroics = 2 end
  local function updatePlayerHUD(i, pcol)
    local board = getObjectFromGUID(GD.game.players[pcol].board_guid)
    local score = board.call("getCurrentScore")
    local spell = board.call("getCurrentSpellPower")
    local heroics = board.call("getCurrentHeroics")
    UI_setAttribute("hud_row_"..tostring(i).."_spell", "text", tostring(spell.power))
    if spell.type ~= "None" then
      UI_setAttribute("hud_row_"..tostring(i).."_image", "image", tostring(spell.type))
      UI_setAttribute("hud_row_"..tostring(i).."_image", "active", "true")
    else
      UI_setAttribute("hud_row_"..tostring(i).."_image", "active", "false")
    end
    UI_setAttribute("hud_row_"..tostring(i).."_heroics", "text", tostring(heroics).." / "..tostring(max_heroics))
    UI_setAttribute("hud_row_"..tostring(i).."_score", "text", tostring(score))
    local d = board.call("getUnallocatedDiceValues")
    for i=1,7 do
      local id = pcol.."_hud_die_"..tostring(i).."_image"
      if i <= #d then
        UI.setAttribute(id,"image",C.die_elements[d[i]])
        UI.setClass(id, "die_image_active")
      else
        UI.setClass(id, "die_image_inactive")
      end
    end
  end
  if player_color ~= nil then
    updatePlayerHUD(indexOf(GD.game.player_order, player_color), player_color)
  else
    for i,pcol in ipairs(GD.game.player_order) do
      updatePlayerHUD(i, pcol)
    end
  end
end

--[[ Final game scoring.
  tiebreaker: first #arcanas, then #spells --]]
function finalScore()
  if env.test.trace then log("Global: finalScore()") end
  local scores = {}
  for color,pinfo in pairs(GD.game.players) do
    local pdata = {}
    pdata.player = color
    pdata.class = pinfo.class
    local board = getObjectFromGUID(pinfo.board_guid)
    board.call("updateScore", {})
    local bd=board.getTable("GD")
    local values = bd.board.scoring.values
    pdata.total = 0
    pdata.heroics = values.heroics
    pdata.total = pdata.total + values.heroics
    pdata.sigils = values.sigils
    pdata.total = pdata.total + values.sigils
    pdata.prestige = values.prestige
    pdata.total = pdata.total + values.prestige
    pdata.arcanas = values.arcanas
    pdata.total = pdata.total + values.arcanas
    pdata.num_arcanas = sizeOf(bd.board.scoring.arcanas)
    pdata.num_spells = sizeOf(bd.board.scoring.spells)
    local new_data = simpleDeepCopy(pdata)
    if #scores == 0 then
      table.insert(scores, new_data)
    else
      local found = false
      for i=1,#scores do
        if new_data.total > scores[i].total then
          table.insert(scores, i, new_data)
          found = true
          break
        elseif new_data.total == scores[i].total then
          --first tie breaker
          if new_data.num_arcanas > scores[i].num_arcanas then
            print(new_data.player.." wins 1st tie breaker with "..scores[i].player.." on #arcanas")
            table.insert(scores, i, new_data)
            found = true
            break
          elseif new_data.num_arcanas == scores[i].num_arcanas then
            --second tie breaker
            if new_data.num_spells > scores[i].num_spells then
              print(new_data.player.." wins 2nd tie breaker with "..scores[i].player.." on #spells")
              table.insert(scores, i, new_data)
              found = true
              break
            else
              print(new_data.player.." and "..scores[i].player.." still tied after all tie breakers.")
            end
          end
        end
      end
      if not(found) then
        table.insert(scores, #scores + 1, new_data)
      end
    end
  end
  --update the score display and show it
  log("score:")
  log(scores)
  local i = 1
  for _,data in ipairs(scores) do
    UI_setAttribute("score_table_row_"..tostring(i).."_text_1", "text", data.player)
    UI_setAttribute("score_table_row_"..tostring(i).."_text_2", "text", data.class)
    UI_setAttribute("score_table_row_"..tostring(i).."_text_3", "text", data.heroics)
    UI_setAttribute("score_table_row_"..tostring(i).."_text_4", "text", data.sigils)
    UI_setAttribute("score_table_row_"..tostring(i).."_text_5", "text", data.prestige)
    UI_setAttribute("score_table_row_"..tostring(i).."_text_6", "text", data.arcanas)
    UI_setAttribute("score_table_row_"..tostring(i).."_text_7", "text", data.total)
    i = i + 1
  end
  broadcastToAll(scores[1].player.." wins the game!!!")
  UI_show("score_panel")
end

--[[ ******** UTILITY ******** --]]

--[[ Get obj position (DEVELOPMENT ONLY) ]]
function savePosition(g)
  local o = getObjectFromGUID(g)
  Notes.setNotes(tostring(o.getPosition()))
end

--[[ Get obj rotation (DEVELOPMENT ONLY) ]]
  function saveRotation(g)
  local o = getObjectFromGUID(g)
  Notes.setNotes(tostring(o.getRotation()))
end

-- require("tts-lib/utils")
#include ~/github/tts-lib/utils.ttslua
#include ~/github/tts-mercurial/Constants.ttslua
#include ~/github/tts-mercurial/Cards.ttslua
