--[[ *************************************************************************

Work items for converstion of beta to production version:

  --BUG MINOR don't show any buttons (cast/take) while edit acuity spell panel is active.

  --TODO: Endgame stuff.  MVP done. All needs to be tested.
        -- DONE all take buttons disabled
        -- mystrune disabled (or not)???
        -- DONE disallow card play
        -- DONE only enable cast button
        -- Maybe blow away the g_lower board?  Or cover it with an endgame dialog?

  --BUG: something wrong with image asset "Spell-4".  Will not load.
        --HACK: WORKAROUND: just load Spell-3 whenever Spell-4 comes up.

Future possible stuff for greater enhancement

  --TODO: add undo for some functions
      -- take alteration card for sure
      -- recycle spell?
      -- take back used alterations?

  --TODO: smart spell card placement.  In generating map.
      -- move link spell(s) to highest value base spell (easy)
      -- auto convert option base spells (hard?)
      -- how to take into account enchant spells? (VERY hard)

  - TODO: start options in UI start game panel

  --TODO: change arcanas into cards, move data into cards.ttslua

  --TODO: OPTIMIZE add discarded alteration cards counter to player data.  Check on playerboard
        ui update to avoid locating deck with physics everyt time.  Only do if count > 0.

  --TODO: MAYBE? Change UI_setAttribute back to UI.setAttribute in UI update functions,
          persistent state no longer needed there.

  --TODO: eleminate redundancy in Spell card info and images.  Bunch of same.

  --TODO: automate assigning resources to spell cards???  At least for fixed dice slots.

****************************************************************************** ]]

env = {}
env.version = "1.0.2 production release"
env.test= {}
-- env.test.test_players = {"Green", "Blue", "Yellow", "Red"}
-- env.test.test_players = {"Yellow", "Red", "Blue"}
env.test.test_players = {"Red", "Blue"}
-- env.test.test_players = {"Green", "Blue"}
-- env.test.test_players = {"Green", "Blue"}
env.test.auto_switch = true
env.test.in_dev = false
env.test.trace = true
env.test.debug = false
env.test.force_fresh_save = false
env.game = {}
env.game.player_table_order = {"Red", "Blue", "Green", "Yellow"}  --clockwise
env.game.verbose = true
env.game.card_tooltips = true

--[[ Game is loading. ]]
function onLoad(saved_data)
  log("Mercurial version " .. env.version)
  log("Loading ...")
  --set globals
  g_table_UI = getObjectFromGUID(C.guids.table_UI)
  GD = {}
  g_lower = C.guids.lower_cards
  g_upper = C.guids.upper_cards
  for i=1,4 do
    local bar = getObjectFromGUID(C.guids.color_bars[i])
    if bar ~= nil then
      bar.interactable = false
      bar.UI.setAttribute("block_text_id", "text", "")
      bar.setInvisibleTo(Player.getColors())
    end
  end
  if not(env.test.in_dev) then
    getObjectFromGUID(C.guids.dice_flip_chart).setInvisibleTo(Player.getColors())
    getObjectFromGUID(C.guids.excess_spell_prestige).setInvisibleTo(Player.getColors())
    for _,g in ipairs(C.guids.player_boards) do
      local b = getObjectFromGUID(g)
      if b then b.tooltip = false end
    end
    getObjectFromGUID(g_upper).interactable = false
    getObjectFromGUID(g_lower).interactable = false
  end
  --handle game loading state
  if saved_data ~= "" then
    if env.test.trace then log("Global onLoad(): Saved load") end
    local restore_data = JSON.decode(saved_data)
    GD = restore_data
    Wait.frames(function() restoreGameState() end, 10) --allow objects to load
  else
    if env.test.trace then log("Global onLoad(): Fresh load") end
    for _,a in ipairs(C.arcanas) do
      getObjectFromGUID(a.guid).setInvisibleTo(Player.getColors())
    end
    --persistent UI state data
    GD.states = {}
    GD.states.UI = {}
    GD.states.UI_class = {}
    GD.states.object_UI = {}
    --persistent environment vars
    GD.env = {}
    GD.env.verbose = env.game.verbose
    GD.env.card_tooltips = env.game.card_tooltips
    --persistent game data
    GD.game = {}
    GD.game.started = false
    GD.game.spells_deck_guid = C.guids.spells_deck
    GD.game.alterations_deck_guid = C.guids.alterations_deck
    GD.game.heroics_deck_guid = C.guids.heroics_deck
    GD.game.artifacts_deck_guid = C.guids.artifacts_deck
    GD.game.players = {}
    GD.game.positions = {}
    GD.game.arcanas = {}
    GD.game.heroics = {}
    for i=1,6 do
      table.insert(GD.game.heroics,
        {
          pos=C.pos.heroics[i],
          card_id=0,
          card_guid="",
        })
    end
    GD.game.alterations = {}
    for i=1,6 do
      table.insert(GD.game.alterations,
        {
          pos=C.pos.alterations[i],
          card_id=0,
          card_guid="",
        })
    end
    GD.game.spells = {}
    for i=1,6 do
      table.insert(GD.game.spells,
        {
          pos=C.pos.spells[i],
          card_id=0,
          card_guid="",
        })
    end
    for i=1,4 do
      GD.game.positions[i] = ""
    end
    --setup UI dialogs
    UI_setAttribute("spell_card_pnl","visibility","Pink")
    UI_setAttribute("alteration_card_pnl","visibility","Pink")
    UI_setAttribute("cast_cons_pnl","visibility","Pink")
    UI_setAttribute("cast_myst_pnl","visibility","Pink")
    UI_setAttribute("cast_mystrune_pnl","visibility","Pink")
    UI_setAttribute("activate_mystrune_pnl","visibility","Pink")
    Wait.frames(function()
      UI_setAttribute("spell_card_pnl","active",true)
      UI_setAttribute("alteration_card_pnl","active",true)
      UI_setAttribute("cast_cons_pnl","active",true)
      UI_setAttribute("cast_myst_pnl","active",true)
      UI_setAttribute("cast_mystrune_pnl","active",true)
      UI_setAttribute("activate_mystrune_pnl","active",true)
    end, 10)
    UI_setAttribute("start_pnl", "active",true)
  end
  math.randomseed(os.time())
  log("Loading complete.")
end

--[[  Wrapper function for saving Global UI attributes for game restore. ]]
function UI_setAttribute(id, field, value)
  -- if env.test.trace then log("UI_setAttribute() "..tostring(id)..", "..tostring(field)..", "..tostring(value)) end
  assert(type(id) == "string", "id must be a string")
  assert(type(field) == "string", "field must be a string")
  UI.setAttribute(id, field, value)
  GD.states.UI[id..":"..field] = value
end

--[[  Wrapper function for saving Global UI setClass for game restore. ]]
function UI_setClass(id, value)
  if env.test.trace then log("UI_setClass() "..tostring(id)..", "..tostring(value)) end
  assert(type(id) == "string", "id must be a string")
  assert(type(value) == "string", "value must be a string")
  UI.setClass(id, value)
  GD.states.UI_class[id] = value
end

--[[  Wrapper function for saving object UI attributes for game restore. ]]
function object_UI_setAttribute(guid, id, field, value)
  -- if env.test.trace then log("object_UI_setAttribute() "..tostring(guid)..", "..tostring(id)..", "..tostring(field)..", "..tostring(value)) end
  assert(guid, "object_UI_setAttribute(): missing guid")
  assert(type(id) == "string", "object_UI_setAttribute(): id must be a string")
  assert(type(field) == "string", "object_UI_setAttribute(): field must be a string")
  assert(value ~= nil, "object_UI_setAttribute(): missing value")
  local obj = getObjectFromGUID(guid)
  assert(obj, "object_UI_setAttribute() unable to locate object for guid "..tostring(guid))
  obj.UI.setAttribute(id, field, value)
  GD.states.object_UI[guid..":"..id..":"..field] = value
end

--[[ Save game state ]]
function onSave()
  local data_to_save = GD
  local saved_data = JSON.encode(data_to_save)
  if env.test.save_stats then
    log("Saved data length: "..tostring(#saved_data))
  end
  if env.test.force_fresh_save then
    saved_data = ""
  end
  return saved_data
end

--[[ Restore game state from saved load. ]]
function restoreGameState()
  if env.test.trace then log("restoreGameState()") end
  if GD.game.started then
    for i=1,4 do
      local bar = getObjectFromGUID(C.guids.color_bars[i])
      if bar ~= nil then bar.setInvisibleTo({}) end
    end
  else
    for _,a in ipairs(C.arcanas) do
      getObjectFromGUID(a.guid).setInvisibleTo(Player.getColors())
    end
  end
  --restore persistent Global UI state
  for key,value in pairs(GD.states.UI) do
    local id = Split(key, ':')[1]
    local field = Split(key, ':')[2]
    UI.setAttribute(id, field, value)
  end
  for id,value in pairs(GD.states.UI_class) do
    UI.setClass(id,value)
  end
  --restore persistent UI state for objects
  for key,value in pairs(GD.states.object_UI) do
    local params = Split(key,":")
    local guid = params[1]
    local id = params[2]
    local field = params[3]
    local obj = getObjectFromGUID(guid)
    assert(obj, "restoreGameState() unable to locate object for guid "..tostring(guid))
    obj.UI.setAttribute(id, field, value)
  end
  --update all UI states with current data
  if GD.game.started then
    updateHUD()
    local pcol = GD.game.player_order[GD.game.current_player]
    --handle mystrune token
    if GD.game.players[pcol].mystrune ~= nil then
      if env.test.debug then log("reassign mystrune to "..pcol) end
      local o = getObjectFromGUID(GD.game.players[pcol].mystrune)
      o.call("assign",pcol)
    end
    local o = getObjectFromGUID(C.guids.dice_flip_chart)
    if o then o.setInvisibleTo({}) end
    local o = getObjectFromGUID(C.guids.excess_spell_prestige)
    if o then o.setInvisibleTo({}) end
  end
end

--////////// Game Setup ////////////

--[[ Button handler for "Start Game".  Setup player order and
    enable class board selection. ]]
function startGameBtn()
  local seated = getSeatedPlayers()
  if(env.test.test_players) then
    seated = env.test.test_players
  end
  if env.test.debug then log("Seated players: "); log(seated) end
  local colors_ok = true;
  for _,c in ipairs(seated) do
    if not(contains(env.game.player_table_order,c)) then
      broadcastToAll("Seated player color "..c.." not present at this table.  Please choose another color.")
      colors_ok = false
    end
  end
  if not(colors_ok) then return end
  UI_setAttribute("start_pnl","active",false)
  --get random start player and assign player order in table clockwise order
  GD.game.player_count = #seated
  local start_color = seated[math.random(1, GD.game.player_count)]
  GD.game.player_order = {}
  GD.game.players = {}
  local order = ""
  local p = indexOf(env.game.player_table_order, start_color)
  for i=1, #env.game.player_table_order do
    local pcol = env.game.player_table_order[p]
    if contains(seated, pcol) then
      GD.game.players[pcol] = {}
      table.insert(GD.game.player_order, pcol)
      if order == "" then order = pcol
      else order = order .. ", " .. pcol end
    end
    p = p + 1
    if p > #env.game.player_table_order then p = 1 end --wrap around end
  end
  GD.game.start_player = indexOf(GD.game.player_order, start_color)
  if GD.env.verbose then print("Player order is " .. order) end
  if env.test.debug then log("Player order is " .. order) end
  --set up the table
  getObjectFromGUID(GD.game.heroics_deck_guid).shuffle()
  getObjectFromGUID(GD.game.spells_deck_guid).shuffle()
  getObjectFromGUID(GD.game.alterations_deck_guid).shuffle()
  getObjectFromGUID(GD.game.artifacts_deck_guid).shuffle()
  -- Enable class boards
  for class, guid in pairs(C.guids.class_boards) do
    local class_board = getObjectFromGUID(guid)
    assert(class_board)
    class_board.interactable = true
    class_board.setLock(false)
  end
  GD.game.assigned_boards_count = 0
  GD.game.current_player = #GD.game.player_order
  if env.test.debug then log("Active player is "..GD.game.player_order[GD.game.current_player]) end
  if GD.env.verbose then print("Active player is "..GD.game.player_order[GD.game.current_player]) end
  --display cast selection UI
  for i=1,4 do
    UI_setAttribute("selectClass_"..tostring(i).."_panel","color","rgba(0,0,0,0)")
    UI_setAttribute("selectClass_"..tostring(i).."_text","text","")
    UI_setAttribute("selectClassLocation_"..tostring(i).."_text","text","")
  end
  local i = 1
  for p=#GD.game.player_order,1,-1 do
    local pcol = GD.game.player_order[p]
    UI_setAttribute("selectClass_"..tostring(i).."_panel","color",pcol)
    UI_setAttribute("selectClass_"..tostring(i).."_text","text",pcol)
    UI_setAttribute("selectClassLocation_"..tostring(i).."_text","text",tostring(i))
    i=i+1
  end
  UI_setAttribute("select_class_pnl","active","true")
  if env.test.auto_switch then
    autoSwitch(GD.game.player_order[GD.game.current_player])
  end
end

--[[ Called from player board on class select.
    If player is unnassigned, set associations to player board.
    Otherwise show error message and return with no action.
    Calls back to player board to finish setup if successful. ]]
function setPlayerClass(params)
  if env.test.trace then log("Global: setPlayerClass()") end
  assert(params.player, "parameter 'player' missing")
  assert(params.guid, "parameter 'guid' missing")
  assert(params.position, "parameter 'position' missing")
  local position = params.position
  local pcol = params.player
  local error = false;
  local player = GD.game.players[pcol]
  if not(contains(GD.game.player_order, pcol)) then
    broadcastToAll("Player " .. pcol .. " is not a player in this game.")
    error = true
  elseif pcol ~= GD.game.player_order[GD.game.current_player] then
    broadcastToColor("Player " .. pcol .. " is not the current player.", pcol)
    error = true
  elseif player.class then
    broadcastToColor("Player " .. pcol .. " cannot select a second class.", pcol)
    error = true
  elseif GD.game.positions[position] ~= "" then
    broadcastToAll("Player position "..position.." already taken.")
    error = true
  end
  local class_board = getObjectFromGUID(params.guid)
  assert(class_board, "ERROR: Global: setPlayerClass(): Missing class board object")
  local setup = C.setup[class_board.getName()]
  assert(setup, "ERROR: Global:setPlayerClass() missing setup data for "..class_board.getName())
  if error then
    class_board.setPosition(setup.home_position)
    return
  else
    local z = getObjectFromGUID(C.guids.board_zones[position])
    if z ~= nil then z.destruct() end
    class_board.call("initialize")
    if GD.env.verbose then print("Player " .. pcol .. " selected class " .. class_board.getName()) end
    GD.game.positions[position] = pcol
    player.player_color = pcol
    player.name = Player[pcol].steam_name
    player.active = false
    player.class = class_board.getName()
    player.color_bar = C.guids.color_bars[position]
    player.class_board = class_board.getGUID()
    player.player_board = C.guids.player_boards[position]
    player.alteration_cards = {}
    player.heroics = {}
    player.active_spell_cards = {}
    player.cast_spells = {}
    player.arcanas = {}
    player.prestige = 0
    player.actions = {}
    player.actions.take = {} --{"any"|"spell"}
    player.actions.play = 0
    player.dice = {}
    for i=1,setup.start_dice do
      local val = math.random(1,6)
      table.insert(player.dice, {value=val,allocated=false,element=C.die_elements[val]})
      UI_setAttribute(pcol.."_hud_die_"..tostring(i).."_image", "image", C.die_elements[val])
      UI_setClass(pcol.."_hud_die_"..tostring(i).."_image", "image_active")
    end
    for i=setup.start_dice+1,7 do
      UI_setClass(pcol.."_hud_die_"..tostring(i).."_image", "image_inactive")
    end
    player.mana = setup.start_mana
    player.spent_mana = 0
    player.acuity = setup.start_acuity
    player.sigils = { red = 0, blue = 0, green = 0, yellow = 0, wild = 0}
    player.alt_sigils = { red = 0, blue = 0, green = 0, yellow = 0, }
    player.sigils[setup.board_sigil] = 1
    player.dice_translation = simpleDeepCopy(setup.dice_translation)
    if setup.aetherflow then player.aetherflow = setup.aetherflow end
    if setup.acuity_discount then player.acuity_discount = setup.acuity_discount end
    if setup.reroll_mod then player.reroll_mod = setup.reroll_mod end
    --initialize spell power
    player.spell_power = {
      dice = {
        restore = 0,
        ruin = 0,
      },
      acuity = {
        restore = 0,
        ruin = 0,
      },
      mystrune = {restore=0,ruin=0},
      card_map = {
        base_spells = {{guid="",id=""},{guid="",id=""},{guid="",id=""},{guid="",id=""},{guid="",id=""},},
        link_spells = {{},{},{},{},{},},
        enchant_spells = {{guid="",id=""},{guid="",id=""},{guid="",id=""},},
      },
      cards = {
        restore = 0,
        ruin = 0,
      },
      gross_restore = 0,
      net_restore = 0,
      gross_ruin = 0,
      net_ruin = 0,
      myst = 0,
    }
    --player score data structure
    player.score = {
      heroics = 0,
      arcanas = 0,
      sigils = 0,
      prestige = 0,
      total = 0,
    }
    --action dialog handler stuffs
    player.alteration_action = nil
    player.casting = false
    player.mystrune_action = nil
    --setup position color bar
    local color_bar = getObjectFromGUID(player.color_bar)
    assert(color_bar,"Global:setPlayerClass(): unable to get color bar "..tostring(player.color_bar))
    object_UI_setAttribute(player.color_bar, "block_text_id", "text", player.name)
    color_bar.setColorTint(pcol)
    color_bar.setInvisibleTo({})
    --deal start cards to player and assign them
    local start_deck = getObjectFromGUID(setup.start_deck)
    assert(start_deck,"ERROR: Global:setPlayerClass(): unable to get start deck for board "..tostring(class_board))
    start_deck.memo = JSON.encode({used=false,player=pcol}) --gets assigned to cards as they leave deck
    local start_cards = start_deck.getObjects()
    for _,c in ipairs(start_cards) do
      table.insert(player.alteration_cards, c.guid)
    end
    start_deck.deal(#start_cards, pcol)
    local artifacts_deck = getObjectFromGUID(C.guids.artifacts_deck)
    assert(artifacts_deck,"ERROR: Global:setPlayerClass(): unable to get artifacts deck for board "..tostring(class_board))
    local count = 0
    Wait.time(function()
      artifacts_deck.takeObject(
        {callback_function = function(o)
          table.insert(player.alteration_cards, o.guid)
          o.memo = JSON.encode({used=false,player=pcol})
          o.deal(1,pcol)
        end}
      )
      count = count + 1
      if count == setup.artifact_cards then
        --If all players assigned to boards, do final setup (which destroys the artifact deck!)
        if GD.game.assigned_boards_count == GD.game.player_count then
          UI_setAttribute("select_class_pnl","active","false")
          Wait.frames(function() finalSetup() end, 10)
        end
      end
    end, 0.5, setup.artifact_cards)
    local player_board = getObjectFromGUID(player.player_board)
    assert(player_board, "ERROR: Global: setPlayerClass(): Missing board object")
    player_board.call("initialize",player)
    class_board.call("updateUI",player)
    GD.game.assigned_boards_count = GD.game.assigned_boards_count + 1
    UI_setAttribute("selectClass_"..tostring(GD.game.assigned_boards_count).."_panel","color","Grey")
    UI_setAttribute("selectClass_"..tostring(GD.game.assigned_boards_count).."_text","text","Done")
    if GD.game.assigned_boards_count < GD.game.player_count then
      local next = GD.game.current_player - 1
      if next == 0 then
        --TODO: A BUG if this happens, should always finish on 1st player in order
        next = #GD.game.player_order
        log("WARN: Global:setPlayerClass(): Did not finish on 1st player in player order.")
      end
      GD.game.current_player = next
      if GD.env.verbose then print("Active player is "..GD.game.player_order[GD.game.current_player]) end
      if env.test.auto_switch then autoSwitch(GD.game.player_order[GD.game.current_player]) end
    end
  end
end

--[[ Final game setup after all players have selected a class. ]]
function finalSetup()
  if env.test.trace then log("Global: finalSetup()") end
  --cleanup unused boards & stuff not used
  for _,guid in pairs(C.guids.class_boards) do
    getObjectFromGUID(guid).call("cleanupBoard")
  end
  for _,guid in pairs(C.guids.player_boards) do
    getObjectFromGUID(guid).call("cleanupBoard")
  end
  for i=1,4 do
    if GD.game.positions[i] == "" then
      getObjectFromGUID(C.guids.color_bars[i]).destruct()
    end
    local zone =getObjectFromGUID(C.guids.board_zones[i])
    if zone ~= nil then zone.destruct() end
  end
  for _,s in pairs(C.setup) do
    local deck = getObjectFromGUID(s.start_deck)
    if deck ~= nil then deck.destruct() end
  end
  local d = getObjectFromGUID(C.guids.artifacts_deck)
  if d ~= nil then d.destruct() end
  --deal out starting cards
  local p = {
    ["position"] = {},
    ["flip"] = true,
    ["top"] = true,
    ["smooth"] = true
  }
  -- Place spell cards
  local deck = getSpellsDeck()
  for i=1,6 do
    p.position = GD.game.spells[i].pos
    p.callback_function = function(obj)
      GD.game.spells[i].card_id = tonumber(obj.getGMNotes())
      GD.game.spells[i].card_guid = obj.getGUID()
      Wait.condition(
        function() obj.setLock(true) end,
        function() return obj.resting end)
    end
    deck.takeObject(p)
    object_UI_setAttribute(g_lower, "spells_button_"..tostring(i).."_pnl","active",false)
  end
  object_UI_setAttribute(g_lower, "spells_buttons_pnl","active",true)
  -- Place Alteration cards
  deck = getAlterationsDeck()
  for i=1,6 do
    p.position = GD.game.alterations[i].pos
    p.callback_function = function(obj)
      GD.game.alterations[i].card_id = tonumber(obj.getGMNotes())
      GD.game.alterations[i].card_guid = obj.getGUID()
      if i <= GD.game.player_count then
        GD.game.alterations[i].acuity = 1
        object_UI_setAttribute(g_lower, "alterations_acuity_"..tostring(i).."_text","text","1")
        object_UI_setAttribute(g_lower, "alterations_acuity_"..tostring(i).."_pnl","active",true)
      else
        GD.game.alterations[i].acuity = 0
        object_UI_setAttribute(g_lower, "alterations_acuity_"..tostring(i).."_text","text","0")
        object_UI_setAttribute(g_lower, "alterations_acuity_"..tostring(i).."_pnl","active",false)
      end
      Wait.condition(
        function() obj.setLock(true) end,
        function() return obj.resting end)
    end
    deck.takeObject(p)
    object_UI_setAttribute(g_lower, "alterations_button_"..tostring(i).."_pnl","active",false)
  end
  object_UI_setAttribute(g_lower, "alterations_acuity_pnl","active",true)
  object_UI_setAttribute(g_lower, "alterations_buttons_pnl","active",true)
  -- Place Heroic cards
  deck = getHeroicsDeck()
  for i=1,6 do
    p.position = GD.game.heroics[i].pos
    p.callback_function = function(obj)
      GD.game.heroics[i].card_id = tonumber(obj.getGMNotes())
      GD.game.heroics[i].card_guid = obj.getGUID()
      Wait.condition(
        function() obj.setLock(true) end,
        function() return obj.resting end)
    end
    deck.takeObject(p)
    object_UI_setAttribute(g_upper, "heroics_"..tostring(i).."_pnl","active",false)
  end
  object_UI_setAttribute(g_upper, "heroics_pnl","active",true)
  -- Place the random selected myst rune (if Mystcaller not taken)
  if (math.random(1, 10) > 5) then
    GD.game.mystrune = C.guids.myst_rune_1
    GD.game.mystrune_type = "Restore"
    getObjectFromGUID(C.guids.myst_rune_2).destruct()
  else
    GD.game.mystrune = C.guids.myst_rune_2
    GD.game.mystrune_type = "Ruin"
    getObjectFromGUID(C.guids.myst_rune_1).destruct()
  end
  local mystcaller = false
  for pcol,p in pairs(GD.game.players) do
    if p.class == "Mystcaller" then
      p.mystrune = GD.game.mystrune
      local board = getObjectFromGUID(p.player_board)
      board.call("placeMystRune", {guid=GD.game.mystrune})
      local o = getObjectFromGUID(p.mystrune)
      o.call("assign",pcol)
      mystcaller = true
    end
  end
  if not(mystcaller) then
    local myst_rune = getObjectFromGUID(GD.game.mystrune)
    myst_rune.setPosition(C.pos.myst_rune)
    Wait.frames(function() myst_rune.setLock(true) end, 1)
  end
  -- Random select 3 arcanas
  GD.game.arcanas = {}
  local t = {1, 2, 3, 4, 5, 6,}
  for i=1,3 do
    local n = math.random(1,#t)
    local arcana = simpleDeepCopy(C.arcanas[t[n]])
    arcana.taken = false
    table.insert(GD.game.arcanas, arcana)
    local o = getObjectFromGUID(C.arcanas[t[n]].guid)
    o.setInvisibleTo({})
    if GD.env.card_tooltips then
      local txt = "Requirement: "..arcana.desc.requirement
      txt = txt.."\nReward: "..arcana.desc.reward
      o.setDescription(txt)
      o.tooltip = true
    else
      o.tooltip = false
    end
    o.setLock(false)
    o.setPosition(C.arcana_pos[i])
    Wait.frames(function() --start moving
      Wait.condition(function() o.setLock(true) end,
      function() return o.resting end)
    end, 10)
    table.remove(t,n)
    object_UI_setAttribute(g_upper, "arcana_"..tostring(i).."_pnl","active",false)
  end
  --Destroy unused arcanas
  for _,i in ipairs(t) do
    local o = getObjectFromGUID(C.arcanas[i].guid)
    if o then o.destruct() end
  end
  object_UI_setAttribute(g_upper, "heroics_cancel_pnl","active",false)
  object_UI_setAttribute(g_upper, "arcanas_pnl","active",true)
  -- Give extra acuity to players in turn order
  local p = GD.game.start_player
  local count = 1
  for n=1,GD.game.player_count-1 do
    if p > GD.game.player_count then p = 1 end --wrap around
    local pcol = GD.game.player_order[p]
    GD.game.players[pcol].acuity = GD.game.players[pcol].acuity + count
    if GD.env.verbose then print(pcol.." starts with "..tostring(count).." extra Acuity") end
    count = count + 1
  end
  --Configure final scoring table and HUD for number of players
  local num_players = #GD.game.player_order
  for i=1,4 do
    if i > num_players then
      UI_setAttribute("score_table_row_"..tostring(i), "active", "false")
      UI_setAttribute("hud_row_"..tostring(i), "active", "false")
    else
      UI_setAttribute("hud_row_"..tostring(i).."_player", "text", GD.game.player_order[i])
      UI_setAttribute("hud_row_"..tostring(i).."_player", "color", GD.game.player_order[i])
    end
  end
  local panel_size = 120 + (num_players * 50)
  UI_setAttribute("score_panel", "height", tostring(panel_size))
  local inner_hud_panel_size = 220 + (num_players * 30)
  local outer_hud_panel_size = inner_hud_panel_size + 20
  UI_setAttribute("inner_hud_panel","height",tostring(inner_hud_panel_size))
  UI_setAttribute("hud_pnl","height",tostring(outer_hud_panel_size))
  UI_setAttribute("hud_pnl","active",true)
  --displapy helper charts
  local flip = getObjectFromGUID(C.guids.dice_flip_chart)
  flip.setPosition(C.pos.dice_flip)
  flip.setInvisibleTo({})
  flip.setLock(true)
  local excess = getObjectFromGUID(C.guids.excess_spell_prestige)
  excess.setPosition(C.pos.excess_spell_prestige)
  excess.setInvisibleTo({})
  excess.setLock(true)
  --done with final setup
  GD.game.started = true
  --TODO: figure out what to wait on, all card data structures not yet set up.
  --TODO: this wait may not be necessary anymore. waiting on card deals to finish now before calling finalSetup()
  Wait.time(function()
    startPlayerTurn(GD.game.player_order[GD.game.current_player])
  end,2)
end

--////////// Game Flow ////////////

--[[ Handler for Take used Alterations button on player boards. ]]
function takeUsedAlterationsBtn(player, button, id)
  if env.test.trace then log("Global: takeUsedAlterationsBtn() "..player.color..", "..tostring(id)) end
  if player.color ~= GD.game.player_order[GD.game.current_player] then return end
  local pdata = GD.game.players[player.color]
  local index = indexOf(pdata.actions.take, "any")
  if not(index > 0) then
    --shouldn't happen if we're disabling the button correctly
    if env.test.debug then log("WARN: takeUsedAlterationsBtn() player has no take actions, ignoring") end
    return
  end
  returnUsedAlterations(player.color)
  local index = indexOf(pdata.actions.take, "any")
  if index > 0 then table.remove(pdata.actions.take, index)
  else log("WARN: takeUsedAlterationsBtn(): unable to decrement take actions") end
  pdata.cast_allowed = false
  updateHUD()
end

--[[ Return all used alteration cards to player's hand and set them unused. ]]
function returnUsedAlterations(pcol)
  if env.test.trace then log("Global: returnUsedAlterations() "..tostring(pcol)) end
  local player_board = getObjectFromGUID(GD.game.players[pcol].player_board)
  local used = player_board.call("getUsedAlterations")
  if used then
    if env.test.debug then log("Global:returnUsedAlterations(): processing used alterations") end
    assert(used.tag == "Deck" or used.tag == "Card", "Global:returnUsedAlterations() unexpected object, not card or deck.")
    if used.tag == "Deck" then
      local cards = used.getObjects()
      used.deal(#cards, pcol)
      Wait.condition(function()           --TODO: Wait.time here?
        for _,c in ipairs(cards) do
          local card = getObjectFromGUID(c.guid)
          assert(card, "takeUsedAlterationsBtn(): no card "..c.guid)
          local memo = JSON.decode(card.memo)
          assert(memo, "takeUsedAlterationsBtn(): no memo for card "..c.guid)
          memo.used = false
          card.memo = JSON.encode(memo)
        end
      end, function() return used.isDestroyed() end)
    elseif used.tag == "Card" then
      local card = used
      assert(card.memo, "takeUsedAlterationsBtn(): no memo for card "..card.getGUID())
      local memo = JSON.decode(card.memo)
      memo.used = false
      card.memo = JSON.encode(memo)
      card.deal(1, pcol)
    end
  end
end

--[[ Handler for Done button on player boards. ]]
function playerDoneBtn(player, button, id)
  if env.test.trace then log("Global: playerDoneBtn() "..player.color..", "..tostring(id)) end
  if player.color ~= GD.game.player_order[GD.game.current_player] then return end
  setNextPlayer()
end

--[[TESTING ONLY: Facilitate testing.  Switch test player color to game active player color.]]
function autoSwitch(pcol)
  if env.test.trace then log("Global: autoSwitch() "..tostring(pcol)) end
  local players = Player.getPlayers()
  if #players == 1 then
    if env.test.debug then log("Test player current color: "..tostring(players[1].color)) end
    if pcol then
      if players[1].color ~= pcol then
        if env.test.debug then log("Switching color to pcol: "..tostring(pcol)) end
        players[1].changeColor(pcol)
      end
    else
      if players[1].color ~= GD.game.player_order[GD.game.current_player] then
        if env.test.debug then log("Switching color to: "..GD.game.player_order[GD.game.current_player]) end
        players[1].changeColor(GD.game.player_order[GD.game.current_player])
      end
    end
  end
end

--[[ Setup stuff at beginning of player turn. ]]
function startPlayerTurn(pcol)
  if env.test.trace then log("Global:startPlayerTurn() "..tostring(pcol)) end
  if env.test.debug then log(GD.game.players[pcol]) end
  if pcol ~= GD.game.player_order[GD.game.current_player] then return end
  local pdata = GD.game.players[pcol]
  if GD.game.endgame then
    pdata.active = true
    object_UI_setAttribute(g_lower, "recycle_spell_pnl", "active", false)
    updateHUD()
  else
    pdata.actions.take = {"any"}
    pdata.actions.play = 1
    object_UI_setAttribute(g_lower, "recycle_spell_pnl", "active", true)
    for i=1,6 do
      object_UI_setAttribute(g_lower, "alterations_button_"..tostring(i).."_pnl", "active", true)
    end
    pdata.active = true
    pdata.cast_allowed = true
    if GD.env.verbose then print("Active player is " .. GD.game.player_order[GD.game.current_player]) end
    updateHUD()
  end
end

--[[ Set the next player in player_order.
  Wraps to first player if last is current. ]]
function setNextPlayer()
  if env.test.trace then log("Global: setNextPlayer()") end
  log("------- setNextPlayer, endgame = "..tostring(GD.game.endgame))
  if GD.game.endgame then
    if env.test.debug then log("setNextPlayer() end game!!!") end
    if #GD.game.endgame_players == 0 then
      updateHUD()
      finalScore()
      return
    else
      --disable previous player stuffs
      local pdata = GD.game.players[GD.game.player_order[GD.game.current_player]]
      pdata.active = false
      local pcol = GD.game.endgame_players[1]
      log("Starting endgame player turn for "..pcol)
      --TODO: check if player has nothing and skip them
      if GD.env.verbose then broadcastToAll("Player "..pcol.." Cast your final Spell.") end
      table.remove(GD.game.endgame_players,1)
      GD.game.current_player = indexOf(GD.game.player_order, pcol)
      if env.test.auto_switch then autoSwitch(pcol) end
      if GD.env.verbose then print("Active player is "..pcol) end
      refillHeroics()
      -- startPlayerTurn(pcol)
      Wait.frames(function() startPlayerTurn(pcol) end,10)
    end
  else
    --disable previous player stuffs
    local pdata = GD.game.players[GD.game.player_order[GD.game.current_player]]
    pdata.active = false
    --advance curent player
    if GD.game.current_player == #GD.game.player_order then
      GD.game.current_player = 1
    else
      GD.game.current_player = GD.game.current_player + 1
    end
    refillCards()
    local pcol = GD.game.player_order[GD.game.current_player]
    if env.test.auto_switch then autoSwitch(GD.game.player_order[GD.game.current_player]) end
    if GD.env.verbose then print("Active player is " .. GD.game.player_order[GD.game.current_player]) end
    --TODO: figure out how to wait for refillCards()
    Wait.frames(function() startPlayerTurn(pcol) end,10)
  end
end

--[[ Called from setNextPlayer (on turn "done") --]]
function refillCards()
  if env.test.trace then log("Global: refillCards()") end
  refillSpells()
  refillAlterations()
  refillHeroics()
end

--[[ Shift spell cards left to fill empty spaces, placing new cards in rightmost spot. --]]
function refillSpells()
  if env.test.trace then log("Global: refillSpells()") end
  local empty = 0
  for i=1,6 do
    if GD.game.spells[i].card_guid == "" then empty = empty + 1 end
  end
  for n=1,empty do
    for i=1,5 do
      if GD.game.spells[i].card_guid == "" then
        for j=i+1,6 do
          card = getObjectFromGUID(GD.game.spells[j].card_guid)
          if card ~= nil then
            card.setPosition(GD.game.spells[j-1].pos)
            GD.game.spells[j-1].card_id = GD.game.spells[j].card_id
            GD.game.spells[j-1].card_guid = GD.game.spells[j].card_guid
            GD.game.spells[j].card_id = 0
            GD.game.spells[j].card_guid = ""
          end
        end
      end
    end
  end
  --now fill empty spots with cards
  for i=6-(empty-1),6 do
    local deck = getSpellsDeck()
    if deck then
      local card
      if deck.tag == "Deck" then
        card = deck.takeObject({
          position = GD.game.spells[i].pos,
          flip = true,
          top = true,
          smooth = false,
          callback_function = function(obj)
            GD.game.spells[i].card_id = tonumber(obj.getGMNotes())
            GD.game.spells[i].card_guid = card.getGUID()
            Wait.condition(function() obj.setLock(true) end,
              function() return obj.resting end)
            end
        })
      elseif deck.tag == "Card" then
        card = deck
        GD.game.spells[i].card_id = tonumber(card.getGMNotes())
        GD.game.spells[i].card_guid = card.getGUID()
      else
        log("ERROR: Global: refillSpells() unknown spell deck object")
      end
    else
      log("WARN: spells deck is empty!")  --not sure this can ever happen, but warn anyway.
    end
  end
end

--[[ Place acuity on remaining cards to left of rightmost empty spot.
    Then shift cards left to fill empty spaces, placing new cards in rightmost spot.
    Move acuity with the cards. --]]
function refillAlterations()
  if env.test.trace then log("Global: refillAlterations()") end
  local tbl = GD.game.alterations
  local empty = 0
  local last_empty_spot = 0
  for i=1,6 do
    if tbl[i].card_guid == "" then
      empty = empty + 1
      last_empty_spot = i
    end
  end
  --add acuity to cards up to last empty spot
  for i=1,last_empty_spot do
    if tbl[i].card_guid ~= "" then
      tbl[i].acuity = tbl[i].acuity + 1
    end
  end
  --now shift cards left to fill empty spots
  for n=1,empty do
    for i=1,5 do
      if tbl[i].card_guid == "" then
        for j=i+1,6 do
          card = getObjectFromGUID(tbl[j].card_guid)
          if card ~= nil then
            card.setPosition(tbl[j-1].pos)
            tbl[j-1].card_id = tbl[j].card_id
            tbl[j-1].card_guid = tbl[j].card_guid
            tbl[j-1].acuity = tbl[j].acuity
            tbl[j].card_id = 0
            tbl[j].card_guid = ""
          end
        end
      end
    end
  end
  --now fill remaining empty spots with cards
  for i=6-(empty-1),6 do
    local deck = getAlterationsDeck()
    if deck then
      local card
      if deck.tag == "Deck" then
        card = deck.takeObject({
          position = tbl[i].pos,
          flip = true,
          top = true,
          smooth = false,
          callback_function = function(obj)
            tbl[i].card_id = tonumber(obj.getGMNotes())
            tbl[i].card_guid = card.getGUID()
            Wait.condition(function() obj.setLock(true) end,
              function() return obj.resting end)
            end
        })
      elseif deck.tag == "Card" then
        card = deck
        tbl[i].card_id = tonumber(card.getGMNotes())
        tbl[i].card_guid = card.getGUID()
      else
        log("ERROR: Global: refillAlterations() unknown deck object")
      end
    else
      log("WARN: refillAlterations() deck is empty!")  --not sure this can ever happen, but warn anyway.
    end
  end
  --update acuity panels
  for i=1,6 do
    if tbl[i].acuity > 0 then
      object_UI_setAttribute(g_lower, "alterations_acuity_"..tostring(i).."_text","text",tostring(tbl[i].acuity))
      object_UI_setAttribute(g_lower, "alterations_acuity_"..tostring(i).."_pnl","active",true)
    else
      object_UI_setAttribute(g_lower, "alterations_acuity_"..tostring(i).."_text","text","0")
      object_UI_setAttribute(g_lower, "alterations_acuity_"..tostring(i).."_pnl","active",false)
    end
  end
end

--[[ Refill the Heroics card positions. --]]
function refillHeroics()
  if env.test.trace then log("Global: refillHeroics()") end
  --only one spot should be empty during play.
  local deck = getHeroicsDeck()
  if deck then
    if deck.tag == "Deck" then
      local p = {
        ["position"] = {},
        ["flip"] = true,
        ["top"] = true,
        ["smooth"] = true
      }
      for i=1,6 do
        if GD.game.heroics[i].card_guid == "" then
          p.position = GD.game.heroics[i].pos
          p.callback_function = function(obj)
            GD.game.heroics[i].card_id = tonumber(obj.getGMNotes())
            GD.game.heroics[i].card_guid = obj.getGUID()
            Wait.condition(
              function() obj.setLock(true) end,
              function() return obj.resting end)
          end
          deck.takeObject(p)
          return
        end
      end
    else
      --last card in heroics deck. shouldn't happen but handle case anyway
      log("WARN: placing last Heroic card in deck")
      local card = deck
      for i=1,6 do
        if GD.game.heroics[i].card_guid == "" then
          card.setPosition(GD.game.heroics[i].pos)
          if card.is_face_down then card.flip() end
          Wait.condition(
            function() card.setLock(true) end,
            function() return card.resting end)
          return
        end
      end
    end
  else
    log("WARN: Heroic deck is empty.")
  end
end

--[[ Calculate the spell power of an active spell card for specified player.
    Returns tuple:  Restore, Ruin
--]]
function getCardSpellPower(card, pcol)
  local spell = spells[tonumber(card.getGMNotes())]
  assert(spell, "getCardSpellPower(): failed to locate card data")
  local restore, ruin = 0, 0
  if spell.base then
    if spell.aether_mod then
      if hasAether(pcol) then
        restore = spell.aether.restore
        ruin = spell.aether.ruin
      else
        restore = spell.base.restore
        ruin = spell.base.ruin
      end
    else
      restore = spell.base.restore
      ruin = spell.base.ruin
    end
  elseif spell.count then
    if spell.aether_mod then
      if hasAether(pcol) then
        restore = spell.aether.restore * #GD.game.players[pcol].active_spell_cards
        ruin = spell.aether.ruin * #GD.game.players[pcol].active_spell_cards
      else
        restore = spell.count.restore * #GD.game.players[pcol].active_spell_cards
        ruin = spell.count.ruin * #GD.game.players[pcol].active_spell_cards
      end
    else
      restore = spell.count.restore * #GD.game.players[pcol].active_spell_cards
      ruin = spell.count.ruin * #GD.game.players[pcol].active_spell_cards
    end
  elseif spell.acuity then
    restore = spell.acuity.restore * GD.game.players[pcol].acuity
    ruin = spell.acuity.ruin * GD.game.players[pcol].acuity
  end
  if spell.option then
    if card.memo == "Restore" then ruin = 0
    elseif card.memo == "Ruin" then restore = 0
    else
      log("ERROR: getCardSpellPower() invalid memo for option card id "..spell.id)
    end
  end
  return restore, ruin
end

--[[ Calculate spell power for a player.
Recalcuate the player spell_power data based on current player state.
]]
function updateSpellPower(pcol)
  if env.test.trace then log("Global: updateSpellPower() "..tostring(pcol)) end
  local pdata = GD.game.players[pcol]
  local s = pdata.spell_power
  s.gross_restore = 0
  s.gross_ruin = 0
  --Spell Cards
  local slots = {{restore=0,ruin=0},{restore=0,ruin=0},{restore=0,ruin=0},{restore=0,ruin=0},{restore=0,ruin=0},}
  for i=1,5 do
    local spell = spells[s.card_map.base_spells[i].id]
    if spell then
      local restore, ruin = getCardSpellPower(getObjectFromGUID(spell.guid), pcol)
      slots[i].restore = restore
      slots[i].ruin = ruin
    end
    --handle any linked spell(s) that modify the base in this slot
    for _,link in ipairs(s.card_map.link_spells[i]) do
      local spell = spells[link.id]
      if spell then
        if spell.aether_mod then
          if hasAether(pcol) then
            slots[i].restore = slots[i].restore * spell.link.aether
            slots[i].ruin = slots[i].ruin * spell.link.aether
          else
            slots[i].restore = slots[i].restore * spell.link.base
            slots[i].ruin = slots[i].ruin * spell.link.base
          end
        else
          slots[i].restore = slots[i].restore * spell.link.base
          slots[i].ruin = slots[i].ruin * spell.link.base
        end
      end
    end
  end
  --total up all card slots and add to gross
  s.cards.restore = 0
  s.cards.ruin = 0
  for i=1,5 do
    s.cards.restore = s.cards.restore + slots[i].restore
    s.cards.ruin = s.cards.ruin + slots[i].ruin
  end
  s.gross_restore = s.gross_restore + s.cards.restore
  s.gross_ruin = s.gross_ruin + s.cards.ruin
  --Unallocated Dice
  s.dice.restore = 0
  s.dice.ruin = 0
  for _,d in ipairs(pdata.dice) do
    if not(d.allocated) then
      if pdata.dice_translation[d.value] == "restore" then
        s.dice.restore = s.dice.restore + 1
      elseif pdata.dice_translation[d.value] == "ruin" then
        s.dice.ruin = s.dice.ruin + 1
      end
    end
  end
  s.gross_restore = s.gross_restore + s.dice.restore
  s.gross_ruin = s.gross_ruin + s.dice.ruin
  --Any Acuity spell power bought
  s.gross_restore = s.gross_restore + s.acuity.restore
  s.gross_ruin = s.gross_ruin + s.acuity.ruin
  --Mystrune
  s.gross_restore = s.gross_restore + s.mystrune.restore
  s.gross_ruin = s.gross_ruin + s.mystrune.ruin
  -- after all above, handle enchantment spells in converting total spell power
  for i=1,3 do
    local spell = spells[s.card_map.enchant_spells[i].id]
    if spell then
      if spell.enchant then
        if spell.enchant.restore > 0 then
          s.gross_restore = s.gross_restore + (s.gross_ruin * spell.enchant.restore)
          s.gross_ruin = 0
        elseif spell.enchant.ruin > 0 then
          s.gross_ruin = s.gross_ruin + (s.gross_restore * spell.enchant.ruin)
          s.gross_restore = 0
        end
      end
    end
  end
  --totals
  s.net_restore = 0
  s.net_ruin = 0
  s.myst = 0
  s.net_restore = s.gross_restore - s.gross_ruin
  if s.net_restore < 0 then s.net_restore = 0 end
  s.net_ruin = s.gross_ruin - s.gross_restore
  if s.net_ruin < 0 then s.net_ruin = 0 end
  if s.gross_restore == s.gross_ruin and s.gross_restore >= 6 then s.myst = s.gross_restore end
  if env.test.debug then log(s) end
end

--[[ Recalculate player score values from current data. ]]
function updateScore(pcol)
  if env.test.trace then log("Global: updateScore()") end
  local pdata = GD.game.players[pcol]
  pdata.score.heroics = 0
  pdata.score.prestige = pdata.prestige
  pdata.score.arcanas = 0
  pdata.score.sigils = 0
  pdata.score.total = pdata.prestige
  --heroics
  for _,h in ipairs(pdata.heroics) do
    pdata.score.heroics = pdata.score.heroics + h.vp
  end
  pdata.score.total = pdata.score.total + pdata.score.heroics
  --sigils
  local sigils = simpleDeepCopy(pdata.sigils)
  for s,n in pairs(pdata.alt_sigils) do sigils[s] = sigils[s] + n end --add in alteration sigils
  local pair = false
  local count = 0
  for s,n in pairs(sigils) do
    count = count + n
    if n > 2 then
      pdata.score.sigils = pdata.score.sigils + n
    elseif n == 2 then
      pdata.score.sigils = pdata.score.sigils + 1
      pair=true
    end
  end
  if pdata.sigils["wild"] > 0 and count > 0 then
    if pair then pdata.score.sigils = pdata.score.sigils + 2
    else pdata.score.sigils = pdata.score.sigils + 1 end
  end
  pdata.score.total = pdata.score.total + pdata.score.sigils
  --arcanas
  for _,a in ipairs(pdata.arcanas) do
    pdata.score.arcanas = pdata.score.arcanas + a.base_vp
    if a.bonus.spell_type == "Fire" or a.bonus.spell_type == "Water" then
      local c = 0
      for _,s in ipairs(pdata.cast_spells) do
        local d = spells[s.id]
        if contains(d.dice, a.bonus.spell_type) then c = c + 1 end
      end
      local bonus = math.floor(c/a.bonus.count)
      pdata.score.arcanas = pdata.score.arcanas + bonus
    elseif a.bonus.spell_type == "any" then
      pdata.score.arcanas = pdata.score.arcanas + math.floor(#pdata.cast_spells/a.bonus.count)
    elseif a.bonus.spell_type == "slot_count" then
      local c = 0
      for _,s in ipairs(pdata.cast_spells) do
        local d = spells[s.id]
        if d.slots >= a.bonus.slot_count then c = c + 1 end
      end
      pdata.score.arcanas = pdata.score.arcanas + math.floor(c/a.bonus.count)
    elseif a.bonus.spell_type == "aether_mod" then
      local c = 0
      for _,s in ipairs(pdata.cast_spells) do
        local d = spells[s.id]
        if d.aether_mod then c = c + 1 end
      end
      pdata.score.arcanas = pdata.score.arcanas + math.floor(c/a.bonus.count)
    elseif a.bonus.spell_type == "not_aether" then
      local c = 0
      for _,s in ipairs(pdata.cast_spells) do
        local d = spells[s.id]
        if not(d.aether_mod) then c = c + 1 end
      end
      pdata.score.arcanas = pdata.score.arcanas + math.floor(c/a.bonus.count)
    else
      assert(false,"Global:updateScore(): invalid arcana bonus spell_type")
    end
  end
  pdata.score.total = pdata.score.total + pdata.score.arcanas
end

--[[ Handle objects dropped in game.  Only certain object tags supported.  --]]
function onObjectDrop(pcol, obj)
  if GD.game.started then
    if obj.hasTag("Spell") then
      if obj.tag == "Deck" then
        log("WARN: onObjectDrop() deck with spell tag dropped "..obj.getGUID())
        return
      end
      if env.test.trace then log("Global: onObjectDrop() spell card "..obj.getGUID()) end
      local player_board = getObjectFromGUID(GD.game.players[pcol].player_board)
      local data = spells[tonumber(obj.getGMNotes())]
      local params = {
        guid = obj.getGUID(),
        map = GD.game.players[pcol].spell_power.card_map,
        card_data = data
      }
      if data.option then setSpellCardDecal(obj, pcol) end
      local map = player_board.call("locateSpell", params)
      assert(map, "Global:onObjectDrop(): player_board locateSpell() did not return a map")
      GD.game.players[pcol].spell_power.card_map = simpleDeepCopy(map)
      updateSpellPower(pcol)
      updateHUD()  --TODO: ok to update spell/alteration buttons here?
    elseif obj.hasTag("Alteration") then
      if contains(Player[pcol].getHandObjects(), obj) then return end --ignore moving in hand
      local current = GD.game.player_order[GD.game.current_player]
      local memo = JSON.decode(obj.memo)
      if memo ~= nil then
        if memo.used then
          local player_board = getObjectFromGUID(GD.game.players[pcol].class_board)
          player_board.call("placeUsedAlterationCard",{guid=obj.guid})
        else
          if memo.player == pcol then
            if GD.game.endgame then
              obj.deal(1,pcol)
              if GD.env.verbose then broadcastToColor("No card play in endgame.", pcol) end
            elseif pcol == current and GD.game.players[pcol].actions.play > 0 then
              local index = tonumber(obj.getGMNotes())
              obj.setLock(true)
              showAlterationDlg(obj.getGUID(), index)
            else
              obj.deal(1,pcol)
              if pcol == current and GD.env.verbose then broadcastToColor("You have no more play actions.", pcol) end
            end
          else
            obj.deal(1,memo.player)
          end
        end
      else
        log("ERROR: onObjectDrop(): alteration card "..obj.getGUID().." has no memo data.") --should not happen
      end
    end
  end
end

--[[ Set the Restore/Ruin decal on an active spell card.
    Also creates the button on the card for switching types.
    Only for spells that can switch types (data.option == true)
    Also See Related functions: onObjectPickUp() and cardButton().
--]]
function setSpellCardDecal(card, pcol)
  local data = spells[tonumber(card.getGMNotes())]
  assert(data, "setSpellCardDecal() no data for card "..card.getGUID())
  if card.memo ~= nil then
    --Set decal based on previous setting stored in card memo
    if card.memo == "Restore" then
      card.addDecal(C.card_decals["Restore"])
    elseif card.memo == "Ruin" then
      card.addDecal(C.card_decals["Ruin"])
    else
      log(self.getName().." ERROR: unexpected memo value on card "..card.getGUID())
    end
  else
    --Default initial decal by which card spell power is greater right now
    local s = GD.game.players[pcol].spell_power
    if s.net_ruin > s.net_restore then
      card.addDecal(C.card_decals.Ruin)
      card.memo = "Ruin"
    else
      card.addDecal(C.card_decals.Restore)
      card.memo = "Restore"
    end
  end
  createCardButton(card)
end

--[[ Create a button on an option spell card to toggle it's type --]]
function createCardButton(card)
  assert(card)
  if card ~= nil then
    params = {
      click_function = "cardButton",
      function_owner = Global,
      label          = "",
      position       = {0,1,-1},
      rotation       = {0,180,0},
      width          = 400,
      height         = 200,
      color          = {0,0,0,0},
      hover_color    = {0,0,0,0},
      press_color    = {0,0,0,0},
    }
    card.createButton(params)
  end
end
function t_createCardButton(params)
  assert(params)
  local card_guid = params.guid
  assert(card_guid)
  local card = getObjectFromGUID(card_guid)
  assert(card)
  createCardButton(card)
end

--[[ Button handler for card type toggle button ]]
function cardButton(card, player_color, mouse)
  local decals = card.getDecals()
  if decals ~= nil then
    card.setDecals({})
    if decals[1].name == "Restore" then
      card.addDecal(C.card_decals.Ruin)
      card.memo = "Ruin"
    elseif decals[1].name == "Ruin" then
      card.addDecal(C.card_decals.Restore)
      card.memo = "Restore"
    else
      log("Global: cardButton() ERROR: unidentified decal on card")
    end
    updateSpellPower(player_color)
    updateHUD()  --TODO: ok to update spell/alteration buttons here?
  end
end

--////////// Play Alteration dialog ////////////

--[[ Handler for the take Alteration button. ]]
function takeAlterationBtn(player, button, id)
  if env.test.trace then log("Global: takeAlterationBtn() "..tostring(player.color)..", "..tostring(id)) end
  if player.color ~= GD.game.player_order[GD.game.current_player] then return end
  local pdata = GD.game.players[player.color]
  local index = tonumber(Split(id,"_")[3])
  local card = getObjectFromGUID(GD.game.alterations[index].card_guid)
  GD.game.alterations[index].card_guid = ""
  GD.game.alterations[index].card_id = 0
  assert(card, "ERROR: Global:takeAlterationBtn() could not locate card")
  table.insert(pdata.alteration_cards, card.getGUID())
  card.memo = JSON.encode({used=false,player=player.color})
  card.deal(1,player.color)
  for _,s in ipairs(alterations[tonumber(card.getGMNotes())].sigils) do
    pdata.alt_sigils[s] = pdata.alt_sigils[s] + 1
  end
  pdata.acuity = pdata.acuity + GD.game.alterations[index].acuity
  if GD.env.verbose then print(pdata.player_color.." gains "..tostring(GD.game.alterations[index].acuity).." Acuity") end
  if pdata.acuity > 10 then
    if GD.env.verbose then print(pdata.player_color.." discards "..tostring(pdata.acuity-10).." Acuity") end
    pdata.acuity = 10
  end
  local index = indexOf(pdata.actions.take, "any")
  if index > 0 then table.remove(pdata.actions.take, index)
  else log("WARN: takeAlterationBtn(): unable to decrement take actions") end
  pdata.cast_allowed = false
  updateHUD()
end

--[[ Show the initial Alteration card dialog when playier plays an alteration card. ]]
function showAlterationDlg(guid, card_index)
  if env.test.trace then log("Global: showAlterationDlg() "..tostring(guid)..", "..tostring(card_index)) end
  if env.test.debug then assert(card_index and card_index > 0 and card_index < 45,"ERROR: showAlterationDlg(): invalid card index") end
  local pcol = GD.game.player_order[GD.game.current_player]
  local pdata = GD.game.players[pcol]
  pdata.alteration_action = {}
  local alt = pdata.alteration_action
  alt.player_color = pcol
  alt.card_id = card_index
  alt.card_guid = guid
  alt.acuity_available = GD.game.players[pcol].acuity
  alt.acuity_paid = 0   --Acuity to be deducted from player for the action if any.
  alt.from_dice = {}  --Dice matching card criteria for possible conversion.
  alt.to_dice = {}    --Dice that have been selected to convert.
  alt.min = 1   --Min dice to convert.  Always 1.
  alt.max = 0   --Max dice allowed to convert.  Will be set from card data + any mods
  alt.acuity_gained = 0   --Will be acuity player gains if any for the action.
  alt.play_gained = 0   --Will be number of plays gained from the action if any.
  alt.take_gained = {}  --Will contain any takes gained for the action.
  alt.opp_acuity_gained = 0   --If opponents get any Acuity for the action.
  alt.state = "select_action"   --State machine for dialog.
  if env.test.debug then log(alt) end
  updateAlterationDlg()
  UI_setAttribute("alteration_card_pnl","visibility",pcol)
  updateHUD(pcol)
end

--[[ Update the alteration dialog with current data structure. ]]
function updateAlterationDlg()
  if env.test.trace then log("Global: updateAlterationDlg()") end
  local pcol = GD.game.player_order[GD.game.current_player]
  local pdata = GD.game.players[pcol]
  local alt = pdata.alteration_action
  if alt.state == "select_action" then
    UI_setAttribute("alteration_card_img","image","Alt-"..tostring(alt.card_id))
    local card = alterations[alt.card_id]
    if env.test.debug then assert(card, "updateAlterationDlg(): can't find card data") end
    if card.primary then
      UI_setAttribute("alteration_primary_action_txt","text","PRIMARY: "..card.primary.actions[1].desc)
      local or_state = false
      if #card.primary.actions > 1 then
        UI_setAttribute("alteration_primary_or_action_txt","text","OR: "..card.primary.actions[2].desc)
        or_state = true
      end
      UI_setAttribute("alteration_primary_or_action_pnl","active",or_state)
    else
      UI_setAttribute("alteration_primary_action_txt","text","undefined")
      UI_setAttribute("alteration_primary_or_action_txt","text","undefined")
    end
    local secondary = card.secondary ~= nil
    -- if secondary and card.secondary.aetherflow then secondary = secondary and GD.game.players[pcol].aetherflow ~= nil end
    if secondary and card.secondary.aetherflow then secondary = secondary and pdata.aetherflow ~= nil end
    if secondary then
      UI_setAttribute("alteration_secondary_action_txt","text","SECONDARY: "..card.secondary.desc)
    end
    UI_setAttribute("alteration_secondary_action_pnl","active",secondary)
    UI_setAttribute("alteration_discard_action_pnl","active",card.discard == true)
    UI_setAttribute("alteration_pay_acuity_row","active",false)
    UI_setAttribute("alteration_convert_dice_row","active",false)
    UI_setAttribute("alteration_select_action_row","active",true)
    UI_setAttribute("alteration_done_pnl","active",false)
    UI_setAttribute("alteration_next_pnl","active",false)
    UI_setAttribute("alteration_cancel_pnl","active",true)
  elseif alt.state == "pay_acuity" then
    UI_setAttribute("alteration_available_acuity_txt","text",tostring(alt.acuity_available))
    UI_setAttribute("alteration_paid_acuity_txt","text",tostring(alt.acuity_paid))
    UI_setAttribute("alteration_pay_acuity_row","active",true)
    UI_setAttribute("alteration_next_pnl","active",alt.acuity_paid >= alt.acuity_min)
    UI_setAttribute("alteration_select_action_row","active",false)
    UI_setAttribute("alteration_done_pnl","active",false)
    UI_setAttribute("alteration_cancel_pnl","active",true)
  elseif alt.state == "convert" then
    UI_setAttribute("convert_to_dice_title_txt","text","Converted Dice:")
    UI_setAttribute("alteration_select_action_row","active",false)
    UI_setAttribute("alteration_pay_acuity_row","active",false)
    for i=1,7 do
      if alt.from_dice[i] and not(alt.from_dice[i].assigned) then
        UI_setAttribute("convert_from_die_"..tostring(i).."_img","image",alt.from_dice[i].element)
        UI_setClass("convert_from_die_"..tostring(i).."_img","image_active")
      else
        UI_setClass("convert_from_die_"..tostring(i).."_img","image_inactive")
      end
      if alt.to_dice[i] then
        UI_setAttribute("convert_to_die_"..tostring(i).."_img","image",alt.to_dice[i].element)
        UI_setClass("convert_to_die_"..tostring(i).."_img","image_active")
      else
        UI_setClass("convert_to_die_"..tostring(i).."_img","image_inactive")
      end
    end
    UI_setAttribute("convert_cycle_to_die_txt","active",(#alt.to > 1))
    UI_setAttribute("alteration_convert_dice_row","active",true)
    UI_setAttribute("alteration_done_pnl","active", #alt.to_dice > 0 )
    UI_setAttribute("alteration_cancel_pnl","active",true)
    UI_setAttribute("alteration_next_pnl","active",false)
  elseif alt.state == "reroll" or alt.state == "flip" then
    if alt.state == "reroll" then
      UI_setAttribute("convert_to_dice_title_txt","text","Dice to Re-Roll:")
    else
      UI_setAttribute("convert_to_dice_title_txt","text","Dice to Flip:")
    end
    UI_setAttribute("alteration_select_action_row","active",false)
    for i=1,7 do
      if alt.from_dice[i] and not(alt.from_dice[i].assigned) then
        UI_setAttribute("convert_from_die_"..tostring(i).."_img","image",alt.from_dice[i].element)
        UI_setClass("convert_from_die_"..tostring(i).."_img","image_active")
      else
        UI_setClass("convert_from_die_"..tostring(i).."_img","image_inactive")
      end
      if alt.to_dice[i] then
        UI_setAttribute("convert_to_die_"..tostring(i).."_img","image",alt.to_dice[i].element)
        UI_setClass("convert_to_die_"..tostring(i).."_img","image_active")
      else
        UI_setClass("convert_to_die_"..tostring(i).."_img","image_inactive")
      end
    end
    UI_setAttribute("convert_cycle_to_die_txt","active",false)
    UI_setAttribute("alteration_convert_dice_row","active",true)
    UI_setAttribute("alteration_done_pnl","active", #alt.to_dice > 0 )
    UI_setAttribute("alteration_cancel_pnl","active",true)
    UI_setAttribute("alteration_next_pnl","active",false)
  else
    log("ERROR: updateAlterationDlg() unknown alteration dialog state")
  end
end

--[[ Alteration card play dialog handler.
    This thing is a beast.  See Cards.ttslua for some help.
    Also see showAlterationDlg() for data structure reference.
--]]
function alterationDlgHandler(player, button, id)
  if env.test.trace then log("Global: alterationDlgHandler() "..player.color..", "..tostring(id)..", "..tostring(button)) end
  if player.color ~= GD.game.player_order[GD.game.current_player] then return end
  local action = Split(id,"_")[2]
  local pdata = GD.game.players[player.color]
  local alt = pdata.alteration_action
  local card = alterations[alt.card_id]
  assert(card, "ERROR: alterationsDlgHandler() cannot locate card data for id "..tostring(alt.card_id))
  local close_dialog = true

  --//////////////////////////////////////////////////////////////////////
  local function execute_action(a)
    if env.test.trace then log("execute_action(): "..a.action..", "..tostring(a.desc)) end
    if env.test.debug then log(a) end
    if a.pre then
      if a.pre.type == "pay_acuity" then alt.acuity_paid = a.pre.amount
      end
    end
    if a.action == "convert" then
      alt.min = 1 --always
      if a.max ~= nil then alt.max = a.max else alt.max = 1 end
      alt.to = simpleDeepCopy(a.to)
      if contains(a.from, "any") then
        alt.from = {}
        for i,d in ipairs(pdata.dice) do
          if not(d.allocated) then
            if #alt.to > 1 or not(contains(alt.to, d.element)) then table.insert(alt.from, d.element) end
          end
        end
      else
        alt.from = simpleDeepCopy(a.from)
      end
      local any = contains(alt.to, "any_owned")
      if any then alt.to = {} end
      if contains(alt.to, "aetherflow") then alt.to = simpleDeepCopy(pdata.aetherflow) end
      for i,d in ipairs(pdata.dice) do
        local e = C.die_elements[d.value]
        if any and not(contains(alt.to,e)) and not(contains(alt.from,e)) then table.insert(alt.to,e) end
        if not(d.allocated) and contains(alt.from, e) then
          table.insert(alt.from_dice,{index=i,element=e,value=d.value,assigned=false})
        end
      end
      alt.state = "convert"
      --check for special modification conditions
      if a.n_acuity_mod then
        -- special case: pay n+1 acuity before convert n dice
        alt.state = "pay_acuity"
        alt.acuity_min = 2  --pay at least 2 to convert 1 die (the minimum)
        alt.acuity_max = #alt.from_dice + 1 --can't pay more than available dice to convert (+1)
      elseif a.reverse_mod then  --TODO: TEST THIS handle reverse_mod
        local n = pdata.sigils[a.reverse_mod.sigil]
        n = n + pdata.sigils["wild"]
        if n >= a.reverse_mod.amount then
          for _,e in ipairs(a.from) do table.insert(alt.to, e) end
          for _,e in ipairs(a.to) do table.insert(alt.from, e) end
        end
      elseif a.convert_mod then
        local n = pdata.sigils[a.convert_mod.sigil]
        n = n + pdata.sigils["wild"]
        alt.max = alt.max + n * a.convert_mod.mod
      elseif a.count_mod then
        local n = 0
        for _,d in ipairs(pdata.dice) do
          if d.element == a.count_mod.value then n = n + 1 end
        end
        alt.max = n
      end
      close_dialog = false
    elseif a.action == "flip" then
      alt.from = {}
      for i,d in ipairs(pdata.dice) do
        if not(d.allocated) then
          table.insert(alt.from_dice, {index=i,element=d.element,value=d.value,assigned=false})
        end
      end
      alt.to = {}  --doesn't matter
      alt.min = 1
      alt.max = a.max
      alt.state = "flip"
      close_dialog = false
    elseif a.action == "reroll" then
      alt.from = {}
      for i,d in ipairs(pdata.dice) do
        if not(d.allocated) then
          table.insert(alt.from_dice, {index=i,element=d.element,value=d.value,assigned=false})
        end
      end
      alt.to = {}  --doesn't matter
      alt.min = 1
      alt.max = a.max
      if alt.secondary and pdata.class == "Chaosmancer" then alt.max = 4 end
      alt.state = "reroll"
      close_dialog = false
    elseif a.action == "gain_spell_card" then
      table.insert(alt.take_gained,"spell")
    elseif a.action == "gain_spell_acuity" then
      alt.acuity_gained = alt.acuity_gained + #pdata.active_spell_cards
    elseif a.action == "gain_n_acuity" then
      alt.acuity_gained = alt.acuity_gained + a.amount
    elseif a.action == "null" then
      if env.test.debug then log("execute_action(): FYI: null action") end
    else
      log("ERROR: execute_action() unknown action type")
      return
    end
    if a.post then
      if env.test.debug then log("executing post action"); log(a.post) end
      if a.post.type == "gain_acuity" then
        alt.acuity_gained = alt.acuity_gained + a.post.amount
        if a.post.sigil then
          local mod = a.post.mod * pdata.sigils[a.post.sigil]
          mod = mod + pdata.sigils["wild"]
          if env.test.debug then log("modding post action acuity gained + "..tostring(mod)) end
          alt.acuity_gained = alt.acuity_gained + mod
        end
      elseif a.post.type == "gain_play" then alt.play_gained = alt.play_gained + a.post.amount
      elseif a.post.type == "opp_acuity" then alt.opp_acuity_gained = alt.opp_acuity_gained + a.post.amount
      end
    end
  end
  --//////////////////////////////////////////////////////////////////////

  if action == "primary" then
    if env.test.debug then log("executing primary action(s) for card "..tostring(card.id)) end
    if card.primary.requirements then
      local satisfied = true
      for i,r in ipairs(card.primary.requirements) do
        if env.test.debug then log("checking primary action requirement "..tostring(i)); log(r) end
        if r.type == "Dice" then
          local count = 0
          for _,d in ipairs(pdata.dice) do
            if not(d.allocated) then
              if contains(r.value, "any") then count = count + 1
              elseif contains(r.value, C.die_elements[d.value]) then count = count + 1 end
            end
          end
          satisfied = satisfied and count >= r.amount
        elseif r.type == "Owned" then
          local found = false
          for _,d in ipairs(pdata.dice) do
            if contains(r.value, C.die_elements[d.value]) then found = true; break end
          end
          satisfied = satisfied and found
        elseif r.type == "Acuity" then
          satisfied = satisfied and pdata.acuity >= r.amount
        elseif r.type == "Spell" then
          satisfied = satisfied and #pdata.active_spell_cards >= r.amount
        else
          log("ERROR: alterationDlgHandler() unknown requirement type "..tostring(r.type))
          return
        end
      end
      if not(satisfied) then
        broadcastToColor("Requirements for primary action not met.", player.color)
        return
      end
    end
    if #card.primary.actions == 1 then
      execute_action(card.primary.actions[1])
    elseif #card.primary.actions == 2 then
      if id == "alteration_primary_action_btn" then
        execute_action(card.primary.actions[1])
      elseif id == "alteration_primary_or_action_btn" then
        execute_action(card.primary.actions[2])
      else
        log("ERROR: alterationDlgHandler() unknown primary action id")
        return
      end
    else
      log("ERROR: alterationDlgHandler() unnexpected number of primary actions for card "..tostring(card.id))
      return
    end
  elseif action == "secondary" then
    if env.test.debug then log("executing secondary action for card "..tostring(card.id)) end
    --all cards should have a secondary
    assert(card.secondary, "alterationDlgHandler(): missing secondary action for card "..tostring(card.id))
    if card.secondary.to and contains(card.secondary.to, "aetherflow") then
      if not(pdata.aetherflow) then
        broadcastToColor("You have no Aetherflow power", player.color)
        return
      end
      --check dice for aetherflow
      local satisfied = false
      for _,d in ipairs(pdata.dice) do
        if d.element == "Aether" and not(d.assigned) then  --TODO: aether/void can never be assigned???
          satisfied = true
          break
        end
      end
      if not(satisfied) then
        if env.test.debug then log("alterationDlgHandler() player does not have Aether die for Aetherflow power.") end
        if GD.env.verbose then broadcastToColor("Requirements for secondary action not met.", player.color) end
        return
      end
    end
    alt.secondary = true --needed for Chaosmancer special case on secondary rerolls
    execute_action(card.secondary)
  elseif action == "discard" then
    if env.test.debug then log("executing discard action for card "..tostring(card.id)) end
    if pdata.acuity == 0 then
      broadcastToColor("Requirements for discard action not met.", player.color)
      return
    end
    table.insert(alt.take_gained, "any")
    alt.acuity_paid = alt.acuity_paid + 1
  elseif action == "next" then
    alt.max = alt.acuity_paid - 1
    alt.state = "convert"
    close_dialog = false
  elseif action == "inc" then
    if alt.acuity_available > 0 and alt.acuity_paid < alt.acuity_max then
      alt.acuity_paid = alt.acuity_paid + 1
      alt.acuity_available = alt.acuity_available - 1
    end
    close_dialog = false
  elseif action == "dec" then
    if alt.acuity_paid > 0 then
      alt.acuity_paid = alt.acuity_paid - 1
      alt.acuity_available = alt.acuity_available + 1
    end
    close_dialog = false
  elseif action == "done" then
    -- handle re-roll randomization before dialog closing processing
    if alt.state == "reroll" then
      for i,d in ipairs(alt.to_dice) do
        d.value = math.random(1,6)
        d.element = C.die_elements[d.value]
      end
    end
  elseif action == "cancel" then
    local c = getObjectFromGUID(card.guid)
    assert(c, "ERROR: alterationDlgHandler(): unable to locate card object "..tostring(card.guid))
    c.setLock(false)
    c.deal(1,player.color)
    pdata.alteration_action = nil
    UI_setAttribute("alteration_card_pnl","visibility","Pink")
    updateHUD(player.color)
    return
  elseif action == "from" then
    local index = tonumber(Split(id,"_")[4])
    if #alt.to_dice < alt.max then
      local d = {
        from_index = index,
        element = alt.to[1],
      }
      if alt.state == "reroll" then
        d.element = alt.from_dice[index].element
      elseif alt.state == "flip" then
        local v = C.die_flip[alt.from_dice[index].value]
        d.element = C.die_elements[v]
      end
      table.insert(alt.to_dice,d)
      alt.from_dice[index].assigned = true
    end
    close_dialog = false
  elseif action == "to" then
    local index = tonumber(Split(id,"_")[4])
    if button == "-1" then
      if #alt.to > 1 and alt.state == "convert" then
        local d = alt.to_dice[index]
        local n = indexOf(alt.to, d.element)
        if n == #alt.to then n = 1 else n = n + 1 end
        d.element = alt.to[n]
      end
    elseif button == "-2" then
      local d = alt.to_dice[index]
      alt.from_dice[d.from_index].assigned = false
      table.remove(alt.to_dice,index)
    end
    close_dialog = false
  else
    log("ERROR: alterationDlgHandler() unknown action: "..tostring(action))
    return
  end
  if close_dialog then
    if env.test.debug then log("closing stuff when exiting the dialog"); log(alt) end
    for _,d in ipairs(alt.to_dice) do
      local index = alt.from_dice[d.from_index].index
      pdata.dice[index].element = d.element
      pdata.dice[index].value = indexOf(C.die_elements, d.element)
    end
    for _,t in ipairs(alt.take_gained) do table.insert(pdata.actions.take,t) end
    pdata.acuity = pdata.acuity - alt.acuity_paid
    if GD.env.verbose then print(pdata.player_color.." pays "..tostring(alt.acuity_paid).." Acuity") end
    pdata.acuity = pdata.acuity + alt.acuity_gained
    if GD.env.verbose then print(pdata.player_color.." gains "..tostring(alt.acuity_gained).." Acuity") end
    if pdata.acuity > 10 then
      if GD.env.verbose then print(pdata.player_color.." discards "..tostring(pdata.acuity-10).." Acuity") end
      pdata.acuity = 10
    end
    pdata.actions.play = pdata.actions.play + alt.play_gained
    if alt.opp_acuity_gained > 0 then
      for pcol,p in pairs(GD.game.players) do
        if pcol ~= player.color then
          p.acuity = p.acuity + alt.opp_acuity_gained
          if GD.env.verbose then print(pcol.." gains "..tostring(alt.opp_acuity_gained).." Acuity") end
          if p.acuity > 10 then
            if GD.env.verbose then print(pcol.." discards "..tostring(p.acuity-10).." Acuity") end
            p.acuity = 10
          end
        end
      end
    end
    pdata.cast_allowed = false
    pdata.actions.play = pdata.actions.play - 1
    local card = getObjectFromGUID(card.guid)
    assert(card, "alterationDlgHandler(): could not instantiate card object")
    local memo = JSON.decode(card.memo)
    if env.test.debug then
      log("alterationDlgHandler():"); log(memo)
      assert(memo.player == player.color, "alterationDlgHandler(): player does not own card")
    end
    memo.used = true
    card.memo = JSON.encode(memo)
    local board = getObjectFromGUID(pdata.player_board)
    board.call("placeUsedAlterationCard",{guid=card.guid})
    UI_setAttribute("alteration_card_pnl","visibility","Pink")
    pdata.alteration_action = nil
    updateHUD()
  else
    updateAlterationDlg()
  end
end

--[[ Set alteration card take button states as specified.  Defaults to true.
    'state' defaults to true.  If false all buttons are disabled.
    If current player has no takes all buttons are disabled.
  --]]
function updateAlterationButtons(state)
  if env.test.trace then log("Global:updateAlterationButtons()") end
  local state = state and true
  local pcol = GD.game.player_order[GD.game.current_player]
  state = state and indexOf(GD.game.players[pcol].actions.take,"any") > 0
  for i=1,6 do
    local s = state and true
    if GD.game.alterations[i].card_id == 0 then state = false end
    object_UI_setAttribute(g_lower, "alterations_button_"..tostring(i).."_pnl", "active", s)
  end
end

--////////// Mystrune dialog ////////////

function mystruneActivate(params)
  assert(params,"Global:mystruneActivate(): missing params")
  if env.test.trace then log("Global: mystruneActivate() "..tostring(params.player_color)..", "..tostring(tostring(params.action))) end
  if env.test.debug then log(params) end
  local pcol = params.player_color
  if pcol ~= GD.game.player_order[GD.game.current_player] then return end
  local pdata = GD.game.players[pcol]
  if pdata.mystrune == nil then return end  --doesn't own it
  --setup dlg data and show dialog
  local to = {}
  local action = params.action
  if action == "Fire_Lightning" then
    to = {"Fire","Lightning",}
  elseif action == "Water_Earth" then
    to = {"Water","Earth",}
  else
    log("ERROR: mystruneActivate(): unknown action")
    return
  end
  -- GD.game.mystrune_action = {
  pdata.mystrune_action = {
    player_color = pcol,
    from_dice = {},
    to = to,
    to_dice = nil,
  }
  for i,d in ipairs(pdata.dice) do
    if not(d.allocated) then
      table.insert(pdata.mystrune_action.from_dice, {
        p_index=i,
        value=d.value,
        element=d.element,
        assigned=false,
      })
    end
  end
  for i=1,7 do
    if i > #pdata.mystrune_action.from_dice then
      UI_setClass("mystrune_from_die_"..tostring(i).."_img","image_inactive")
    else
      UI_setClass("mystrune_from_die_"..tostring(i).."_img","image_active")
    end
  end
  updateMystruneActivateDlg()
  UI_setAttribute("activate_mystrune_pnl","visibility",pcol)
  updateHUD(pcol)
end

--[[ Update the mystrune dialog from the dlg data structure. ]]
function updateMystruneActivateDlg()
  if env.test.trace then log("updateMystruneActivateDlg()") end
  local pcol = GD.game.player_order[GD.game.current_player]
  local pdata = GD.game.players[pcol]
  local data = pdata.mystrune_action
  for i,d in ipairs(data.from_dice) do
    if d.assigned then
      UI_setClass("mystrune_from_die_"..tostring(i).."_img","image_inactive")
    else
      UI_setAttribute("mystrune_from_die_"..tostring(i).."_img","image",d.element)
      UI_setClass("mystrune_from_die_"..tostring(i).."_img","image_active")
    end
  end
  if data.to_dice ~= nil then
    UI_setAttribute("mystrune_to_die_img","image",data.to_dice.element)
    UI_setClass("mystrune_to_die_img","image_active")
  else
    UI_setClass("mystrune_to_die_img","image_inactive")
  end
  UI_setAttribute("mystrune_done_pnl","active",data.to_dice ~= nil)
end

--[[ Handler for the mystrune activate dialog. ]]
function mystruneActivateDlg(player, button, id)
  if env.test.trace then log("Global:mystruneActivateDlg() "..player.color..", "..tostring(id)..", "..tostring(button)) end
  if not(GD.game.started) then return end --TODO: remove after development
  if player.color ~= GD.game.player_order[GD.game.current_player] then return end
  local pdata = GD.game.players[player.color]
  local data = pdata.mystrune_action
  local action = Split(id,"_")[2]
  if action == "cancel" then
    pdata.mystrune_action = nil
    UI_setAttribute("activate_mystrune_pnl","visibility","Pink")
    updateHUD()
    return
  elseif action == "done" then
    if data.to_dice == nil then
      log("WARN: Global:mystruneActivateDlg() to_dice is nil")  --DEBUG: shouldn't happen
      return
    end
    -- local pdata = GD.game.players[player.color]
    local index = data.to_dice.p_index
    pdata.dice[index].value = data.to_dice.value
    pdata.dice[index].element = data.to_dice.element
    pdata.mystrune_action = nil
    UI_setAttribute("activate_mystrune_pnl","visibility","Pink")
    returnMystRune(player.color)
    updateHUD()
    return
  elseif action == "from" then
    if data.to_dice ~= nil then return end
    local index = tonumber(Split(id,"_")[4])
    data.to_dice = {
      index = index,
      p_index = data.from_dice[index].p_index,
      element = data.to[1],
      value = indexOf(C.die_elements, data.to[1]),
    }
    data.from_dice[index].assigned = true
  elseif action == "to" then
    if data.to_dice == nil then
      log("WARN: Global:mystruneActivateDlg() to_dice is nil")  --DEBUG: shouldn't happen
      return
    end
    --only two elements in 'to', so just toggle
    if button == "-1" then
      if data.to_dice.element == data.to[1] then
        data.to_dice.element = data.to[2]
        data.to_dice.value = indexOf(C.die_elements, data.to[2])
      else
        data.to_dice.element = data.to[1]
        data.to_dice.value = indexOf(C.die_elements, data.to[1])
      end
    else
      data.from_dice[data.to_dice.index].assigned = false
      data.to_dice = nil
    end
  else
    assert(false, "Global:mystruneActivateDlg(): unexpected action id")
  end
  updateMystruneActivateDlg()
end

--////////// Take Spell dialog ////////////

--[[ Handler for the take Spell button. ]]
function takeSpellBtn(player, button, id)
  if env.test.trace then log("Global: takeSpellBtn() "..tostring(player.color)..", "..tostring(id)) end
  if player.color ~= GD.game.player_order[GD.game.current_player] then return end
  local card_index = tonumber(Split(id,"_")[3])
  showPaySpellDlg(card_index, player.color)
end

--[[ setup persistent data for dialog and show it. --]]
function showPaySpellDlg(card_index, pcol)
  if env.test.trace then log("Global: showPaySpellDlg() "..tostring(pcol)..", "..tostring(card_index)) end
  local card = getObjectFromGUID(GD.game.spells[card_index].card_guid)
  assert(card,"showPaySpellDlg(): missing spell card object")
  local spell = spells[tonumber(card.getGMNotes())]
  assert(spell,"showPaySpellDlg() missing spell card data")
  local pdata = GD.game.players[pcol]
  local pos = card.getPosition()
  pos.y = pos.y + 2
  card.setPosition(pos)
  card.setLock(true)
  pdata.spell_cost = {
    card_index = card_index,
    player_color = pcol,
    element = "",
    available_dice = {},
    assigned_dice = {},
    available_mana = pdata.mana,
    assigned_mana = 0,
    available_acuity = pdata.acuity,
    assigned_acuity = 0,
    flex_spots = spell.flex,
    fixed_spots = spell.slots - spell.flex,
    slots = {},
    filled = 0,
    mana_discount = 0,
    acuity_discount = 0,
    excess_mana = 0,
    excess_acuity = 0,
  }
  local dlg = pdata.spell_cost
  if pdata.acuity_discount then dlg.acuity_discount = dlg.acuity_discount + pdata.acuity_discount end
  if card_index == 1 then dlg.mana_discount = dlg.mana_discount + 1 end
  if card_index == 2 then dlg.acuity_discount = dlg.acuity_discount + 1 end
  --availble dice
  for i,die in ipairs(pdata.dice) do
    if not(die.allocated) then
      local e = C.die_elements[die.value]
      if contains(spell.dice, e) then
        table.insert(dlg.available_dice, {
          index=i,
          element=e,
        })
      end
    end
  end
  for i=1,dlg.flex_spots do
    table.insert(dlg.slots, {
      filled = false,
      die = 0,
      flex = true,
      mana = 0,
      acuity = 0,
    })
  end
  for i=1,dlg.fixed_spots do
    table.insert(dlg.slots, {
      filled = false,
      die = 0,
      flex = false,
    })
  end
  --TODO: pre-populate selections with matching fixed die if possible?
  for i=1,5 do
    UI_setClass("spell_assigned_die_"..tostring(i).."_img","image_inactive")
  end
  updateSpellCostDlg()
  local id = card.getGMNotes()
  if id == "4" then id = "3" end --HACK: BUG: Spell-4 image won't load, WORKAROUND: Spell-3 is the same image
  local card_image = "Spell-"..card.getGMNotes()
  if env.test.debug then
    log("---- Clearing card image")
    UI_setAttribute("spell_cost_card_img","image","")  --HACK: trying to force image load
    Wait.frames(function()
      log("---- Setting card image: "..card_image)
      UI_setAttribute("spell_cost_card_img","image",card_image)
    end,1)
  else
    UI_setAttribute("spell_cost_card_img","image",card_image)
  end
  UI_setAttribute("spell_card_pnl","visibility",pcol)
  updateHUD(pcol)
end

--[[ Update the spell cost dialog with latest data.  ]]
function updateSpellCostDlg()
  if env.test.trace then log("Global: updateSpellCostDlg") end
  local pcol = GD.game.player_order[GD.game.current_player]
  local dlg = GD.game.players[pcol].spell_cost
  --availble resources
  UI_setAttribute("spell_cost_mana_txt","text",tostring(dlg.available_mana))
  UI_setAttribute("spell_cost_acuity_txt","text",tostring(dlg.available_acuity))
  for i,die in ipairs(dlg.available_dice) do
    UI_setAttribute("spell_cost_die_"..tostring(i).."_img","image",die.element)
    UI_setClass("spell_cost_die_"..tostring(i).."_img","image_active")
  end
  for i=(#dlg.available_dice+1),7 do
    UI_setClass("spell_cost_die_"..tostring(i).."_img","image_inactive")
  end
  --selected resources
  UI_setAttribute("spell_assigned_mana_txt","text",tostring(dlg.assigned_mana))
  UI_setAttribute("spell_assigned_acuity_txt","text",tostring(dlg.assigned_acuity))
  for i,slot in ipairs(dlg.slots) do
    if slot.filled then
      if slot.die > 0 then
        UI_setAttribute("spell_assigned_die_"..tostring(i).."_img","image",dlg.element)
        UI_setClass("spell_assigned_die_"..tostring(i).."_img","image_active")
      else
        UI_setAttribute("spell_assigned_die_"..tostring(i).."_img","image","Filled-flex")
        UI_setClass("spell_assigned_die_"..tostring(i).."_img","image_active")
      end
    else
      if slot.flex then
        UI_setAttribute("spell_assigned_die_"..tostring(i).."_img","image","Empty-flex")
        UI_setClass("spell_assigned_die_"..tostring(i).."_img","image_active")
      else
        UI_setAttribute("spell_assigned_die_"..tostring(i).."_img","image","Empty-fixed")
        UI_setClass("spell_assigned_die_"..tostring(i).."_img","image_active")
      end
    end
  end
  UI_setAttribute("spell_cost_mana_disc_txt","text",tostring(dlg.mana_discount))
  UI_setAttribute("spell_cost_acuity_disc_txt","text",tostring(dlg.acuity_discount))
  if dlg.excess_mana > 0 or dlg.excess_acuity > 0 then
    UI_setAttribute("spell_cost_excess_tbl","active",true)
    UI_setAttribute("spell_cost_mana_excess_txt","text",tostring(dlg.excess_mana))
    UI_setAttribute("spell_cost_acuity_excess_txt","text",tostring(dlg.excess_acuity))
  else
    UI_setAttribute("spell_cost_excess_tbl","active",false)
  end
  UI_setAttribute("spell_cost_assign_pnl","active",dlg.filled == dlg.flex_spots + dlg.fixed_spots)
end

--[[ Handler for pay spell cost dialog --]]
function spellCostHandler(player, button, id)
  if env.test.trace then log("Global: spellCostHandler() "..tostring(player.color)..", "..tostring(id)) end
  if player.color ~= GD.game.player_order[GD.game.current_player] then return end
  local dlg = GD.game.players[player.color].spell_cost
  --////////////////////////////
  local function updateSlots()
    --initialize the table of slots
    dlg.filled = 0
    for i=1,#dlg.slots do
      dlg.slots[i].filled = false
      dlg.slots[i].die = 0
      if dlg.slots[i].flex then
        dlg.slots[i].mana = 0
        dlg.slots[i].acuity = 0
      end
    end
    --fill with fixed die first from back to front
    for i,die in ipairs(dlg.assigned_dice) do
      local s = dlg.slots[#dlg.slots - (i-1)] --reverse order
      s.filled = true
      s.die = die.index
      dlg.filled = dlg.filled + 1
    end
    -- calculate # slots to fill with mana/acuity
    local _mana = dlg.assigned_mana + dlg.mana_discount
    local _acuity = dlg.assigned_acuity + dlg.acuity_discount
    local _eff = _mana + math.floor(_acuity / 2)
    -- fill unfilled slots front to back now with mana / acuity
    local mana_used = 0
    local acuity_used = 0
    for i,slot in ipairs(dlg.slots) do
      if not(slot.filled) and slot.flex then
        if _mana - mana_used >= 2 then --fill with 2 mana
          slot.mana = 2
          slot.filled = true
        elseif _mana - mana_used == 1 then
          slot.mana = 1
          if _acuity - acuity_used >= 2 then  -- fill with 1 mana and 2 acuity
            slot.acuity = 2
            slot.filled = true
          elseif _acuity - acuity_used == 1 then  --not filled
            slot.acuity = 1
            slot.filled = false
          end
        elseif _acuity - acuity_used >= 4 then  -- fill with 4 acuity
          slot.acuity = 4
          slot.filled = true
        elseif _acuity - acuity_used > 0 then  -- not filled
          slot.acuity = _acuity - acuity_used
          slot.filled = false
        end
        if slot.filled then dlg.filled = dlg.filled + 1 end
        mana_used = mana_used + slot.mana
        acuity_used = acuity_used + slot.acuity
      else
        if env.test.debug then
          if slot.filled then log("   --- slot filled")
          elseif not(slot.flex) then log("   --- not flex") end
        end
      end
    end
    local actual_used = mana_used - dlg.mana_discount
    if actual_used < 0 then actual_used = 0 end
    dlg.excess_mana = dlg.assigned_mana - actual_used
    actual_used = acuity_used - dlg.acuity_discount
    if actual_used < 0 then actual_used = 0 end
    dlg.excess_acuity = dlg.assigned_acuity - actual_used
  end
  --////////////////////////////
  local action = Split(id,"_")[3]
  if action == "cancel" then
    UI_setAttribute("spell_card_pnl","visibility","Pink")
    GD.game.players[player.color].spell_cost = nil
    local card = getObjectFromGUID(GD.game.spells[dlg.card_index].card_guid)
    assert(card,"spellCostHandler(): missing spell card object")
    card.setLock(false)
    Wait.frames(function()
      Wait.condition(function() card.setLock(true) end, function() return card.resting end)
    end,1)
    updateHUD(player.color)
  elseif action == "assign" then
    --count up only assigned acuity and/or mana to pay, accounting for discounts
    local mana = 0
    local acuity = 0
    for _,slot in ipairs(dlg.slots) do
      if slot.flex and slot.die == 0 then
        mana = mana + slot.mana
        acuity = acuity + slot.acuity
      end
    end
    if mana > 0 then mana = mana - dlg.mana_discount end
    if acuity > 0 then acuity = acuity - dlg.acuity_discount end
    if env.test.debug then
      log("Player payes "..tostring(mana).." Mana")
      log("Player payes "..tostring(acuity).." Acuity")
      for _,die in ipairs(dlg.assigned_dice) do
        log("Player pays die at index: "..tostring(die.index)..", "..die.element)
      end
    end
    local pdata = GD.game.players[player.color]
    local board = getObjectFromGUID(pdata.player_board)
    assert(board, "Global:spellCostHandler(): assign: missing board")
    local card = getObjectFromGUID(GD.game.spells[dlg.card_index].card_guid)
    assert(card,"Global:spellCostHandler(): assign: missing spell card object")
    card.setLock(false)
    board.call("placeSpellCard", {guid=card.getGUID()})
    table.insert(pdata.active_spell_cards,
    {
      card_id=GD.game.spells[dlg.card_index].card_id,
      guid=card.getGUID()
    })
    --auto place card (TODO: primitively for now)
    local data = spells[tonumber(card.getGMNotes())]
    local params = {
      guid = card.getGUID(),
      map = pdata.spell_power.card_map,
      card_data = data
    }
    if data.option then setSpellCardDecal(card, player.color) end
    --player data adustments and UI updates
    GD.game.spells[dlg.card_index].card_id = 0
    GD.game.spells[dlg.card_index].card_guid = ""
    pdata.mana = pdata.mana - mana
    pdata.spent_mana = pdata.spent_mana + mana
    pdata.acuity = pdata.acuity - acuity
    for  _,die in ipairs(dlg.assigned_dice) do
      pdata.dice[die.index].allocated = true
    end
    local index = #pdata.actions.take
    for i,take in ipairs(pdata.actions.take) do
      if take == "spell" then index=i; break end --priortize remove spell take
    end
    table.remove(pdata.actions.take, index)
    pdata.cast_allowed = false
    UI_setAttribute("spell_card_pnl","visibility","Pink")
    pdata.spell_cost = nil
    Wait.condition(function()
      --after card rests on class board, auto locate in 1st available spell position
      local map = board.call("locateSpell", params)
      assert(map, "Global:spellCostHandler(): player_board locateSpell() did not return a map")
      GD.game.players[player.color].spell_power.card_map = simpleDeepCopy(map)
      updateSpellPower(player.color)
      updateHUD()
    end, function() return card.resting end)
  elseif action == "mana" then
    local type = Split(id,"_")[2]
    if type == "cost" then
      if dlg.available_mana == 0 then return end --no more mana
      if dlg.filled == #dlg.slots then return end --slots full
      if dlg.filled - #dlg.assigned_dice >= dlg.flex_spots then return end -- no more flex spots
      dlg.assigned_mana = dlg.assigned_mana + 1
      dlg.available_mana = dlg.available_mana - 1
      updateSlots()
    elseif type == "assigned" then
      if dlg.assigned_mana == 0 then return end --no more mana assigned
      dlg.assigned_mana = dlg.assigned_mana - 1
      dlg.available_mana = dlg.available_mana + 1
      updateSlots()
    else
      log("ERROR: spellCostHandler() unknown mana action type")
      return
    end
    updateSpellCostDlg()
  elseif action == "acuity" then
    local type = Split(id,"_")[2]
    if type == "cost" then
      if dlg.available_acuity == 0 then return end --no more mana
      if dlg.filled == #dlg.slots then return end --slots full
      if dlg.filled - #dlg.assigned_dice >= dlg.flex_spots then return end -- no more flex spots
      dlg.assigned_acuity = dlg.assigned_acuity + 1
      dlg.available_acuity = dlg.available_acuity - 1
      updateSlots()
    elseif type == "assigned" then
      if dlg.assigned_acuity == 0 then return end --no more acuity assigned
      dlg.assigned_acuity = dlg.assigned_acuity - 1
      dlg.available_acuity = dlg.available_acuity + 1
      updateSlots()
    else
      log("ERROR: spellCostHandler() unknown acuity action type")
      return
    end
    updateSpellCostDlg()
  elseif action == "die" then
    local type = Split(id,"_")[2]
    if type == "cost" then
      local i = tonumber(Split(id,"_")[4])
      local die = dlg.available_dice[i]
      if dlg.element ~= "" and die.element ~= dlg.element then
        broadcastToColor("Cannot mix element types on a spell card", player.color)
        return
      end
      if dlg.filled == #dlg.slots then return end --slots full
      if dlg.element == "" then dlg.element = die.element end
      table.insert(dlg.assigned_dice, {
        index=die.index,
        element=die.element,
        value=die.value,
      })
      table.remove(dlg.available_dice,i)
      updateSlots()
    elseif type == "assigned" then
      local i = tonumber(Split(id,"_")[4])
      if dlg.slots[i].die == 0 then return end --ignore spot without die
      if dlg.filled == 0 then return end --ignore if empty
      local die = dlg.assigned_dice[#dlg.assigned_dice]
      table.insert(dlg.available_dice, {
        index=die.index,
        element=die.element,
        value=die.value,
      })
      table.remove(dlg.assigned_dice,#dlg.assigned_dice)
      if #dlg.assigned_dice == 0 then dlg.element = "" end
      updateSlots()
    else
      log("ERROR: spellCostHandler() unknown die action type")
      return
    end
    updateSpellCostDlg()
  end
end

--[[ Set spell card take button states as specified
    'state' defaults to true.  If false all buttons are disabled.
    If state is true then check each spell requirement against player resources.
    If current player has no takes all buttons are disabled.
  --]]
function updateSpellButtons(state)
  if env.test.trace then log("Global:updateSpellButtons()") end
  local state = state and true
  local pcol = GD.game.player_order[GD.game.current_player]
  state = state and indexOf(GD.game.players[pcol].actions.take,"any") > 0
  if not(state) then
    state = state and indexOf(GD.game.players[pcol].actions.take,"spell") > 0
  end
  for i=1,6 do
    local s = state and true
    if GD.game.spells[i].card_id > 0 then s = s and checkSpellRequirements(i, pcol)
    else s = false end
    object_UI_setAttribute(g_lower, "spells_button_"..tostring(i).."_pnl", "active", s)
  end
  object_UI_setAttribute(g_lower, "recycle_spell_pnl", "active", state)
end

--[[ Check a spell card at a given location to see if a player can take it. --]]
function checkSpellRequirements(loc, pcol)
  if env.test.trace then log("Global:checkSpellRequirements() "..tostring(loc)..", "..tostring(pcol)) end
  local id = GD.game.spells[loc].card_id
  local mana = GD.game.players[pcol].mana
  if loc == 1 then mana = mana + 1 end  --discount
  local acuity = GD.game.players[pcol].acuity
  if loc == 2 then acuity = acuity + 1 end  --discount
  local flex_die = math.floor(mana / 2) + math.floor(acuity / 4)
  local dice = {}
  for _,d in ipairs(GD.game.players[pcol].dice) do
    if not(d.allocated) then
      local element = C.die_elements[d.value]
      if dice[element] then dice[element] = dice[element] + 1
      else dice[element] = 1 end
    end
  end
  local spell = spells[id]
  local flex = spell.flex
  local physical = spell.slots - flex
  if physical == 0 then
    if flex_die >= spell.slots then
      return true
    end
  end
  for _,element in ipairs(spell.dice) do
    if dice[element] then
      if dice[element] >= spell.slots then
        return true
      elseif dice[element] >= physical then
        if dice[element] + flex_die >= spell.slots then
          return true
        end
      end
    end
  end
  return false
end

--[[ Handler for Recycle Leftmost Spell button. ]]
function recycleSpellBtn(player, button, id)
  if env.test.trace then log("Global: recycleSpellBtn() "..tostring(player.color)) end
  if player.color ~= GD.game.player_order[GD.game.current_player] then return end
  local pdata = GD.game.players[player.color]
  if GD.game.spells[1].card_guid == "" then
    broadcastToColor("No spell card in position 1 to recycle.", player.color)
    return
  end
  local card = getObjectFromGUID(GD.game.spells[1].card_guid)
  assert(card, "recycleSpellBtn() could not locate card object for guid "..tostring(GD.game.spells[1].card_guid))
  card.setLock(false)
  if not(card.is_face_down) then card.flip() end
  local deck = getSpellsDeck()
  if deck then
    if deck.tag == "Deck" then
      deck.setLock(false)
      deck.putObject(card)
      Wait.condition(function()
        deck.setLock(true)
      end, function() return card.isDestroyed() end)
    elseif deck.tag == "Card" then
      local pos = deck.getPosition()
      deck.setPosition(Vector(pos.x, pos.y + 3, pos.z))
      card.setPosition(pos)
      Wait.condition(function()
        local d = getSpellsDeck()
        d.setLock(true)
        GD.game.spells_deck_guid = d.getGUID()
      end, function() return card.isDestroyed() end)
    else
      assert(false, "Global:recycleSpellBtn() unknown spell deck object")
    end
  else
    card.setPosition(C.spells_deck_position)
    GD.game.spells_deck_guid = card.getGUID()
    Wait.condition(function() card.setLock(true) end, function() return card.resting end)
  end
  GD.game.spells[1].card_guid = ""
  GD.game.spells[1].card_id = 0
  -- give player one acuity and use up a take
  pdata.acuity = pdata.acuity + 1
  if GD.env.verbose then print(pdata.player_color.." gains 1 Acuity") end
  if pdata.acuity > 10 then
    if GD.env.verbose then print(pdata.player_color.." discards "..tostring(pdata.acuity-10).." Acuity") end
    pdata.acuity = 10
  end
  local index = indexOf(pdata.actions.take, "any")
  if index > 0 then table.remove(pdata.actions.take, index)
  else log("WARN: takeAlterationBtn(): unable to decrement take actions") end
  pdata.cast_allowed = false
  updateHUD()
end

--////////// Spell Cast stuffs ////////////

--[[ Handler for the Cast spell button. ] ]]
function castSpellBtn(player, button, id)
  if env.test.trace then log("Global: castSpellBtn() "..player.color..", "..tostring(id)) end
  if player.color ~= GD.game.player_order[GD.game.current_player] then return end
  local pdata = GD.game.players[player.color]
  pdata.casting = true
  updateHUD()
  if pdata.mystrune ~= nil then
    UI_setAttribute("cast_mystrune_img","image","MystRune_"..GD.game.mystrune_type)
    UI_setAttribute("cast_mystrune_pnl","visibility",player.color)
  elseif pdata.spell_power.myst > 0 then
    showMystDialog(player.color)
  else
    local restore = pdata.spell_power.net_restore
    local ruin = pdata.spell_power.net_ruin
    updateCast(restore, ruin, player.color)
  end
end

--[[ Process cast data to display result to player.
    Determine if any heroics won and show buttons accordingly or
    show consolation dialog if no heroics won.
    Called either directly from the cast button or after
    selecting a myst converstion if that happens.
--]]
function updateCast(restore, ruin, pcol)
  local no_heroics = true
  for i,h in ipairs(GD.game.heroics) do
    local heroic = heroics[h.card_id]
    if restore >= heroic.cost.Restore or ruin >= heroic.cost.Ruin then
      object_UI_setAttribute(g_upper, "heroics_"..tostring(i).."_pnl","active",true)
      no_heroics = false
    end
  end
  GD.game.players[pcol].arcanas_won = checkArcanas(pcol)
  if no_heroics then
    showCastConsolationDialog(pcol)
    object_UI_setAttribute(g_upper, "heroics_cancel_pnl","active",false)
  else
    object_UI_setAttribute(g_upper, "heroics_cancel_pnl","active",true)
    if GD.env.verbose then
      broadcastToColor("Choose a Heroic to claim.", pcol)
    end
  end
end

--[[ Check current spell to see if any Arcanas won.
    Returns a table of any Arcanas qualified for by spell.
    Returns nil if none.
--]]
function checkArcanas(pcol)
  if env.test.trace then log("Global:checkArcanas() "..tostring(pcol)) end
  local pdata = GD.game.players[pcol]
  local result = {}
  for i,arcana in ipairs(GD.game.arcanas) do
    if not(arcana.taken) then
      local satisfied = true
      if arcana.requirement.elements ~= nil then
        for _,e in ipairs(arcana.requirement.elements) do
          local not_found = true
          for _,c in ipairs(pdata.active_spell_cards) do
            local spell = spells[c.card_id]
            if contains(spell.dice, e) then not_found = false; break end
          end
          if not_found then satisfied = false; break end
        end
      elseif arcana.requirement.cards ~= nil then
        satisfied = #pdata.active_spell_cards >= 4
      elseif arcana.requirement.spell_power ~= nil then
        satisfied = pdata.spell_power.net_restore >= arcana.requirement.spell_power.restore or
          pdata.spell_power.net_ruin >= arcana.requirement.spell_power.ruin
      elseif arcana.requirement.aether_mod ~= nil then
        local n = 0
        for _,s in ipairs(pdata.active_spell_cards) do
          if spells[s.card_id].aether_mod then n = n + 1 end
        end
        satisfied = n >= 3 and hasAether(pcol)
      elseif arcana.requirement.myst ~= nil then
        satisfied = pdata.spell_power.myst >= 12
      end
      if satisfied then table.insert(result,{index=i,arcana=arcana}) end
    end
  end
  if env.test.debug then log(result) end
  if #result > 0 then return result
  else return nil end
end

--[[ Handler for the take Heroic button. ]]
function takeHeroicBtn(player, button, id)
  if env.test.trace then log("Global: takeHeroicBtn() "..tostring(player.color)..", "..tostring(id)) end
  if player.color ~= GD.game.player_order[GD.game.current_player] then return end
  local pdata = GD.game.players[player.color]
  if id == "take_heroic_cancel" then
    --reset player state to cancel cast
    pdata.casting = false
    pdata.arcanas_won = nil
    if pdata.spell_power.mystrune.restore > 0 or pdata.spell_power.mystrune.ruin > 0 then
      --return and reset the mystrune HACK: is there a better way around this?
      local board = getObjectFromGUID(pdata.player_board)
      assert(board, "Global:takeHeroicBtn() could not locate player board")
      board.call("placeMystRune", {guid=GD.game.mystrune})
      pdata.spell_power.mystrune.restore = 0
      pdata.spell_power.mystrune.ruin = 0
      pdata.mystrune = GD.game.mystrune
      local o = getObjectFromGUID(pdata.mystrune)
      o.call("assign",player.color)
    end
    updateHUD()
  else
    local index = tonumber(Split(id,"_")[2])
    local card = getObjectFromGUID(GD.game.heroics[index].card_guid)
    assert(card, "Global:takeHeroicBtn() could not locate card")
    local data = heroics[tonumber(card.getGMNotes())]
    assert(data, "Global:takeHeroicBtn() could not get card data")
    table.insert(pdata.heroics, data)
    local board = getObjectFromGUID(pdata.player_board)
    assert(board, "Global:takeHeroicBtn() could not locate player board")
    board.call("placeHeroicCard",{guid=card.getGUID(),index=#pdata.heroics})
    GD.game.heroics[index].card_id = ""
    GD.game.heroics[index].card_guid = ""
    if GD.env.verbose then print("Heroic bonus: "..pdata.player_color.." gains 1 Mana and 1 Acuity") end
    pdata.mana = pdata.mana + 1
    if pdata.mana > 10 then
      if GD.env.verbose then print(pdata.player_color.." discards "..tostring(pdata.mana-10).." Mana") end
      pdata.mana = 10
    end
    pdata.acuity = pdata.acuity + 1
    if pdata.acuity > 10 then
      if GD.env.verbose then print(pdata.player_color.." discards "..tostring(pdata.acuity-10).." Acuity") end
      pdata.acuity = 10
    end
    for _,sigil in ipairs(data.sigils) do
      pdata.sigils[sigil] = pdata.sigils[sigil] + 1
    end
    --calculate any prestige from excess spell power
    local type = "Restore"
    local power = pdata.spell_power.net_restore
    if pdata.spell_power.net_ruin > 0 then
      power = pdata.spell_power.net_ruin
      type = "Ruin"
    end
    local excess = power - data.cost[type]
    local prestige = 0
    if type == "Restore" then
      prestige = math.floor(excess / 4)
    else
      prestige = math.floor(excess / 3)
    end
    pdata.prestige = pdata.prestige + prestige
    if env.test.debug then log("Prestige from "..tostring(excess).." excess "..type.." = "..tostring(prestige)) end
    if GD.env.verbose and prestige > 0 then
      print(player.color.." recieved "..tostring(prestige).." Prestige from "..tostring(excess).." excess "..type)
    end
    --check arcanas won
    if pdata.arcanas_won ~= nil then
      for _,e in ipairs(pdata.arcanas_won) do
        object_UI_setAttribute(g_upper, "arcana_"..tostring(e.index).."_pnl","active",true)
      end
      if GD.env.verbose then
        broadcastToColor("Choose an Arcana to claim.", player.color)
      end
    else
      castCleanup(player.color)
      updateHUD()
    end
  end
  for i=1,6 do
    object_UI_setAttribute(g_upper, "heroics_"..tostring(i).."_pnl","active",false)
  end
  object_UI_setAttribute(g_upper, "heroics_cancel_pnl","active",false)
end

--[[ Display the cast consolation dialog to a player. ]]
function showCastConsolationDialog(pcol)
  if env.test.trace then log("Global: showCastConsolationDialog() "..tostring(pcol)) end
  local pdata = GD.game.players[pcol].spell_power
  local power = 0
  local type = ""
  local prestige = 0
  if pdata.net_restore > 0 then
    power = pdata.net_restore
    type = "Restore"
    prestige = math.floor(power/4)
  elseif pdata.net_ruin > 0 then
    power = pdata.net_ruin
    type = "Ruin"
    prestige = math.floor(power/3)
  else
    log("WARN: Global: showCastConsolationDialog() no spell power.")
  end
  if type == "" then
    UI_setClass("cast_cons_spell_type_img","image_inactive")
  else
    UI_setClass("cast_cons_spell_type_img","image_active")
    UI_setAttribute("cast_cons_spell_type_img","image",type)
  end
  UI_setAttribute("cast_cons_spell_power_txt","text",tostring(power))
  UI_setAttribute("cast_cons_prestige_txt","text",tostring(prestige))
  UI_setAttribute("cast_cons_pnl","visibility",pcol)
end

--[[ Handler for the cast consolation dialog. ]]
function castConsolationHandler(player, button, id)
  if env.test.trace then log("Global: castConsolationHandler() "..tostring(player.color)..", "..tostring(id)) end
  if player.color ~= GD.game.player_order[GD.game.current_player] then return end
  local pdata = GD.game.players[player.color]
  if id == "cast_cons_continue" then
    --handle cast for prestige points
    local prestige = 0
    if pdata.spell_power.net_restore > 0 then
      prestige = math.floor(pdata.spell_power.net_restore/4)
    elseif pdata.spell_power.net_ruin > 0 then
      prestige = math.floor(pdata.spell_power.net_ruin/3)
    else
      log("WARN: Global: castConsolationHandler() no spell power.")
    end
    pdata.prestige = pdata.prestige + prestige
    if pdata.arcanas_won ~= nil then
      --it could happen!
      for _,e in ipairs(pdata.arcanas_won) do
        object_UI_setAttribute(g_upper, "arcana_"..tostring(e.index).."_pnl","active",true)
      end
      if GD.env.verbose then
        broadcastToColor("Choose an Arcana to claim.", player.color)
      end
    else
      castCleanup(player.color)
    end
  elseif id == "cast_cons_cancel" then
    --reset player state to cancel cast
    pdata.casting = false
    pdata.arcanas_won = nil
    if pdata.spell_power.mystrune.restore > 0 or pdata.spell_power.mystrune.ruin > 0 then
      --return and reset the mystrune HACK: is there a better way around this?
      local board = getObjectFromGUID(pdata.player_board)
      assert(board, "Global:takeHeroicBtn() could not locate player board")
      board.call("placeMystRune", {guid=GD.game.mystrune})
      pdata.spell_power.mystrune.restore = 0
      pdata.spell_power.mystrune.ruin = 0
      pdata.mystrune = GD.game.mystrune
      local o = getObjectFromGUID(pdata.mystrune)
      o.call("assign",player.color)
    end
    updateHUD()
  else
    assert(false, "Global:castConsolationHandler() invalid action id")
  end
  UI_setAttribute("cast_cons_pnl","visibility","Pink")
end

--[[ Display the myst spell power selection dialog to a player. ]]
function showMystDialog(pcol)
  if env.test.trace then log("Global:showMystDialog() "..tostring(pcol)) end
  local pdata = GD.game.players[pcol]
  UI_setAttribute("cast_myst_spell_power_txt","text",tostring(pdata.spell_power.myst))
  UI_setAttribute("cast_myst_pnl","visibility",pcol)
end

--[[ Handler for the Myst select spell type dialog.]]
function castMystHandler(player, button, id)
  if env.test.trace then log("Global:castMystHandler() "..tostring(player.color)..", "..tostring(id)) end
  if player.color ~= GD.game.player_order[GD.game.current_player] then return end
  local pdata = GD.game.players[player.color]
  local restore = pdata.spell_power.net_restore
  local ruin = pdata.spell_power.net_ruin
  local myst = pdata.spell_power.myst
  local type
  if id == "cast_myst_restore" then
    type = "restore"
  elseif id == "cast_myst_ruin" then
    type = "ruin"
  else
    assert(false, "Global:castMystHandler() invalid action id")
  end
  if myst >=6 and myst <=7 then
    if type == "restore" then restore = 15
    else ruin = 11 end
  elseif myst >=8 and myst <=9 then
    if type == "restore" then restore = 21
    else ruin = 16 end
  elseif myst >=10 and myst <=11 then
    if type == "restore" then restore = 28
    else ruin = 20 end
  elseif myst >= 12 then
    if type == "restore" then restore = 34
    else ruin = 24 end
  end
  if type == "restore" then
    pdata.spell_power.net_restore = restore
  else
    pdata.spell_power.net_ruin = ruin
  end
  updateCast(restore, ruin, player.color)
  UI_setAttribute("cast_myst_pnl","visibility","Pink")
end

--[[ Handler for the Myst Rune choice dialog.]]
function castMystruneHandler(player, button, id)
  if env.test.trace then log("Global:castMystruneHandler() "..tostring(player.color)..", "..tostring(id)) end
  if player.color ~= GD.game.player_order[GD.game.current_player] then return end
  local pdata = GD.game.players[player.color]
  local action = Split(id,"_")[3]
  if action == "no" then
    --TODO: anything?
  elseif action == "yes" then
    if GD.game.mystrune_type == "Restore" then
      pdata.spell_power.mystrune = {restore=3,ruin=0}
    else
      pdata.spell_power.mystrune = {restore=0,ruin=2}
    end
    updateSpellPower(player.color)
    returnMystRune(player.color)
  else
    assert(false, "Global:castMystruneHandler() unknown action id")
  end
  UI_setAttribute("cast_mystrune_pnl","visibility","Pink")
  updateHUD()
  --check to see if myst generated after mystrune mod
  local restore = pdata.spell_power.gross_restore
  local ruin = pdata.spell_power.gross_ruin
  if env.test.debug then
    log("gross restore: "..tostring(restore))
    log("gross ruin: "..tostring(ruin))
  end
  if pdata.spell_power.myst > 0 then
    showMystDialog(player.color)
  else
    updateCast(restore, ruin, player.color)
  end
end

--[[ Handler for the take Arcana buttons. ]]
function takeArcanaBtn(player, button, id)
  if env.test.trace then log("Global:takeArcanaBtn() "..tostring(player.color)..", "..tostring(id)) end
  if player.color ~= GD.game.player_order[GD.game.current_player] then return end
  local pdata = GD.game.players[player.color]
  local index = tonumber(Split(id,"_")[2])
  local arcana = GD.game.arcanas[index]
  arcana.taken = true
  table.insert(pdata.arcanas, arcana)
  local board = getObjectFromGUID(pdata.player_board)
  assert(board, "Global:takeArcanaBtn() could not locate player board")
  board.call("placeArcana",{guid=arcana.guid})
  castCleanup(player.color)
  updateHUD()
  for i=1,3 do
    object_UI_setAttribute(g_upper, "arcana_"..tostring(i).."_pnl","active",false)
  end
end

--[[ Perform post spell cast cleanup for a player. ]]
function castCleanup(pcol)
  if env.test.trace then log("Global:castCleanup() "..tostring(pcol)) end
  local pdata = GD.game.players[pcol]
  local board = getObjectFromGUID(pdata.player_board)
  for _,s in ipairs(pdata.spell_power.card_map.base_spells) do
    if s.guid ~= "" then
      board.call("placeCastSpell",{guid=s.guid})
      table.insert(pdata.cast_spells, {id=s.id})
    end
  end
  for _,s in ipairs(pdata.spell_power.card_map.enchant_spells) do
    if s.guid ~= "" then
      board.call("placeCastSpell",{guid=s.guid})
      table.insert(pdata.cast_spells, {id=s.id})
    end
  end
  for i,link in ipairs(pdata.spell_power.card_map.link_spells) do
    if #link == 1 then --single card
      board.call("placeCastSpell",{guid=link[1].guid})
      table.insert(pdata.cast_spells, {id=link[1].id})
    elseif #link > 1 then --handle a deck here
      local list = board.call("placeLinkSpellDeck",{index=i})
      for _,card_id in ipairs(list) do
        table.insert(pdata.cast_spells, {id=card_id})
      end
    end
  end
  --return used alteration cards
  returnUsedAlterations(pcol)
  --return player's spent mana
  pdata.mana = pdata.mana + pdata.spent_mana
  --if myst, give the mystrune, clear other players mystrune
  if pdata.spell_power.myst > 0 then
    for c,p in pairs(GD.game.players) do
      if c == pcol then
        p.mystrune = GD.game.mystrune
        local board = getObjectFromGUID(p.player_board)
        board.call("placeMystRune", {guid=GD.game.mystrune})
        local o = getObjectFromGUID(p.mystrune)
        o.call("assign",pcol)
      else
        p.mystrune = nil
      end
    end
  end
  --handle myst awards if earned
  if pdata.spell_power.myst >= 12 then
    if GD.env.verbose then print("Myst bonus:"..pdata.player_color.." recieves +1 Prestige and +2 Acuity") end
    pdata.acuity = pdata.acuity + 2
    pdata.prestige = pdata.prestige + 1
  elseif pdata.spell_power.myst >= 10 then
    if GD.env.verbose then print("Myst bonus:"..pdata.player_color.." recieves +2 Acuity") end
    pdata.acuity = pdata.acuity + 2
  elseif pdata.spell_power.myst >= 8 then
    if GD.env.verbose then print("Myst bonus:"..pdata.player_color.." recieves +1 Acuity") end
    pdata.acuity = pdata.acuity + 1
  end
  if pdata.acuity > 10 then
    if GD.env.verbose then print(pdata.player_color.." discards "..tostring(pdata.acuity-10).." Acuity") end
    pdata.acuity = 10
  end
  --reset player data structure
  pdata.spent_mana = 0
  pdata.casting = false
  pdata.active_spell_cards = {}
  pdata.actions.take = {}
  pdata.actions.play = 0
  pdata.spell_power = {   --TODO: duplicated from setPlayerClass
    dice = {
      restore = 0,
      ruin = 0,
    },
    acuity = {
      restore = 0,
      ruin = 0,
    },
    mystrune = {restore=0,ruin=0},
    card_map = {
      base_spells = {{guid="",id=""},{guid="",id=""},{guid="",id=""},{guid="",id=""},{guid="",id=""},},
      link_spells = {{},{},{},{},{},},
      enchant_spells = {{guid="",id=""},{guid="",id=""},{guid="",id=""},},
    },
    cards = {
      restore = 0,
      ruin = 0,
    },
    gross_restore = 0,
    net_restore = 0,
    gross_ruin = 0,
    net_ruin = 0,
    myst = 0,
  }
  if not(GD.game.endgame) then checkEndGame(pcol) end
  --reroll player's dice and set un-allocated
  if GD.game.endgame then
    for _,d in ipairs(pdata.dice) do
      d.value = 4
      d.element = C.die_elements[4]
      d.allocated = true
    end
  else
    for _,d in ipairs(pdata.dice) do
      local val = math.random(1,6)
      d.value = val
      d.element = C.die_elements[val]
      d.allocated = false
    end
  end
  -- checkEndGame(pcol)
  setNextPlayer()
end

--////////// Support Functions ////////////

function returnMystRune(pcol)
  if env.test.trace then log("Global:returnMystRune() "..tostring(pcol)) end
  local o = getObjectFromGUID(GD.game.mystrune)
  assert(o, "")
  o.setPosition(C.pos.myst_rune)
  GD.game.players[pcol].mystrune = nil
  o.call("assign","")
end

--[[ Called from playerBoard.  Used in the edit acuity spell dialog.
    See Related: updateAcuitySpell()
--]]
function getAcuitySpell(pcol)
  if env.test.trace then log("Global:getAcuitySpell() "..tostring(pcol)) end
  local pdata = GD.game.players[pcol]
  local acuity_spell = {
    acuity = pdata.acuity,
    restore = pdata.spell_power.acuity.restore,
    ruin = pdata.spell_power.acuity.ruin,
  }
  return acuity_spell
end

--[[ Called from player board edit acuity spell dialog.
    Update player data with edited acuity spell info.
    See Related: getAcuitySpell()
--]]
function updateAcuitySpell(params)
  if env.test.trace then log("Global: updateAcuitySpell()") end
  log(params)
  local pdata = GD.game.players[params.player_color]
  pdata.acuity = params.acuity
  pdata.spell_power.acuity.restore = params.restore
  pdata.spell_power.acuity.ruin = params.ruin
  updateHUD()
end

--[[ Update HUD and board UIs with current data.
Parameters:
  player_color: (opt) if supplied update only this players info
NOTE: Have moved updateSpellButtons and updateAlterationButtons into this function.
      Effectively making this into update all UI atomically.
NOTE: this function triggers updates to the following things:
    player spell power recalculation
    player score recalculation
    player class board object UI update
    player board object UI update
    mystrune token UI update (if owned)
TODO: evaluate if there's any duplication or REALLY BAD: recursion going on with those updates.
--]]
function updateHUD(player_color)
  if env.test.trace then log("Global: updateHUD() "..tostring(player_color)) end
  local max_heroics = 5
  if GD.game.player_count == 3 then  max_heroics = 4
  elseif GD.game.player_count == 4 then max_heroics = 3 end
  local function updatePlayerHUD(i, pcol)
    if env.test.debug then log("updatePlayerHUD() i: "..tostring(i).." "..tostring(pcol)) end
    local pdata = GD.game.players[pcol]
    updateScore(pcol)
    local score = GD.game.players[pcol].score.total
    updateSpellPower(pcol)
    local spell = {power=0,type="None"}
    if pdata.spell_power.net_restore > pdata.spell_power.net_ruin then
      spell = {
        power = pdata.spell_power.net_restore,
        type = "Restore",
      }
    elseif pdata.spell_power.net_ruin > pdata.spell_power.net_restore then
      spell = {
        power = pdata.spell_power.net_ruin,
        type = "Ruin",
      }
    elseif pdata.spell_power.myst > 0 then
      spell = {
        power = pdata.spell_power.myst,
        type = "Myst",
      }
    end
    local heroics = #pdata.heroics
    if pdata.active then
      UI_setAttribute("hud_row_"..tostring(i).."_player_pnl", "color", "Cyan")
    else
      UI_setAttribute("hud_row_"..tostring(i).."_player_pnl", "color", "rgba(0,0,0,0)")
    end
    UI_setAttribute("hud_row_"..tostring(i).."_spell", "text", tostring(spell.power))
    if spell.type ~= "None" then
      UI_setAttribute("hud_row_"..tostring(i).."_image", "image", tostring(spell.type))
      UI_setAttribute("hud_row_"..tostring(i).."_image", "active", "true")
    else
      UI_setAttribute("hud_row_"..tostring(i).."_image", "active", "false")
    end
    UI_setAttribute("hud_row_"..tostring(i).."_heroics", "text", tostring(heroics).." / "..tostring(max_heroics))
    UI_setAttribute("hud_row_"..tostring(i).."_score", "text", tostring(score))
    for i,d in ipairs(pdata.dice) do
      local id = pcol.."_hud_die_"..tostring(i).."_image"
      UI.setAttribute(id,"image",C.die_elements[d.value])
      if d.allocated then   --TODO: use gray border same as in class board?
        UI.setAttribute(id, "color", "rgb(0.4,0.4,0.4)")
      else
        UI.setAttribute(id, "color", "white")
      end
    end
    for sigil,count in pairs(pdata.sigils) do
      local txt = tostring(count)
      if sigil == "wild" then
        if count == 0 then txt = " " end
      else
        txt = txt.." ("..tostring(pdata.alt_sigils[sigil])..")"
      end
      UI_setAttribute(pcol.."_hud_sigil_"..sigil.."_txt","text",txt)
    end
    UI_setAttribute(pcol.."_hud_takes_text","text",tostring(#pdata.actions.take))
    UI_setAttribute(pcol.."_hud_plays_text","text",tostring(pdata.actions.play))
    UI_setAttribute(pcol.."_hud_mana_text","text",tostring(pdata.mana))
    UI_setAttribute(pcol.."_hud_acuity_text","text",tostring(pdata.acuity))
    UI_setAttribute(pcol.."_hud_hand_text","text",tostring(#pdata.alteration_cards).." / 10")
    --update board UIs
    local class_board = getObjectFromGUID(pdata.class_board)
    class_board.call("updateUI",pdata)
    local player_board = getObjectFromGUID(pdata.player_board)
    player_board.call("updateUI",pdata)
    if pdata.active then
      local dialog_open = pdata.casting or
            pdata.alteration_action ~= nil or
            pdata.mystrune_action ~= nil or
            pdata.spell_cost ~= nil
      if dialog_open or #pdata.actions.take == 0 or GD.game.endgame then
        updateSpellButtons(false)
        updateAlterationButtons(false)
        object_UI_setAttribute(g_lower, "recycle_spell_pnl", "active", false)
      else
        updateSpellButtons(true)
        updateAlterationButtons(true)
        object_UI_setAttribute(g_lower, "recycle_spell_pnl", "active", true)
      end
      --handle case of myst rune owned by player
      if pdata.mystrune then
        local o = getObjectFromGUID(pdata.mystrune)
        o.UI.setAttribute("ui_panel","active", not(dialog_open))
      end
    else
      if pdata.mystrune then
        local o = getObjectFromGUID(pdata.mystrune)
        o.UI.setAttribute("ui_panel","active", false)
      end
    end
  end
  if player_color ~= nil then
    updatePlayerHUD(indexOf(GD.game.player_order, player_color), player_color)
  else
    for i,pcol in ipairs(GD.game.player_order) do
      updatePlayerHUD(i, pcol)
    end
  end
end

--[[ Return true if player has Aether.  False if not.]]
function hasAether(pcol)
  local pdata = GD.game.players[pcol]
  if pdata.class == "Arcanist" then return true end
  for _,d in ipairs(pdata.dice) do
    if d.element == "Aether" then return true end
  end
  return false
end

--[[ Don't allow player's to deal cards by typing a number on them. --]]
function onObjectNumberTyped(o, pcol, n)
  if env.test.debug then log("Prevented player "..pcol.." from typing number on object "..o.getGUID()) end
  return true
end

--[[ Handle cards leaving decks.
    Sets tooltip description if enabled.
    Update guid in LUT (just in case)
    Set name to GMNotes id just for debugging if enabled.
--]]
function onObjectLeaveContainer(container, obj)
  if container.tag == "Deck" then
    if not(GD.game.started) and container.hasTag("Start_Deck") then
      --special case for start card decks being dealt out
      if container.memo ~= nil then obj.memo = container.memo
      else log("WARN: start deck memo is nil for guid "..container.getGUID())end
    end
    if obj.hasTag("Alteration") then
      local data = alterations[tonumber(obj.getGMNotes())]
      if GD.env.card_tooltips then
        local txt = ""
        if data.primary then
          txt = "PRIMARY: "
          for i,a in ipairs(data.primary.actions) do
            if i > 1 then txt = txt .. " OR: " end
            txt = txt .. a.desc
          end
        end
        if data.secondary then
          txt = txt .. "\nSECONDARY: "..data.secondary.desc
        end
        if data.discard then
          txt = txt .. "\nDISCARD: Spend one Acuity and then take another card."
        end
        obj.setDescription(txt)
        data.guid = obj.getGUID()
      end
      if env.test.debug then obj.setName(data.id)
      else obj.setName("") end
    elseif obj.hasTag("Spell") then
      local data = spells[tonumber(obj.getGMNotes())]
      if GD.env.card_tooltips then obj.setDescription(data.desc) end
      if env.test.debug then obj.setName(data.id)
      else obj.setName("") end
      data.guid = obj.getGUID()
    elseif obj.hasTag("Heroic") then
      local data = heroics[tonumber(obj.getGMNotes())]
      if GD.env.card_tooltips then obj.setDescription(data.desc) end
      if env.test.debug then obj.setName(data.id)
      else obj.setName("") end
      data.guid = obj.getGUID()
    end
  end
end

--[[ Handle Spell cards picked up in game.
    Only for Spell card tags.  Used to support the decal label used
    on spells with both types of spell power.
    Also clear spell card from map, to allow for drop to new location.
--]]
function onObjectPickUp(player_color, obj)
  if GD.game.started then
    if obj.hasTag("Spell") then
      if env.test.debug then log("Player "..player_color.." picked up spell card "..obj.getGUID()) end
      -- Clear any decals and buttons on a spell card when picked up
      if obj.getDecals() ~= nil then
        obj.setDecals({})
      end
      if obj.getButtons() ~= nil then
        obj.clearButtons()
      end
      --remove the card from the player's spell_power card map.
      local cdata = spells[tonumber(obj.getGMNotes())]
      local pdata = GD.game.players[player_color]
      local type = "base_spells"
      if cdata.enchant ~= nil then
        type = "enchant_spells"
      elseif cdata.link ~= nil then
        type = "link_spells"
      end
      for i,slot in ipairs(pdata.spell_power.card_map[type]) do
        if type == "link_spells" then
          for j,link in ipairs(slot) do
            if link.guid == obj.getGUID() then
              table.remove(slot, j)
              break
            end
          end
        else
          if slot.guid == obj.getGUID() then
            slot.guid = ""
            slot.id = ""
            break
          end
        end
      end
    end
  end
end

--////////// Deck Management ////////////

--[[ Locate and return Heroics deck.
  Update to new GUID if deck guid changed (or only one card)
  Return deck object if found (will be single card if only one left).
  Log error and return nil if no more heroics.]]                            --TODO: convert to findObject()
function getHeroicsDeck()
  if env.test.trace then log("Global: getHeroicsDeck()") end
  local deck = getObjectFromGUID(GD.game.heroics_deck_guid)
  if deck then return deck end
  -- No deck object so use cast to find it
  local p = simpleDeepCopy(C.default_cast_params)
  p.origin = C.heroics_deck_pos
  local hits = Physics.cast({p})
  if hits then
    for _,hit in pairs(hits) do
      if hit.hit_object.tag == "Deck" then
        GD.game.heroics_deck_guid = hit.hit_object.getGUID()
        return hit.hit_object
      elseif hit.hit_object.tag == "Card" then
        log("WARN: Global: getHeroicsDeck(): returning last card")
        return hit.hit_object
      end
    end
  end
  log("ERROR: Global: getHeroicsDeck(): No deck found")
  return nil
end

--[[ Locate and return Alterations deck.
  Update to new GUID if deck guid changed (or only one card)
  Return deck object if found (will be single card if only one left).
  Log error and return nil if no card or deck.]]
function getAlterationsDeck()
  if env.test.trace then log("Global: getAlterationsDeck()") end
  local deck = getObjectFromGUID(GD.game.alterations_deck_guid)
  if deck then return deck end
  -- No deck object so find it
  local deck = findObject(C.alterations_deck_pos, {"Deck","Card"}, env.test.debug)
  if not(deck) then log("WARN: Global: getAlterationsDeck(): No deck found")
  else GD.game.alterations_deck_guid = deck.getGUID() end
  return deck
end

--[[ Locate and return Spells deck.
  Update to new GUID if deck guid changed (or only one card)
  Return deck object if found (will be single card if only one left).
  Log error and return nil if no more heroics.]]
function getSpellsDeck()
  if env.test.trace then log("Global: getSpellsDeck()") end
  local deck = getObjectFromGUID(GD.game.spells_deck_guid)
  if deck then return deck end
  -- No deck object so find it
  local deck = findObject(C.spells_deck_pos, {"Deck","Card"}, env.test.debug)
  if not(deck) then log("WARN: Global: getSpellsDeck(): No deck found")
  else GD.game.spells_deck_guid = deck.getGUID() end
  return deck
end

--////////// End Game ////////////

--[[ Check end game conditions.  Set state if reached. ]]
function checkEndGame(pcol)
  if env.test.trace then log("Global: checkEndGame() "..tostring(pcol)) end
  -- if GD.game.endgame then return end --already triggered
  local max = 5
  if #GD.game.player_order == 3 then
    max = 4
  elseif #GD.game.player_order == 4 then
    max = 3
  end
  if #GD.game.players[pcol].heroics == max then
    for _,pdata in pairs(GD.game.players) do
      pdata.actions.take = {}
      pdata.actions.play = 0
      pdata.active = false
      pdata.endgame = true
    end
    GD.game.endgame_players = {}
    local index = indexOf(GD.game.player_order, pcol)
    for i=1,#GD.game.player_order-1 do
      index = index + 1
      if index > #GD.game.player_order then index = 1 end
      table.insert(GD.game.endgame_players, GD.game.player_order[index])
    end
    if GD.env.verbose then
      print("Endgame triggered by player "..pcol.."!")
      print("Remaining players may only cast spells.")
    end
    UI_setAttribute("endgame_pnl","active", true)
    --remove spell cards
    for _,card in ipairs(GD.game.spells) do
      local o = getObjectFromGUID(card.card_guid)
      if o then o.destruct() end
    end
    --remove alteration cards & acuity
    for i,card in ipairs(GD.game.alterations) do
      local o = getObjectFromGUID(card.card_guid)
      if o then o.destruct() end
      object_UI_setAttribute(g_lower, "alterations_acuity_"..tostring(i).."_pnl","active",false)
    end
    if env.test.debug then
      log("Endgame triggered by "..pcol)
      log("Remaining players only cast spells.")
      log(GD.game.endgame_players)
    end
    GD.game.endgame = true
    updateHUD()
  end
end

--[[ Final game scoring.  Sort players by score and display results.
  Tiebreaker: arcanas points.
--]]
function finalScore()
  if env.test.trace then log("Global: finalScore()") end
  UI_setAttribute("endgame_pnl","active", false)
  local scores = {}
  for pcol,pdata in pairs(GD.game.players) do
    local new_data = simpleDeepCopy(pdata.score)
    new_data.player = pcol
    new_data.class = pdata.class
    if #scores == 0 then
      table.insert(scores, new_data)
    else
      local found = false
      for i=1,#scores do
        if new_data.total > scores[i].total then
          table.insert(scores, i, new_data)
          found = true
          break
        elseif new_data.total == scores[i].total then --tie breaker
          if new_data.arcanas > scores[i].arcanas then
            print(new_data.player.." wins tie breaker with "..scores[i].player.." on arcana points")
            table.insert(scores, i, new_data)
            found = true
            break
          elseif scores[i].arcanas > new_data.arcanas then
            print(scores[i].player.." wins tie breaker with "..new_data.player.." on arcana points")
            table.insert(scores, i+1, new_data)
            found = true
            break
          else
            print(new_data.player.." and "..scores[i].player.." share a tie.")
            table.insert(scores, i+1, new_data)
            found = true
            break
          end
        end
      end
      if not(found) then
        table.insert(scores, #scores + 1, new_data)
      end
    end
  end
  if env.test.debug then
    log("score:")
    log(scores)
  end
  local i = 1
  for _,data in ipairs(scores) do
    UI_setAttribute("score_table_row_"..tostring(i).."_text_1", "text", data.player)
    UI_setAttribute("score_table_row_"..tostring(i).."_text_1", "color", data.player)
    UI_setAttribute("score_table_row_"..tostring(i).."_text_2", "text", data.class)
    UI_setAttribute("score_table_row_"..tostring(i).."_text_3", "text", data.heroics)
    UI_setAttribute("score_table_row_"..tostring(i).."_text_4", "text", data.sigils)
    UI_setAttribute("score_table_row_"..tostring(i).."_text_5", "text", data.prestige)
    UI_setAttribute("score_table_row_"..tostring(i).."_text_6", "text", data.arcanas)
    UI_setAttribute("score_table_row_"..tostring(i).."_text_7", "text", data.total)
    i = i + 1
  end
  local pname = GD.game.players[scores[1].player].name
  UI_setAttribute("score_title_text","text",pname.." wins the game!!!")
  broadcastToAll(scores[1].player.." wins the game!!!")
  UI_setAttribute("score_panel","active",true)
end



--[[ ******** TESTING ******** --]]

function enableDieTesting(on)
  log("enableDieTesting() "..tostring(state))
  if not(GD.game.started) then
    log("Usage: after all players placed class boards.")
    return
  end
  if on == nil then on = true end
  local class = "image_active"
  if on then class = "die_test" end
  log("setting dice to class "..class)
  for pcol,pdata in pairs(GD.game.players) do
    log("Player "..pcol)
    for i,d in ipairs(pdata.dice) do
      UI.setClass(pcol.."_hud_die_"..tostring(i).."_image",class)
    end
  end
end

function testDie(player, button, id)
  log("testDie(): "..player.color.." "..tostring(id).." "..tostring(button))
  local dice = GD.game.players[player.color].dice
  local index = tonumber(Split(id,"_")[4])
  if button == "-2" then
    log("Toggle "..player.color.." die "..tostring(index).." allocated state.")
    dice[index].allocated = not(dice[index].allocated)
  elseif button == "-1" then
    log("Cycle "..player.color.." die "..tostring(index).." value.")
    local val = dice[index].value + 1
    if val > 6 then val = 1 end
    dice[index].value = val
    dice[index].element = C.die_elements[val]
  end
  updateHUD(player.color)
end

--[[ Get obj position (DEVELOPMENT ONLY) ]]
function savePosition(g)
  local o = getObjectFromGUID(g)
  Notes.setNotes(tostring(o.getPosition()))
end

--[[ Get obj rotation (DEVELOPMENT ONLY) ]]
function saveRotation(g)
  local o = getObjectFromGUID(g)
  Notes.setNotes(tostring(o.getRotation()))
end

-- require("tts-lib/utils")
#include ~/github/tts-lib/utils.ttslua
#include ~/github/tts-mercurial/Constants.ttslua
#include ~/github/tts-mercurial/Cards.ttslua
