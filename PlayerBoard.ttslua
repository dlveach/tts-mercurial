--Board relative positions
mana_local_pos = {}
mana_local_pos[1] = { 0.325848, -0.5, -0.777266 }
mana_local_pos[2] = { 0.642849, -0.5, -0.770351 }
mana_local_pos[3] = { 0.943852, -0.5, -0.758921 }
mana_local_pos[4] = { 1.237281, -0.5, -0.76304 }
mana_local_pos[5] = { 1.558671, -0.5, -0.756527 }
mana_local_pos[6] = { 0.293719, -0.5, -0.438221 }
mana_local_pos[7] = { 0.612091, -0.5, -0.443802 }
mana_local_pos[8] = { 0.915044, -0.5, -0.441325 }
mana_local_pos[9] = { 1.252831, -0.5, -0.443335 }
mana_local_pos[10] = { 1.559581, -0.5, -0.440888 }
acuity_local_pos = {}
acuity_local_pos[1] = { 0.327416, -0.5, -0.105233 }
acuity_local_pos[2] = { 0.602913, -0.5, -0.098424 }
acuity_local_pos[3] = { 0.937014, -0.5, -0.092739 }
acuity_local_pos[4] = { 1.243617, -0.5, -0.102063 }
acuity_local_pos[5] = { 1.558407, -0.5, -0.088233 }
acuity_local_pos[6] = { 0.289897, -0.5, 0.210014 }
acuity_local_pos[7] = { 0.612284, -0.5, 0.215907 }
acuity_local_pos[8] = { 0.926764, -0.5, 0.214188 }
acuity_local_pos[9] = { 1.218278, -0.5, 0.220292 }
acuity_local_pos[10] = { 1.567567, -0.5, 0.222189 }
dice_local_pos = {}
dice_local_pos[1] = { 4.9, -1, -0.859595 }
dice_local_pos[2] = { 6.0, -1, -0.861671 }
dice_local_pos[3] = { 4.9, -1, -0.363973 }
dice_local_pos[4] = { 6.0, -1, -0.355712 }
dice_local_pos[5] = { 4.9, -1, 0.131452 }
dice_local_pos[6] = { 6.0, -1, 0.143394 }
dice_local_pos[7] = { 4.9, -1, 0.659981 }
dice_local_pos[8] = { 6.0, -1, 0.662818 }
heroics_local_pos = {}
heroics_local_pos[1] = { 8.026311, 0.186396, 2.947193 }
heroics_local_pos[2] = { 8.043096, 0.186396, 2.426311 }
heroics_local_pos[3] = { 8.034476, 0.186396, 1.922377 }
heroics_local_pos[4] = { 8.038564, 0.186395, 1.426908 }
heroics_local_pos[5] = { 8.029942, 0.186396, 0.914504 }
spells_local_pos = {}
spells_local_pos[1] = { -1.393784, 0.186396, 2.121494 }
spells_local_pos[2] = { -0.369069, 0.186396, 2.136242 }
spells_local_pos[3] = { 0.658648, 0.186396, 2.134193 }
spells_local_pos[4] = { 1.686339, 0.186396, 2.12854 }
spells_local_pos[5] = { 2.740341, 0.186396, 2.119081 }
link_spells_local_pos = {}
link_spells_local_pos[1] = { -1.393219, 0.186396, 4.027077 }
link_spells_local_pos[2] = { -0.368504, 0.186396, 4.041823 }
link_spells_local_pos[3] = { 0.659214, 0.186396, 4.039776 }
link_spells_local_pos[4] = { 1.686906, 0.186396, 4.034122 }
link_spells_local_pos[5] = { 2.740907, 0.186396, 4.024664 }
enchantment_spells_local_pos = {}
enchantment_spells_local_pos[1] = { 3.897315, 0.186396, 4.018102 }
enchantment_spells_local_pos[2] = { 4.975488, 0.186396, 4.017481 }
enchantment_spells_local_pos[3] = { 6.059778, 0.186396, 4.008014 }

spell_discards_local_pos = { 9.686725, 0.186396, 0.937226 }
used_alterations_local_pos = { 2.731754, 0.186396, -0.061831 }
drop_zone_local_pos = { -0.842196, -1.424986, -0.003841 }
dice_zone_local_pos = { 5.382422, -2.351135, 0.733407 }
dice_zone_size = {["x"]=6.015524,["y"]=5.1,["z"]=6.659328}
prestige_zone_local_pos = { 9.690072, -2.351135, 2.93751 }
prestige_zone_size = {["x"]=2.736159,["y"]=5.1,["z"]=2.836752}
acuity_restore_zone_local_pos = { 6.601711, -2.351135, -1.90781 }
acuity_restore_zone_size = {["x"]=3.37996,["y"]=5.1,["z"]=1.50891}
acuity_ruin_zone_local_pos = { 8.798397, -2.351135, -1.924995 }
acuity_ruin_zone_size = {["x"]=3.420197,["y"]=5.1,["z"]=1.508913}
spells_zone_local_pos = { 2.326385, -2.351134, 3.205592}
spells_zone_size = {["x"]=15.35225,["y"]=5.1,["z"]=6.884419}

dice_translation = {"ruin","ruin","","","restore","restore"}

env = {}
C = {}
GD = {}
loading = true
action = "drop"

--[[ Game loading. ]]
function onLoad(saved_data)
  env = Global.getTable("env")
  C = Global.getTable("C")
  --self.interactable = false
  if saved_data ~= "" then
    if env.test.trace then log("Player Board " .. self.getName() .. " saved load") end
    local restore_data = JSON.decode(saved_data)
    GD = restore_data
    restoreBoardState()
  else
    if env.test.trace then log("Player Board " .. self.getName() .. " fresh load") end
    GD.states = {}
    GD.states.UI = {}
    GD.states.obj_vis = {}
    GD.board = {}
    GD.board.player_color = ""
    GD.board.initialized = false
    GD.board.player_position = 0  -- 1 to 4 when initialized
    GD.board.color_bar_guid = ""
    --spell cast stuff
    GD.board.power = {}
    GD.board.power.ruin = {}
    GD.board.power.ruin.dice = 0
    GD.board.power.ruin.acuity = 0
    GD.board.power.ruin.cards = 0
    GD.board.power.restore = {}
    GD.board.power.restore.dice = 0
    GD.board.power.restore.acuity = 0
    GD.board.power.restore.cards = 0
    --scoring stuff (TODO)
  end
  loading = false
end

--[[ Restore this board's state during a load from saved data. ]]
function restoreBoardState()
  if env.test.trace then log(self.getName()..":restoreBoardState()") end
  if GD.board.initialized then
    setupBoard()
    if GD.board.active  then
      local color_bar = getObjectFromGUID(C.guids.color_bars[GD.board.player_position])
      color_bar.setInvisibleTo({})
      color_bar.UI.setAttribute("block_panel", "active", "true")
    end
  end
  --restore object visiblity
  for g,colors in pairs(GD.states.obj_vis) do
    local obj = getObjectFromGUID(g)
    if obj then
      obj.setInvisibleTo(colors)
    end
  end
  --restore UI state
  for key,value in pairs(GD.states.UI) do
    local id = Split(key, ':')[1]
    local field = Split(key, ':')[2]
    self.UI.setAttribute(id, field, value)
  end
end

--[[ Wrapper function for saving obj visiblity for game restore. ]]
  function setInvisibleTo(guid, colors)
    if env.test.trace then log("setInvisibleTo(): "..guid) end
    assert(type(guid) == 'string', "guid must be a string")
    assert(colors)
    getObjectFromGUID(guid).setInvisibleTo(colors)
    GD.states.obj_vis[guid] = colors
  end
  
--[[  Wrapper function for saving UI attributes for game restore. ]]
function UI_setAttribute(id, field, value)
  if env.test.trace and env.game.verbose then log(self.getName() .. ": UI_setAttribute()") end
  assert(type(id) == "string", "id must be a string")
  assert(type(field) == "string", "field must be a string")
  self.UI.setAttribute(id, field, value)
  GD.states.UI[id..":"..field] = value
end

--[[ Create script zones for this player board.  
    Not sure they survive save/load so there is a
    check to see if they are there.  --]]
function createZones()
  if env.test.trace then log(self.getName() .. ": createZones()") end

  local p = {
    type              = 'ScriptingTrigger', 
    sound             = false,
    snap_to_grid      = false,
  }
  -- cast board drop zone
  local drop_pos = self.positionToWorld(drop_zone_local_pos)
  p.position          = drop_pos
  p.scale             = {3.27755, 3, 3.59142}
  p.callback_function = function(obj)
    obj.setPosition(drop_pos)
    GD.board.class_board_drop_zone = obj.getGUID()
    end
  if getObjectFromGUID(GD.board.class_board_drop_zone) == nil then
    spawnObject(p) 
  end
  --dice zone
  local dice_pos = self.positionToWorld(dice_zone_local_pos)
  p.position          = dice_pos
  p.scale             = dice_zone_size
  p.callback_function = function(obj)
    obj.setPosition(dice_pos)
    GD.board.dice_zone = obj.getGUID()
    end
  if getObjectFromGUID(GD.board.dice_zone) == nil then
    spawnObject(p) 
  end
  --prestige zone
  local prestige_pos = self.positionToWorld(prestige_zone_local_pos)
  p.position          = prestige_pos
  p.scale             = prestige_zone_size
  p.callback_function = function(obj)
    obj.setPosition(prestige_pos)
    GD.board.prestige_zone = obj.getGUID()
    end
  if getObjectFromGUID(GD.board.prestige_zone) == nil then
    spawnObject(p) 
  end
  --acuity restore zone
  local acuity_restore_pos = self.positionToWorld(acuity_restore_zone_local_pos)
  p.position          = acuity_restore_pos
  p.scale             = acuity_restore_zone_size
  p.callback_function = function(obj)
    obj.setPosition(acuity_restore_pos)
    GD.board.acuity_restore_zone = obj.getGUID()
    end
  if getObjectFromGUID(GD.board.acuity_restore_zone) == nil then
    spawnObject(p) 
  end
  --acuity ruin zone
  local acuity_ruin_pos = self.positionToWorld(acuity_ruin_zone_local_pos)
  p.position          = acuity_ruin_pos
  p.scale             = acuity_ruin_zone_size
  p.callback_function = function(obj)
    obj.setPosition(acuity_ruin_pos)
    GD.board.acuity_ruin_zone = obj.getGUID()
    end
  if getObjectFromGUID(GD.board.acuity_ruin_zone) == nil then
    spawnObject(p) 
  end
  --zpell cards zone
  local spells_zone_pos = self.positionToWorld(spells_zone_local_pos)
  p.position          = spells_zone_pos
  p.scale             = spells_zone_size
  p.callback_function = function(obj)
    obj.setPosition(spells_zone_pos)
    GD.board.spells_zone = obj.getGUID()
    end
  if getObjectFromGUID(GD.board.spells_zone) == nil then
    spawnObject(p) 
  end
end

--[[ Save game state ]]
function onSave()
  local data_to_save = GD
  local saved_data = JSON.encode(data_to_save)
  if env.test.force_fresh_save then saved_data = "" end
  return saved_data
end

--[[ Handler for player "Done" button. ]]
function nextPlayerBtn(player, mouse, id)
  if env.test.trace then log(self.getName() .. ": nextPlayerBtn()") end
  if player.color == GD.board.player_color then
    UI_setAttribute("next_player_pnl", "active", "false")
    UI_setAttribute("cleanup_pnl", "active", "false")    
    local color_bar = getObjectFromGUID(C.guids.color_bars[GD.board.player_position])
    color_bar.setInvisibleTo(env.game.player_table_order)
    color_bar.UI.setAttribute("block_panel", "active", "false")
    GD.board.active = false
    Global.call("setNextPlayer")
  else
    broadcastToColor("Player " .. player.color .. ": " .. self.getName() .. " is not your class.", player.color)
  end
end

--[[ Handler for "Cleanup" button press.  Cleanup player board after a spell cast. ]]
function cleanupBtn(player, mouse, id)
  if env.test.trace then log(self.getName() .. ": cleanupBtn()") end
  if not(player.color == GD.board.player_color) then
    broadcastToColor("Player " .. player.color .. ": " .. self.getName() .. " is not your class.", player.color)
    return
  end
  local dice = {}
  local spells = {}
  local mana = {}    
  local zone = getObjectFromGUID(GD.board.spells_zone)
  assert(zone)
  local stuff = zone.getObjects()
  for _,o in pairs(stuff) do
    if o.hasTag("Dice") then table.insert(dice, o) 
    elseif o.hasTag("Mana") then table.insert(mana, o)
    elseif o.hasTag("Spell") then table.insert(spells, o)
    elseif o.hasTag("Acuity") then o.destruct()
    else
      log("Unknown Object: " .. o.getGUID())
      log(o.getTags())
    end
  end
  action = "cleanup"
  for _,obj in pairs(dice) do placeObject(obj) end
  for _,obj in pairs(spells) do placeObject(obj) end
  for _,obj in pairs(mana) do placeObject(obj) end
end

--[[ Document --]]
function onCollisionEnter(hit_info)
  if loading then return end
  --if env.test.trace then log(self.getName() .. ":onCollisionEnter()") end
  if GD.board.initialized then
    local zone = getObjectFromGUID(GD.board.class_board_drop_zone)
    if zone == nil then
      log(self.getName()..":onCollisionEnter() ERROR: No drop zone")
    else
      for _,obj in pairs(zone.getObjects()) do
        if obj.getGUID() == hit_info.collision_object.getGUID() then           
          --[[if GD.board.active == false then
            broadcastToAll(self.getName() .. " is not the active player board.")
          elseif not(obj.hasTag("Spell")) then 
            placeObject(obj) 
          end ]]          
          action = "drop"
          if not(obj.hasTag("Spell")) then 
            placeObject(obj) 
          end
        end
      end
    end
  end
end

--[[ Document --]]
function placeObject(obj)
  if env.test.trace then log(self.getName() .. ":placeObject()") end
  local p = {
    origin       = {},
    direction    = {0,1,0},
    type         = 2,
    size         = {0.25,0.25,0.25},
    max_distance = 1,
    debug        = false,    
  }
  --TODO: refactor common code
  if obj.hasTag("Mana") then
    local index = 1
    local looking = true
    while looking do
      p.origin = self.positionToWorld(mana_local_pos[index])
      local hits = Physics.cast(p)
      local empty = true
      if hits ~= nil then
        for _,h in pairs(hits) do
          local o = h.hit_object
          if o.hasTag("Mana") then empty = false end
        end
        if empty then
          looking = false
          obj.setPosition(self.positionToWorld(mana_local_pos[index]))
          obj.setRotation({0,0,0})
        else
          index = index + 1
          if index > 10 then
            looking = false
            log("ERROR: mana index > 10")
          end
        end
      else
        log("ERROR: got no hits for mana index "..index) --shouldn't ever happen, table and tile will hit
      end
    end
  elseif obj.hasTag("Acuity") then
    local index = 1
    local looking = true
    while looking do
      p.origin = self.positionToWorld(acuity_local_pos[index])
      local hits = Physics.cast(p)
      local empty = true
      if hits ~= nil then
        for _,h in pairs(hits) do
          local o = h.hit_object
          if o.hasTag("Acuity") then empty = false end
        end
        if empty then
          looking = false
          obj.setRotation({0,0,0})
          obj.setPosition(self.positionToWorld(acuity_local_pos[index]))
        else
          index = index + 1
          if index > 10 then
            looking = false
            log("ERROR: acuity index > 10")
          end
        end
      else
        log("ERROR: got no hits for acuity index "..index) --shouldn't ever happen, table and tile will hit
      end
    end  
  elseif obj.hasTag("Dice") then
    local pos = scatter(self.positionToWorld(dice_zone_local_pos), {1.25,0,1.5}, {0.1,0,0.1})
    obj.setPosition(pos)
  elseif obj.hasTag("Spell") then
    if action == "drop" then
      log("--- TODO: Spell drop, locate best spell position")
    elseif action == "cleanup" then
      local pos = Vector(self.positionToWorld(spell_discards_local_pos))
      pos.y = 3
      obj.setPosition(pos)
    end
  elseif obj.hasTag("Arcana") then
    local pos = Vector(self.positionToWorld(spell_discards_local_pos))
    pos.y = 3
    obj.setPosition(pos)
  elseif obj.hasTag("Heroic") then
    log("--- TODO: Heroc drop.  Place in next empty Heroic position.")
  elseif obj.hasTag("Alteration") or obj.hasTag("Artifact") then
    obj.deal(1, GD.board.player_color)
  else
    log("ERROR: unhandled` object")
  end
end

--[[ Handler for player selecting (dropping) this board.  
    Call Global to check conditions and assign playerboard & position to player. ]]
function onDrop(player_color)
  if env.test.trace then log(self.getName().." onDrop()") end
  for i=1,4 do
    local zone_guid = C.guids.board_zones[i]
    z = getObjectFromGUID(zone_guid)
    if z ~= nil then
      for _,o in pairs(z.getObjects()) do
        if o.getGUID() == self.getGUID() then
          --ensure tile is in range to be snapped by moving to center of zone
          local pos = z.getPosition()
          local new_pos = o.getPosition()
          new_pos.x = pos.x
          new_pos.z = pos.z
          new_pos.y = 3
          o.setPosition(new_pos)
          --setup teh board & player area after it's settled in position
          if env.test.debug then log(self.getName()..":"..self.getGUID().." dropped in position "..tostring(i).." by "..player_color) end
          local board_guid = self.getGUID()
          Wait.condition(
            function() Global.call("setPlayerClass",{
              ["player"]=player_color, 
              ["guid"]=board_guid,
              ["position"]=i,
            }) end,
            function() return self.resting end
          )
          z.destruct()
          break;
        end
      end
    else
      log("No player zone here")
      --broadcastToColor("Not a valid Class Board location", player_color)
    end
  end
end

--[[ Called from Global after it checks to ensure player has not already selected a class.
      Sets up player for this class.  ]]
function setPlayer(params)
  if env.test.trace then log(self.getName() .. ": setPlayer()") end
  assert(params.player)
  assert(params.position)
  self.setLock(true)
  self.interactable = false
  GD.board.player_color = params.player
  GD.board.player_position = params.position
  UI_setAttribute("class_select_pnl", "active", "false")
  local deck = getObjectFromGUID(start_deck)
  card_count = #deck.getObjects()
  deck.deal(card_count, GD.board.player_color)
  deck = getObjectFromGUID(C.guids.artifacts_deck)
  deck.deal(artifact_cards, GD.board.player_color)
  if take_myst_rune then
    --get the myst rune and move it to Mystcaller
    local guid = Global.call("getMystRuneGuid")
    local pos = self.getPosition()
    pos[1] = pos[1] - 4
    local rune = getObjectFromGUID(guid)
    rune.setPositionSmooth(pos, false, false)
    rune.setRotation(C.rot.myst_rune)
  end
  color_bar = getObjectFromGUID(C.guids.color_bars[GD.board.player_position])
  color_bar.UI.setAttribute("block_text_id", "text", self.getName())
  color_bar.setColorTint(GD.board.player_color)
  color_bar.setInvisibleTo({})
  UI_setAttribute("total_restore_panel", "active", "true")
  UI_setAttribute("total_ruin_panel", "active", "true")
  UI_setAttribute("total_myst_panel", "active", "true")
  UI_setAttribute("dice_restore_panel", "active", "true")
  UI_setAttribute("dice_ruin_panel", "active", "true")
  UI_setAttribute("acuity_restore_panel", "active", "true")
  UI_setAttribute("acuity_ruin_panel", "active", "true")
  UI_setAttribute("update_spell_pnl", "active", "true")
  --Starting dice
  local dice_bag = getObjectFromGUID(C.guids.dice_bag)
  local function dice()
    dice_bag.takeObject({
      callback_function = function(obj) 
        obj.setValue(math.random(1,6))
        placeObject(obj) 
      end
    })
  end
  Wait.time(function() dice() end, .25, start_dice)
  --Starting mana
  local mana_bag = getObjectFromGUID(C.guids.mana_bag)
  local function mana()
    mana_bag.takeObject({
      callback_function = function(obj) placeObject(obj) end
    })
  end
  Wait.time(function() mana() end, .25, start_mana)
  --Starting acuity
  if start_acuity > 0 then
    local acuity_bag = getObjectFromGUID(C.guids.acuity_bag)
    local function acuity()
      acuity_bag.takeObject({
        callback_function = function(obj) placeObject(obj) end
      })
    end
    Wait.time(function() acuity() end, .25, start_acuity)
  end
end

--[[ Called from Global during player setup.  ]]
function dealAcuity(params)
  if env.test.trace then log(self.getName() .. ": dealAcuity()") end
  assert(params.amount)
  local acuity_bag = getObjectFromGUID(C.guids.acuity_bag)
  log(self.getName().." placing " .. params.amount .. " extra acuity on " .. self.getName())
  local function deal()
    acuity_bag.takeObject({
      callback_function = function(obj) placeObject(obj) end
    })
  end
  Wait.time(function() deal() end, .25, params.amount)
end

--[[ Called from Global when this player is active. ]]
function enableActivePlayer()
  if env.test.trace then log(self.getName() .. ": enableActivePlayer()") end
  UI_setAttribute("next_player_pnl", "active", "true")
  UI_setAttribute("cleanup_pnl", "active", "true")
  --UI_setAttribute("update_spell_pnl", "active", "true")
  local color_bar = getObjectFromGUID(C.guids.color_bars[GD.board.player_position])
  color_bar.setInvisibleTo({})
  color_bar.UI.setAttribute("block_panel", "active", "true")
  GD.board.active = true
end

--[[ Called from Global after all players have selected a class.  Also may be called during game restore.
      If this board is unnassigned, clear all the stuff for it (dice etc.) from the game. ]]
function setupBoard()
  if env.test.trace then log(self.getName() .. ": setupBoard()") end
  if GD.board.player_color == "" then
    --unasigned, delete this board
      getObjectFromGUID(start_deck).destruct()
      self.destruct()
  else
    createZones()
    GD.board.initialized = true
    GD.board.active = false
    local color_bar = getObjectFromGUID(C.guids.color_bars[GD.board.player_position])
    color_bar.setInvisibleTo(env.game.player_table_order)
    color_bar.UI.setAttribute("block_panel", "active", "false")
  end  
end

--[[ Return a table with unallocated dice values. --]]
function getUnallocatedDiceValues()
  local dice_zone = getObjectFromGUID(GD.board.dice_zone)
  if dice_zone == nil then
    log(self.getName().." getUnallocatedDiceValues(): ERROR: Attempt to get dice but zone is nil.")
    return {}
  end
  local objects = dice_zone.getObjects()
  local result = {}
  for _,o in pairs(objects) do
    if o.hasTag("Dice") then
      --result[o.getGUID()] = o.getRotationValue()
      table.insert(result, o.getRotationValue())
    end
  end
  return result
end

--[[ Return a count of unused acuity on the player class board. --]]
function getUnusedAcuityCount()
  local p = {
    origin       = {},
    direction    = {0,1,0},
    type         = 2,
    size         = {0.25,0.25,0.25},
    max_distance = 1,
    debug        = false,    
  }
  local count = 0
  for i=1,10 do
    p.origin = self.positionToWorld(acuity_local_pos[i])
    local hits = Physics.cast(p)
    if hits ~= nil then
      for _,h in pairs(hits) do
        if h.hit_object.hasTag("Acuity") then count = count + 1 end
      end
    end
  end
  return count
end

--[[ Button handler to trigger spell power update --]]
function updateSpellPowerBtn(player, mouse, id)
  local pcol = player.color
  if env.test.trace then log(self.getName() .. ": updateSpellPowerBtn() "..pcol) end
  updateSpellPower()
end

--[[ Calculate spell power for this player board and update UI elements --]]
function updateSpellPower()
  if env.test.trace then log(self.getName() .. ": updateSpellPower()") end
  local total_restore = 0
  local total_ruin = 0
  local total_myst = 0
  --update power contribution by unused dice
  GD.board.power.ruin.dice = 0
  GD.board.power.restore.dice = 0
  for _,d in pairs(getUnallocatedDiceValues()) do
    if dice_translation[d] == "ruin" then
      GD.board.power.ruin.dice = GD.board.power.ruin.dice + 1
    elseif dice_translation[d] == "restore" then
      GD.board.power.restore.dice = GD.board.power.restore.dice + 1
    end
  end
  UI_setAttribute("dice_restore_text_id", "text", tostring(GD.board.power.restore.dice))
  UI_setAttribute("dice_ruin_text_id", "text", tostring(GD.board.power.ruin.dice))
  --uppdate power contributed by acuity spaces
  GD.board.power.restore.acuity = 0
  local acuity_restore_zone = getObjectFromGUID(GD.board.acuity_restore_zone)
  local acuity_count = 0
  for _,o in pairs(acuity_restore_zone.getObjects()) do
    if o.hasTag("Acuity") then
      acuity_count = acuity_count + 1
    end
  end
  if acuity_count > 0 then
    local val,_ = math.modf(acuity_count/3)
    GD.board.power.restore.acuity = val
  else
    GD.board.power.restore.acuity = 0
  end
  UI_setAttribute("acuity_restore_text_id", "text", tostring(GD.board.power.restore.acuity))
  GD.board.power.ruin.acuity = 0
  local acuity_ruin_zone = getObjectFromGUID(GD.board.acuity_ruin_zone)
  local ruin_count = 0
  for _,o in pairs(acuity_ruin_zone.getObjects()) do
    if o.hasTag("Acuity") then
      ruin_count = ruin_count + 1
    end
  end
  if ruin_count > 0 then
    local val,_ = math.modf(ruin_count/4)
    GD.board.power.ruin.acuity = val
  else
    GD.board.power.ruin.acuity = 0
  end
  UI_setAttribute("acuity_ruin_text_id", "text", tostring(GD.board.power.ruin.acuity))

  --TODO: update power from spell cards

  --calculate totals and update UI
  total_restore = total_restore + GD.board.power.restore.dice
  total_restore = total_restore + GD.board.power.restore.acuity
  total_restore = total_restore + GD.board.power.restore.cards
  total_ruin = total_ruin + GD.board.power.ruin.dice
  total_ruin = total_ruin + GD.board.power.ruin.acuity
  total_ruin = total_ruin + GD.board.power.ruin.cards
  if total_restore == total_ruin then total_myst = total_restore end
  UI_setAttribute("total_restore_text_id", "text", tostring(total_restore))
  UI_setAttribute("total_ruin_text_id", "text", tostring(total_ruin))
  UI_setAttribute("total_myst_text_id", "text", tostring(total_myst))
end

--[[ ******** EXPERIMENTAL ******** --]]

function t_getSpellPower(params)
  assert(params.guid)
  local card = getObjectFromGUID(params.guid)
  return getSpellPower(card)
end

--[[ Process the GM notes on a spell card.  Return the restore power and ruin power of the card. --]]
function getSpellPower(card)
  if env.test.trace then log(self.getName() .. ": updateSpellPower()") end
  assert(card)
  local gm_note = card.getGMNotes()
  local data = JSON.decode(gm_note)
  if data ~= nil then
    assert(data.restore)
    assert(data.ruin)
    return data.restore, data.ruin
  end
  return 0, 0
end

--[[ Called from global on spell card drop by player for this board. 
      Triggers spell power update if dropped in board's spell card zone. --]]
function spellDrop(params)
  if env.test.trace then log(self.getName() .. ": spellDrop()") end
  local card_guid = params.guid
  local z = getObjectFromGUID(GD.board.spells_zone)
  for _,o in pairs(z.getObjects()) do
    if o.getGUID() == card_guid then
      updateSpellPower()
      return
    end
  end
end

--[[ Called from global on acuity drop by player for this board.
      Triggers spell power update if dropped in board's restore or ruin zone. --]]
function acuityDrop(params)
  if env.test.trace then log(self.getName() .. ": acuityDrop()") end
  local acuity_guid = params.guid
  local z = getObjectFromGUID(GD.board.acuity_restore_zone)
  for _,o in pairs(z.getObjects()) do
    if o.getGUID() == acuity_guid then
      updateSpellPower()
      return
    end
  end
  z = getObjectFromGUID(GD.board.acuity_ruin_zone)
  for _,o in pairs(z.getObjects()) do
    if o.getGUID() == acuity_guid then
      updateSpellPower()
      return
    end
  end
end
  


--[[ ***** DEVELOPMENT ONLY UTILS --]]

function setGMNote(card, data)
  assert(card)
  assert(data)
  assert(type(data) == "table")
  assert(card.hasTag("Spell"))
  card.setGMNotes(JSON.encode_pretty(variable)(data))
end

function saveLocalPosition(params)  
  local o = getObjectFromGUID(params.guid)
  local world_pos = o.getPosition()
  local local_pos = self.positionToLocal(world_pos)
  Notes.setNotes(tostring(local_pos))
end

require("tts-lib/utils")
