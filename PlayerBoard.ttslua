--Board relative positions
mana_local_pos = {}
mana_local_pos[1] = { 0.325848, -0.5, -0.777266 }
mana_local_pos[2] = { 0.642849, -0.5, -0.770351 }
mana_local_pos[3] = { 0.943852, -0.5, -0.758921 }
mana_local_pos[4] = { 1.237281, -0.5, -0.76304 }
mana_local_pos[5] = { 1.558671, -0.5, -0.756527 }
mana_local_pos[6] = { 0.293719, -0.5, -0.438221 }
mana_local_pos[7] = { 0.612091, -0.5, -0.443802 }
mana_local_pos[8] = { 0.915044, -0.5, -0.441325 }
mana_local_pos[9] = { 1.252831, -0.5, -0.443335 }
mana_local_pos[10] = { 1.559581, -0.5, -0.440888 }
acuity_local_pos = {}
acuity_local_pos[1] = { 0.327416, -0.5, -0.105233 }
acuity_local_pos[2] = { 0.602913, -0.5, -0.098424 }
acuity_local_pos[3] = { 0.937014, -0.5, -0.092739 }
acuity_local_pos[4] = { 1.243617, -0.5, -0.102063 }
acuity_local_pos[5] = { 1.558407, -0.5, -0.088233 }
acuity_local_pos[6] = { 0.289897, -0.5, 0.210014 }
acuity_local_pos[7] = { 0.612284, -0.5, 0.215907 }
acuity_local_pos[8] = { 0.926764, -0.5, 0.214188 }
acuity_local_pos[9] = { 1.218278, -0.5, 0.220292 }
acuity_local_pos[10] = { 1.567567, -0.5, 0.222189 }
dice_local_pos = {}
dice_local_pos[1] = { 4.9, -1, -0.859595 }
dice_local_pos[2] = { 6.0, -1, -0.861671 }
dice_local_pos[3] = { 4.9, -1, -0.363973 }
dice_local_pos[4] = { 6.0, -1, -0.355712 }
dice_local_pos[5] = { 4.9, -1, 0.131452 }
dice_local_pos[6] = { 6.0, -1, 0.143394 }
dice_local_pos[7] = { 4.9, -1, 0.659981 }
dice_local_pos[8] = { 6.0, -1, 0.662818 }
heroics_local_pos = {}
heroics_local_pos[1] = { 8.026311, 0.186396, 2.947193 }
heroics_local_pos[2] = { 8.043096, 0.186396, 2.426311 }
heroics_local_pos[3] = { 8.034476, 0.186396, 1.922377 }
heroics_local_pos[4] = { 8.038564, 0.186395, 1.426908 }
heroics_local_pos[5] = { 8.029942, 0.186396, 0.914504 }
won_heroics_local_pos = {}
won_heroics_local_pos[1] = { 8.152003, 0.186395, 2.945135 }
won_heroics_local_pos[2] = { 8.151908, 0.186395, 2.415836 }
won_heroics_local_pos[3] = { 8.151816, 0.186395, 1.906508 }
won_heroics_local_pos[4] = { 8.151725, 0.186395, 1.397175 }
won_heroics_local_pos[5] = { 8.151633, 0.186395, 0.887843 }
won_heroics_local_pos[6] = { 8.148399, 0.186395, 0.34735 }
spells_local_pos = {}
spells_local_pos[1] = { -1.393784, 0.186396, 2.121494 }
spells_local_pos[2] = { -0.369069, 0.186396, 2.136242 }
spells_local_pos[3] = { 0.658648, 0.186396, 2.134193 }
spells_local_pos[4] = { 1.686339, 0.186396, 2.12854 }
spells_local_pos[5] = { 2.740341, 0.186396, 2.119081 }
link_spells_local_pos = {}
link_spells_local_pos[1] = { -1.393219, 0.186396, 4.027077 }
link_spells_local_pos[2] = { -0.368504, 0.186396, 4.041823 }
link_spells_local_pos[3] = { 0.659214, 0.186396, 4.039776 }
link_spells_local_pos[4] = { 1.686906, 0.186396, 4.034122 }
link_spells_local_pos[5] = { 2.740907, 0.186396, 4.024664 }
enchantment_spells_local_pos = {}
enchantment_spells_local_pos[1] = { 3.897315, 0.186396, 4.018102 }
enchantment_spells_local_pos[2] = { 4.975488, 0.186396, 4.017481 }
enchantment_spells_local_pos[3] = { 6.059778, 0.186396, 4.008014 }

spell_discards_local_pos = { 9.686725, 0.186396, 0.937226 }
used_alterations_local_pos = { 2.731754, 0.186396, -0.061831 }
drop_zone_local_pos = { -0.842196, -1.424986, -0.003841 }
dice_zone_local_pos = { 5.382422, -2.351135, 0.733407 }
dice_zone_size = {["x"]=6.015524,["y"]=5.1,["z"]=6.659328}
prestige_zone_local_pos = { 9.690072, -2.351135, 2.93751 }
prestige_zone_size = {["x"]=2.736159,["y"]=5.1,["z"]=2.836752}
acuity_restore_zone_local_pos = { 6.601711, -2.351135, -1.90781 }
acuity_restore_zone_size = {["x"]=3.37996,["y"]=5.1,["z"]=1.50891}
acuity_ruin_zone_local_pos = { 8.798397, -2.351135, -1.924995 }
acuity_ruin_zone_size = {["x"]=3.420197,["y"]=5.1,["z"]=1.508913}
spells_zone_local_pos = { 2.326385, -2.351134, 3.205592}
spells_zone_size = {["x"]=15.35225,["y"]=5.1,["z"]=6.884419}
spell_arcana_zone_local_pos = { 9.71008, -2.351135, 0.969723 }
spell_arcana_zone_size = {["x"]=1.64942,["y"]=5.1,["z"]=2.898976}
heroics_zone_local_pos = { 8.056143, -2.351134, 1.961139 }
heroics_zone_size = {["x"]=1.68,["y"]=5.1,["z"]=6.59}

mana_acuity_zone_local_pos = {x=0.9717337,y=-2.351134,z=-0.3036352}
mana_acuity_zone_size = {x=2.998749,y=5.1,z=2.524589}

card_decal_pos = {0,0.364,-1.124}
card_decal_rot = {90,180,0}
card_decal_scale = {0.97,0.81,11.54}
card_decals = {
  ["Restore"] = {
    ["name"] = "Restore",
    ["url"] = "http://cloud-3.steamusercontent.com/ugc/1742350294911075097/FDF248479EFF91425AB8D2AE1644D31DFE43ACB1/",
    ["position"] = card_decal_pos,
    ["rotation"] = card_decal_rot,
    ["scale"] = card_decal_scale,
  },
  ["Ruin"] = {
    ["name"] = "Ruin",
    ["url"] = "http://cloud-3.steamusercontent.com/ugc/1742350294911085021/5EC0CEF670A9546B1F593AA31434A02094AC5E5B/",
    ["position"] = card_decal_pos,
    ["rotation"] = card_decal_rot,
    ["scale"] = card_decal_scale,
  }
}

env = {}
C = {}
GD = {}
loading = true
action = "drop"
player_position_zone = nil

--[[ Game loading. ]]
function onLoad(saved_data)
  env = Global.getTable("env")
  C = Global.getTable("C")
  --self.interactable = false
  if saved_data ~= "" then
    if env.test.trace then log("Player Board " .. self.getName() .. " saved load") end
    local restore_data = JSON.decode(saved_data)
    GD = restore_data
    restoreBoardState()
  else
    if env.test.trace then log("Player Board " .. self.getName() .. " fresh load") end
    GD.states = {}
    GD.states.UI = {}
    GD.states.obj_vis = {}
    GD.board = {}
    GD.board.player_color = ""
    GD.board.initialized = false
    GD.board.player_position = 0  -- 1 to 4 when initialized
    GD.board.color_bar_guid = ""
    --spell cast stuff
    GD.board.power = {}
    GD.board.power.ruin = {}
    GD.board.power.ruin.dice = 0
    GD.board.power.ruin.acuity = 0
    GD.board.power.ruin.cards = 0
    GD.board.power.restore = {}
    GD.board.power.restore.dice = 0
    GD.board.power.restore.acuity = 0
    GD.board.power.restore.cards = 0
    GD.board.power.myst = 0
    --sigils stuff
    GD.board.sigils = {}
    GD.board.sigils.yellow = 0
    GD.board.sigils.green = 0
    GD.board.sigils.red = 0
    GD.board.sigils.blue = 0
    GD.board.sigils.wild = 0
    --scoring stuff (TODO)
    GD.board.scoring = {}
    GD.board.scoring.heroics = {}
    GD.board.scoring.spells = {}
    GD.board.scoring.arcanas = {}
    GD.board.scoring.values = {}
    GD.board.scoring.values.heroics = 0
    GD.board.scoring.values.sigils = 0
    GD.board.scoring.values.prestige = 0
    GD.board.scoring.values.arcanas = 0
  end
  loading = false
end

--[[ Restore this board's state during a load from saved data. ]]
function restoreBoardState()
  if env.test.trace then log(self.getName()..":restoreBoardState()") end
  if GD.board.initialized then
    setupBoard()
    if GD.board.active  then
      local color_bar = getObjectFromGUID(C.guids.color_bars[GD.board.player_position])
      color_bar.setInvisibleTo({})
      color_bar.UI.setAttribute("block_panel", "active", "true")
    end
  end
  --restore object visiblity
  for g,colors in pairs(GD.states.obj_vis) do
    local obj = getObjectFromGUID(g)
    if obj then
      obj.setInvisibleTo(colors)
    end
  end
  --restore UI state
  for key,value in pairs(GD.states.UI) do
    local id = Split(key, ':')[1]
    local field = Split(key, ':')[2]
    self.UI.setAttribute(id, field, value)
  end

  --TODO: buttons on cards do not survive save/laod.  Recreate.
    --  Workaround is just pickup the card and drop it.
    --  Decals DO save and restore.

end

--[[ Wrapper function for saving obj visiblity for game restore. ]]
  function setInvisibleTo(guid, colors)
    if env.test.trace then log("setInvisibleTo(): "..guid) end
    assert(type(guid) == 'string', "guid must be a string")
    assert(colors)
    getObjectFromGUID(guid).setInvisibleTo(colors)
    GD.states.obj_vis[guid] = colors
  end

--[[  Wrapper function for saving UI attributes for game restore. ]]
function UI_setAttribute(id, field, value)
  if env.test.trace and env.game.verbose then log(self.getName() .. ": UI_setAttribute()") end
  assert(type(id) == "string", "id must be a string")
  assert(type(field) == "string", "field must be a string")
  self.UI.setAttribute(id, field, value)
  GD.states.UI[id..":"..field] = value
end

--[[ Create script zones for this player board.
    Not sure they survive save/load so there is a
    check to see if they are there.  --]]
function createZones()
  if env.test.trace then log(self.getName() .. ": createZones()") end

  local p = {
    type              = 'ScriptingTrigger',
    sound             = false,
    snap_to_grid      = false,
  }
  -- cast board drop zone
  local drop_pos = self.positionToWorld(drop_zone_local_pos)
  p.position          = drop_pos
  p.scale             = {3.27755, 3, 3.59142}
  p.callback_function = function(obj)
    obj.setPosition(drop_pos)
    GD.board.class_board_drop_zone = obj.getGUID()
    end
  if getObjectFromGUID(GD.board.class_board_drop_zone) == nil then
    spawnObject(p)
  end
  --mana and acuity zones
  local mana_acuity_pos = self.positionToWorld(mana_acuity_zone_local_pos)
  p.position          = drop_pos
  p.scale             = {3.00, 5.1, 2.52}
  p.callback_function = function(obj)
    obj.setPosition(mana_acuity_pos)
    GD.board.class_board_mana_acuity_zone = obj.getGUID()
    end
  if getObjectFromGUID(GD.board.class_board_mana_acuity_zone) == nil then
    spawnObject(p)
  end
  --dice zone
  local dice_pos = self.positionToWorld(dice_zone_local_pos)
  p.position          = dice_pos
  p.scale             = dice_zone_size
  p.callback_function = function(obj)
    obj.setPosition(dice_pos)
    GD.board.dice_zone = obj.getGUID()
    obj.addTag("Dice")
    end
  if getObjectFromGUID(GD.board.dice_zone) == nil then
    spawnObject(p)
  end
  --prestige zone
  local prestige_pos = self.positionToWorld(prestige_zone_local_pos)
  p.position          = prestige_pos
  p.scale             = prestige_zone_size
  p.callback_function = function(obj)
    obj.setPosition(prestige_pos)
    GD.board.prestige_zone = obj.getGUID()
    end
  if getObjectFromGUID(GD.board.prestige_zone) == nil then
    spawnObject(p)
  end
  --acuity restore zone
  local acuity_restore_pos = self.positionToWorld(acuity_restore_zone_local_pos)
  p.position          = acuity_restore_pos
  p.scale             = acuity_restore_zone_size
  p.callback_function = function(obj)
    obj.setPosition(acuity_restore_pos)
    GD.board.acuity_restore_zone = obj.getGUID()
    end
  if getObjectFromGUID(GD.board.acuity_restore_zone) == nil then
    spawnObject(p)
  end
  --acuity ruin zone
  local acuity_ruin_pos = self.positionToWorld(acuity_ruin_zone_local_pos)
  p.position          = acuity_ruin_pos
  p.scale             = acuity_ruin_zone_size
  p.callback_function = function(obj)
    obj.setPosition(acuity_ruin_pos)
    GD.board.acuity_ruin_zone = obj.getGUID()
    end
  if getObjectFromGUID(GD.board.acuity_ruin_zone) == nil then
    spawnObject(p)
  end
  --spell cards zone
  local spells_zone_pos = self.positionToWorld(spells_zone_local_pos)
  p.position          = spells_zone_pos
  p.scale             = spells_zone_size
  p.callback_function = function(obj)
    obj.setPosition(spells_zone_pos)
    GD.board.spells_zone = obj.getGUID()
    end
  if getObjectFromGUID(GD.board.spells_zone) == nil then
    spawnObject(p)
  end
  --spell and arcana cards zone
  local spell_arcana_zone_pos = self.positionToWorld(spell_arcana_zone_local_pos)
  p.position          = spell_arcana_zone_pos
  p.scale             = spell_arcana_zone_size
  p.callback_function = function(obj)
    obj.setPosition(spell_arcana_zone_pos)
    GD.board.spell_arcana_zone = obj.getGUID()
    end
  if getObjectFromGUID(GD.board.spell_arcana_zone) == nil then
    spawnObject(p)
  end
  --heroics zone
  local heroics_zone_pos = self.positionToWorld(heroics_zone_local_pos)
  p.position          = heroics_zone_pos
  p.scale             = heroics_zone_size
  p.callback_function = function(obj)
    obj.setPosition(heroics_zone_pos)
    GD.board.heroics_zone = obj.getGUID()
    obj.addTag("Heroic")
    end
  if getObjectFromGUID(GD.board.heroics_zone) == nil then
    spawnObject(p)
  end
end

--[[ Save game state ]]
function onSave()
  local data_to_save = GD
  local saved_data = JSON.encode(data_to_save)
  if env.test.force_fresh_save then saved_data = "" end
  return saved_data
end

--[[ Handler for player "Done" button. ]]
function nextPlayerBtn(player, mouse, id)
  if env.test.trace then log(self.getName() .. ": nextPlayerBtn()") end
  if player.color == GD.board.player_color then
    UI_setAttribute("next_player_pnl", "active", "false")
    UI_setAttribute("cleanup_pnl", "active", "false")
    local color_bar = getObjectFromGUID(C.guids.color_bars[GD.board.player_position])
    color_bar.setInvisibleTo(Player.getColors())
    color_bar.UI.setAttribute("block_panel", "active", "false")
    GD.board.active = false
    Global.call("setNextPlayer")
  else
    broadcastToColor("Player " .. player.color .. ": " .. self.getName() .. " is not your class.", player.color)
  end
end

--[[ Handler for "Cleanup" button press.  Cleanup player board after a spell cast. ]]
function cleanupBtn(player, mouse, id)
  if env.test.trace then log(self.getName() .. ": cleanupBtn()") end
  if not(player.color == GD.board.player_color) then
    broadcastToColor("Player " .. player.color .. ": " .. self.getName() .. " is not your class.", player.color)
    return
  end
  local dice = {}
  local spells = {}
  local mana = {}
  local zone = getObjectFromGUID(GD.board.spells_zone)
  assert(zone, self.getName().." ERROR cleanupBtn() no board spell zone.")
  local stuff = zone.getObjects()
  for _,o in pairs(stuff) do
    if o.hasTag("Dice") then table.insert(dice, o)
    elseif o.hasTag("Mana") then table.insert(mana, o)
    elseif o.hasTag("Spell") then
      table.insert(spells, o)
      o.setDecals({})
      o.clearButtons()
    elseif o.hasTag("Acuity") then o.destruct()
    else
      if env.test.debug then log(self.getName().." cleanupBtn() Unknown object in zone: "..o.getGUID()) end
      if env.test.debug then log(o.getTags()) end
    end
  end
  action = "cleanup"
  local function place(list)
    if list[1] == nil then return end
    local obj = list[1]
    placeObject(obj)
    table.remove(list, 1)
    Wait.condition(
      function() place(list) end,
      function() return (obj.isDestroyed() or obj.resting) end)
  end
  place(dice)
  place(spells)
  place(mana)
  --delete an  acuity used for spell points
  for _,o in pairs(getObjectFromGUID(GD.board.acuity_ruin_zone).getObjects()) do
    if o.hasTag("Acuity") then o.destruct() end
  end
  for _,o in pairs(getObjectFromGUID(GD.board.acuity_restore_zone).getObjects()) do
    if o.hasTag("Acuity") then o.destruct() end
  end
  --give myst bonus if applicable
  if GD.board.power.myst >= 8 then
    local acuity_bag = getObjectFromGUID(C.guids.acuity_bag)
    if GD.board.power.myst >= 8 and GD.board.power.myst <= 9 then
      print(self.getName().." recieves one Acuity for Myst bonus")
      acuity_bag.takeObject({ callback_function = function(obj) placeObject(obj) end })
    elseif GD.board.power.myst >= 10 and GD.board.power.myst <= 11 then
      print(self.getName().." recieves two Acuity for Myst bonus")
      local function acuity()
        acuity_bag.takeObject({
          callback_function = function(obj) placeObject(obj) end
        })
      end
      Wait.time(function() acuity() end, .25, 2)
    elseif GD.board.power.myst >=12 then
      print(self.getName().." recieves two Acuity and one Prestigefor Myst bonus")
      local function acuity()
        acuity_bag.takeObject({
          callback_function = function(obj) placeObject(obj) end
        })
      end
      Wait.time(function() acuity() end, .25, 2)
      local prestige_bag = getObjectFromGUID(C.guids.prestige_bag)
      acuity_bag.takeObject({ callback_function = function(obj) placeObject(obj) end })
    end
  end
  --reset a bunch of stuff
  GD.board.power.restore.dice = 0
  GD.board.power.restore.acuity = 0
  GD.board.power.restore.cards = 0
  GD.board.power.ruin.dice = 0
  GD.board.power.ruin.acuity = 0
  GD.board.power.ruin.cards = 0
  GD.board.power.myst = 0
  UI_setAttribute("gross_restore_text_id", "text", "0")
  UI_setAttribute("gross_ruin_text_id", "text", "0")
  UI_setAttribute("net_restore_text_id", "text", "0")
  UI_setAttribute("net_ruin_text_id", "text", "0")
  UI_setAttribute("total_myst_text_id", "text", "0")
  UI_setAttribute("acuity_restore_text_id", "text", "0")
  UI_setAttribute("acuity_ruin_text_id", "text", "0")
  UI_setAttribute("score_text_id", "text", "0")
  UI_setAttribute("roll_dice_pnl", "active", "true")
end

--[[ Player dropped something on this board. --]]
objects_to_place = {}
function onCollisionEnter(hit_info)
  if loading then return end
  --if env.test.trace then log(self.getName() .. ":onCollisionEnter()") end
  if GD.board.initialized then
    local zone = getObjectFromGUID(GD.board.class_board_drop_zone)
    if zone == nil then
      log(self.getName()..":onCollisionEnter() ERROR: No drop zone")
    else
      for _,obj in pairs(zone.getObjects()) do
        if obj.getGUID() == hit_info.collision_object.getGUID() then
          action = "drop"
          if not(obj.hasTag("Spell")) then
            -- placeObject(obj)
            if objects_to_place[obj.getGUID()] == nil then objects_to_place[obj.getGUID()] = obj end
          end
        end
      end
      placeObjects(objects_to_place)
    end
  end
end

function placeObjects(list)
  -- log("placeObjects")
  -- log(list)
  if sizeOf(list) == 0 then return end
  for g,o in pairs(list) do
    if o then
      placeObject(o)
      list[g] = nil
      break;
    end
  end
  Wait.frames(function() placeObjects(list) end, 30)
end

--[[ Document --]]
function placeObject(obj)
  -- if env.test.trace then log(self.getName() .. ":placeObject() "..tostring(obj)) end
  if env.test.trace then log(self.getName() .. ":placeObject()") end
  local p = {
    origin       = {},
    direction    = {0,1,0},
    type         = 2,
    size         = {0.25,0.25,0.25},
    max_distance = 1,
    debug        = false,
  }
  --TODO: refactor common code
  if obj.hasTag("Mana") then
    local mana_acuity_zone = getObjectFromGUID(GD.board.class_board_mana_acuity_zone)
    mana_acuity_zone.setTags({"Mana"})
    local mana = mana_acuity_zone.getObjects()
    -- log("mana count in zone is "..tostring(#mana))
    if #mana == 10 then
      if env.test.debug then log(self.getName().." mana full, destroy Mana") end
      if env.game.verbose then print(self.getName().." Mana is full, throwing one away.") end
      obj.destroy()
    else
      local index = 1
      local looking = true
      while looking do
        p.origin = self.positionToWorld(mana_local_pos[index])
        local hits = Physics.cast(p)
        -- log(hits)
        local empty = true
        if hits ~= nil then
          for _,h in pairs(hits) do
            if h.hit_object.hasTag("Mana") then empty = false end
          end
          if empty then
            looking = false
            obj.setPosition(self.positionToWorld(mana_local_pos[index]))
            obj.setRotation({0,0,0})
          else
            index = index + 1
            if index > 10 then looking = false end
          end
        else
          log("ERROR: got no hits for mana index "..index) --shouldn't ever happen, table and tile will hit
        end
      end
    end
  elseif obj.hasTag("Acuity") then
    local mana_acuity_zone = getObjectFromGUID(GD.board.class_board_mana_acuity_zone)
    mana_acuity_zone.setTags({"Acuity"})
    local acuity = mana_acuity_zone.getObjects()
    -- log("acuity count in zone is "..tostring(#acuity))
    if #acuity == 10 then
      if env.test.debug then log(self.getName().." acuity full, destroy Acuity") end
      if env.game.verbose then print(self.getName().." Acuity is full, throwing one away.") end
      obj.destroy()
    else
      local index = 1
      local looking = true
      while looking do
        p.origin = self.positionToWorld(acuity_local_pos[index])
        local hits = Physics.cast(p)
        local empty = true
        if hits ~= nil then
          for _,h in pairs(hits) do
            local o = h.hit_object
            if o.hasTag("Acuity") then empty = false end
          end
          if empty then
            looking = false
            obj.setPosition(self.positionToWorld(acuity_local_pos[index]))
            obj.setRotation({0,0,0})
          else
            index = index + 1
            if index > 10 then looking = false end
          end
        else
          log("ERROR: got no hits for acuity index "..index) --shouldn't ever happen, table and tile will hit
        end
      end
    end
  elseif obj.hasTag("Dice") then
    local pos = scatter(self.positionToWorld(dice_zone_local_pos), {1.25,0,1.5}, {0.1,0,0.1})
    obj.setPositionSmooth(pos, false, true)
  elseif obj.hasTag("Spell") then
    if action == "drop" then
      log("--- TODO: Spell drop, locate best spell position for spell power?")
    elseif action == "cleanup" then
      local pos = Vector(self.positionToWorld(spell_discards_local_pos))
      pos.y = 3
      obj.setPositionSmooth(pos, false, true)
    end
  elseif obj.hasTag("Arcana") then
    local pos = Vector(self.positionToWorld(spell_discards_local_pos))
    local rot = obj.getRotation()
    rot.y = rot.y + 90
    pos.y = 3
    obj.setPositionSmooth(pos, false, true)
    obj.setRotation(rot)
  elseif obj.hasTag("Heroic") then
    local index = 0
    for i=1,5 do
      local h = getCardByTag(won_heroics_local_pos[i+1], "Heroic")
      if h == nil then
        index = i
        break
      end
    end
    if index == 0 then index = 5 end
    local pos = self.positionToWorld(won_heroics_local_pos[index])
    pos.y = 2
    pos.x = pos.x - 0.2 --HACK: why is snap not working?
    pos.z = pos.z - 0.1 --HACK: why is snap not working?
    obj.setPositionSmooth(pos, false, false)
    Wait.condition(
      function() updateScore() end,
      function() return obj.isDestroyed() or obj.resting end )
  elseif obj.hasTag("Alteration") or obj.hasTag("Artifact") then
    obj.deal(1, GD.board.player_color)
    -- Wait.time(function() updateScore() end, 1)  --This is now done when card enters hand zone
  elseif obj.hasTag("Prestige") then
    local pos = self.positionToWorld(prestige_zone_local_pos)
    obj.setPositionSmooth(pos, false, true)
  else
    log("ERROR: unhandled object")
  end
end

--[[ Handler for player selecting (dropping) this board.
    Call Global to check conditions and assign playerboard & position to player. ]]
function onDrop(player_color)
  if env.test.trace then log(self.getName().." onDrop()") end
  for i=1,4 do
    local zone_guid = C.guids.board_zones[i]
    z = getObjectFromGUID(zone_guid)
    if z ~= nil then
      for _,o in pairs(z.getObjects()) do
        if o.getGUID() == self.getGUID() then
          player_position_zone = z
          --ensure tile is in range to be snapped by moving to center of zone
          local pos = z.getPosition()
          local new_pos = o.getPosition()
          new_pos.x = pos.x
          new_pos.z = pos.z
          new_pos.y = 3
          o.setPosition(new_pos)
          --setup teh board & player area after it's settled in position
          if env.test.debug then log(self.getName()..":"..self.getGUID().." dropped in position "..tostring(i).." by "..player_color) end
          local board_guid = self.getGUID()
          Wait.condition(
            function() Global.call("setPlayerClass",{
              player = player_color,
              guid = board_guid,
              position = i,
              home_position = home_position,
            }) end,
            function() return self.resting end
          )
          break;
        end
      end
    else
      log("No player position zone here")
    end
  end
end

--[[ Called from Global after it checks to ensure player has not already selected a class.
      Sets up player for this class.  ]]
function setPlayer(params)
  if env.test.trace then log(self.getName() .. ": setPlayer()") end
  assert(params.player)
  assert(params.position)
  if player_position_zone ~= nil then player_position_zone.destruct() end
  self.setLock(true)
  self.interactable = false
  GD.board.player_color = params.player
  GD.board.player_position = params.position
  createZones()
  UI_setAttribute("class_select_pnl", "active", "false")
  local deck = getObjectFromGUID(start_deck)
  card_count = #deck.getObjects()
  deck.deal(card_count, GD.board.player_color)
  deck = getObjectFromGUID(C.guids.artifacts_deck)
  deck.deal(artifact_cards, GD.board.player_color)
  if take_myst_rune then
    --get the myst rune and move it to Mystcaller
    local guid = Global.call("getMystRuneGuid")
    local pos = self.getPosition()
    pos[1] = pos[1] - 4
    local rune = getObjectFromGUID(guid)
    rune.setPositionSmooth(pos, false, false)
    rune.setRotation(C.rot.myst_rune)
  end
  color_bar = getObjectFromGUID(C.guids.color_bars[GD.board.player_position])
  color_bar.UI.setAttribute("block_text_id", "text", self.getName())
  color_bar.setColorTint(GD.board.player_color)
  color_bar.setInvisibleTo({})
  UI_setAttribute("gross_restore_panel", "active", "true")
  UI_setAttribute("gross_ruin_panel", "active", "true")
  UI_setAttribute("net_restore_panel", "active", "true")
  UI_setAttribute("net_ruin_panel", "active", "true")
  UI_setAttribute("total_myst_panel", "active", "true")
  UI_setAttribute("dice_restore_panel", "active", "true")
  UI_setAttribute("dice_ruin_panel", "active", "true")
  UI_setAttribute("acuity_restore_panel", "active", "true")
  UI_setAttribute("acuity_ruin_panel", "active", "true")
  UI_setAttribute("update_spell_pnl", "active", "true")
  UI_setAttribute("score_panel", "active", "true")
  UI_setAttribute("roll_dice_pnl", "active", "true")
  UI_setAttribute("yellow_sigils_panel", "active", "true")
  UI_setAttribute("green_sigils_panel", "active", "true")
  UI_setAttribute("red_sigils_panel", "active", "true")
  UI_setAttribute("blue_sigils_panel", "active", "true")
  UI_setAttribute("wild_sigils_panel", "active", "true")
  --Starting dice
  local dice_bag = getObjectFromGUID(C.guids.dice_bag)
  local function dice()
    dice_bag.takeObject({
      callback_function = function(obj)
        obj.setValue(math.random(1,6))
        placeObject(obj)
      end
    })
  end
  Wait.time(function() dice() end, .25, start_dice)
  --Starting mana
  local mana_bag = getObjectFromGUID(C.guids.mana_bag)
  local function mana()
    mana_bag.takeObject({
      callback_function = function(obj) placeObject(obj) end
    })
  end
  Wait.time(function() mana() end, .25, start_mana)
  --Starting acuity
  if start_acuity > 0 then
    local acuity_bag = getObjectFromGUID(C.guids.acuity_bag)
    local function acuity()
      acuity_bag.takeObject({
        callback_function = function(obj) placeObject(obj) end
      })
    end
    Wait.time(function() acuity() end, .25, start_acuity)
  end
  GD.board.sigils[board_sigil] = 1
  UI_setAttribute(board_sigil.."_sigils_text","text","1")
end

--[[ Called from Global during player setup or when player types a number over a bag. ]]
function dealItems(params)
  if env.test.trace then log(self.getName() .. ": dealAcuity()") end
  assert(params.item_type)
  assert(params.amount)
  local bag
  local function endTrigger() end
  if params.item_type == "acuity" then
    bag = getObjectFromGUID(C.guids.acuity_bag)
    endTrigger = function() updateSpellPower() end
  elseif params.item_type == "mana" then
    bag = getObjectFromGUID(C.guids.mana_bag)
  elseif params.item_type == "prestige" then
    bag = getObjectFromGUID(C.guids.prestige_bag)
    endTrigger = function() updateScore() end
  else
    log(self.getName().." ERROR: unknown item type, cannot deal.")
    return
  end
  if env.test.debug then log(self.getName().." placing "..params.amount .." "..params.item_type) end
  local count = 0
  local function deal()
      bag.takeObject({
      callback_function = function(obj)
        placeObject(obj)
        count = count + 1
        if count == params.amount then
          Wait.time(endTrigger, 1)
        end
      end
    })
  end
  Wait.time(function() deal() end, .25, params.amount)
end

--[[ Called from Global when this player is active. ]]
function enableActivePlayer()
  if env.test.trace then log(self.getName() .. ": enableActivePlayer()") end
  UI_setAttribute("next_player_pnl", "active", "true")
  UI_setAttribute("cleanup_pnl", "active", "true")
  local color_bar = getObjectFromGUID(C.guids.color_bars[GD.board.player_position])
  color_bar.setInvisibleTo({})
  color_bar.UI.setAttribute("block_panel", "active", "true")
  GD.board.active = true
end

--[[ Called from Global after all players have selected a class.  Also may be called during game restore.
      If this board is unnassigned, clear all the stuff for it (dice etc.) from the game. ]]
function setupBoard()
  if env.test.trace then log(self.getName() .. ": setupBoard()") end
  if GD.board.player_color == "" then
    --unasigned, delete this board
      getObjectFromGUID(start_deck).destruct()
      self.destruct()
  else
    -- createZones()
    GD.board.initialized = true
    GD.board.active = false
    local color_bar = getObjectFromGUID(C.guids.color_bars[GD.board.player_position])
    color_bar.setInvisibleTo(Player.getColors())
    color_bar.UI.setAttribute("block_panel", "active", "false")
  end
end

--[[ Return a table with unallocated dice values. --]]
function getUnallocatedDiceValues()
  local dice_zone = getObjectFromGUID(GD.board.dice_zone)
  if dice_zone == nil then
    log(self.getName().." getUnallocatedDiceValues(): ERROR: Attempt to get dice but zone is nil.")
    return {}
  end
  local objects = dice_zone.getObjects()
  local result = {}
  for _,o in pairs(objects) do
    if o.hasTag("Dice") then
      --result[o.getGUID()] = o.getRotationValue()
      table.insert(result, o.getRotationValue())
    end
  end
  return result
end

--[[ Return a count of unused acuity on the player class board. --]]
function getUnusedAcuityCount()
  local p = {
    origin       = {},
    direction    = {0,1,0},
    type         = 2,
    size         = {0.25,0.25,0.25},
    max_distance = 1,
    debug        = false,
  }
  local count = 0
  for i=1,10 do
    p.origin = self.positionToWorld(acuity_local_pos[i])
    local hits = Physics.cast(p)
    if hits ~= nil then
      for _,h in pairs(hits) do
        if h.hit_object.hasTag("Acuity") then count = count + 1 end
      end
    end
  end
  return count
end

--[[ Button handler to trigger spell power update --]]
function updateSpellPowerBtn(player, mouse, id)
  local pcol = player.color
  if env.test.trace then log(self.getName() .. ": updateSpellPowerBtn() "..pcol) end
  if player.color == GD.board.player_color then
    updateSpellPower()
  end
end

--[[ Calculate spell power for this player board and update UI elements --]]
function updateSpellPower()
  if env.test.trace then log(self.getName() .. ": updateSpellPower()") end
  local total_restore = 0
  local total_ruin = 0
  local total_myst = 0
  GD.board.power.myst = 0

  --update power contribution by unused dice
  GD.board.power.ruin.dice = 0
  GD.board.power.restore.dice = 0
  for _,d in pairs(getUnallocatedDiceValues()) do
    if dice_translation[d] == "ruin" then
      GD.board.power.ruin.dice = GD.board.power.ruin.dice + 1
    elseif dice_translation[d] == "restore" then
      GD.board.power.restore.dice = GD.board.power.restore.dice + 1
    end
  end
  UI_setAttribute("dice_restore_text_id", "text", tostring(GD.board.power.restore.dice))
  UI_setAttribute("dice_ruin_text_id", "text", tostring(GD.board.power.ruin.dice))

  --uppdate power contributed by acuity spaces
  GD.board.power.restore.acuity = 0
  local acuity_restore_zone = getObjectFromGUID(GD.board.acuity_restore_zone)
  local acuity_count = 0
  for _,o in pairs(acuity_restore_zone.getObjects()) do
    if o.hasTag("Acuity") then
      acuity_count = acuity_count + 1
    end
  end
  if acuity_count > 0 then
    GD.board.power.restore.acuity = math.modf(acuity_count/3)
  else
    GD.board.power.restore.acuity = 0
  end
  UI_setAttribute("acuity_restore_text_id", "text", tostring(GD.board.power.restore.acuity))
  GD.board.power.ruin.acuity = 0
  local acuity_ruin_zone = getObjectFromGUID(GD.board.acuity_ruin_zone)
  local ruin_count = 0
  for _,o in pairs(acuity_ruin_zone.getObjects()) do
    if o.hasTag("Acuity") then
      ruin_count = ruin_count + 1
    end
  end
  if ruin_count > 0 then
    GD.board.power.ruin.acuity = math.modf(ruin_count/4)
  else
    GD.board.power.ruin.acuity = 0
  end
  UI_setAttribute("acuity_ruin_text_id", "text", tostring(GD.board.power.ruin.acuity))

  --update power from spell cards
  GD.board.power.restore.cards = 0
  GD.board.power.ruin.cards = 0
  for i=1,5 do
    local card = getCardByTag(spells_local_pos[i], "Spell")
    if card ~= nil then
      --TODO: confirm this is a base spell card & warn if not
      if env.test.debug then log("Getting power for card "..card.getGUID()) end
      local restore, ruin = getSpellPower(card)
      if restore > 0 and ruin > 0 then
        if card.memo ~= nil then
          if card.memo == "Ruin" then
            GD.board.power.ruin.cards = GD.board.power.ruin.cards + ruin
          elseif card.memo == "Restore" then
            GD.board.power.restore.cards = GD.board.power.restore.cards + restore
          else
            log(self.getName().." ERROR: unexpected memo value on card "..card.getGUID())
          end
        end
      else
        GD.board.power.restore.cards = GD.board.power.restore.cards + restore
        GD.board.power.ruin.cards = GD.board.power.ruin.cards + ruin
      end
    end
  end

    --calculate totals
  total_restore = total_restore + GD.board.power.restore.dice
  total_restore = total_restore + GD.board.power.restore.acuity
  total_restore = total_restore + GD.board.power.restore.cards
  total_ruin = total_ruin + GD.board.power.ruin.dice
  total_ruin = total_ruin + GD.board.power.ruin.acuity
  total_ruin = total_ruin + GD.board.power.ruin.cards
  --handle any enchantment card effects, in order of position
  local spells = Global.getTable("spells")
  for i=1,3 do
    local card = getCardByTag(enchantment_spells_local_pos[i], "Spell")
    if card ~= nil then
      if env.test.debug then log("Process enchantment for card "..card.getGUID()) end
      local data = spells[tonumber(card.getGMNotes())]
      if env.test.debug then log(data) end
      if data.enchant ~= nil then
        if data.enchant.ruin > 0 then
          total_ruin = total_ruin + (total_restore * data.enchant.ruin)
          total_restore = 0
        elseif data.enchant.restore > 0 then
          total_restore = total_restore + (total_ruin * data.enchant.restore)
          total_ruin = 0
        else
          log(self.getName().." ERROR: unexpected enchantment type")
        end
      else
        log(self.getName().." WARN: non-enchantment spell in enchantment space.")
        broadcastToColor((self.getName().." has a non-enchantment spell in an enchantment space."), GD.board.player_color)
      end
    end
  end
  --check for equilibrium or calculate net if not
  local net_restore = total_restore - total_ruin
  local net_ruin = total_ruin - total_restore
  if total_restore > 0 and total_restore == total_ruin then
    total_myst = total_restore
    --transform net restore/ruin from myst
    if total_myst >=6 and total_myst <=7 then
      net_restore = 15
      net_ruin = 11
    elseif total_myst >=8 and total_myst <=9 then
      net_restore = 21
      net_ruin = 16
    elseif total_myst >=10 and total_myst <=11 then
      net_restore = 28
      net_ruin = 20
    elseif total_myst >= 12 then
      net_restore = 34
      net_ruin = 24
    end
    GD.board.power.myst = total_myst
  else
    if net_restore < 0 then net_restore = 0 end
    if net_ruin < 0 then net_ruin = 0 end
  end
  --update UI
  UI_setAttribute("gross_restore_text_id", "text", tostring(total_restore))
  UI_setAttribute("gross_ruin_text_id", "text", tostring(total_ruin))
  UI_setAttribute("net_restore_text_id", "text", tostring(net_restore))
  UI_setAttribute("net_ruin_text_id", "text", tostring(net_ruin))
  UI_setAttribute("total_myst_text_id", "text", tostring(total_myst))
end

--[[ Called from global on spell card drop by player for this board.
Triggers spell power update if dropped in board's spell card zone. --]]
function spellDrop(params)
  if env.test.trace then log(self.getName() .. ": spellDrop()") end
  local card_guid = params.guid
  local card = getObjectFromGUID(card_guid)
  if card == nil then
    --card could be in a deck already??? unlikely but log it for debug
    log(self.getName().." spellDrop() WARN: Player dropped card "..card_guid.." but object is nil now.")
    return
  end
  local spells = Global.getTable("spells")
  local data = spells[tonumber(card.getGMNotes())]
  assert(data, "ERROR: "..self.getName()..": spellDrop(): no data found for card, "..card.getGUID())
  local z = getObjectFromGUID(GD.board.spells_zone)
  for _,o in pairs(z.getObjects()) do
    if o.getGUID() == card_guid then
      Wait.condition(
        function()
          if data ~= nil and not(card.isDestroyed()) then --avoid cases of link spells in a deck
            if data.option then
              if card.memo ~= nil then
                --Set decal based on previous setting stored in card memo
                if card.memo == "Restore" then
                  card.addDecal(card_decals["Restore"])
                elseif card.memo == "Ruin" then
                  card.addDecal(card_decals["Ruin"])
                else
                  log(self.getName().." ERROR: unexpected memo value on card "..card.getGUID())
                end
              else
                --Default initial decal by which card spell power is greater right now
                if GD.board.power.ruin.cards > GD.board.power.restore.cards then
                  card.addDecal(card_decals["Ruin"])
                  card.memo = "Ruin"
                else
                  card.addDecal(card_decals["Restore"])
                  card.memo = "Restore"
                end
              end
              createCardButton(card)
            end
          end
          updateSpellPower()
        end,
        function() return( card.isDestroyed() or card.resting) end)
      return
    end
  end
end

--[[ Create a button on an option spell card to toggle it's type --]]
function createCardButton(card)
  assert(card)
  if card ~= nil then
    params = {
      click_function = "cardButton",
      function_owner = self,
      label          = "",
      position       = {0,1,-1},
      rotation       = {0,180,0},
      width          = 400,
      height         = 200,
      color          = {0,0,0,0},
      hover_color    = {0,0,0,0},
      press_color    = {0,0,0,0},
    }
    card.createButton(params)
  end
end
function t_createCardButton(params)
  assert(params)
  local card_guid = params.guid
  assert(card_guid)
  local card = getObjectFromGUID(card_guid)
  assert(card)
  createCardButton(card)
end

--[[ Button handler for card type toggle button ]]
function cardButton(card, player_color, mouse)
  local decals = card.getDecals()
  if decals ~= nil then
    card.setDecals({})
    if decals[1].name == "Restore" then
      card.addDecal(card_decals["Ruin"])
      card.memo = "Ruin"
    elseif decals[1].name == "Ruin" then
      card.addDecal(card_decals["Restore"])
      card.memo = "Restore"
    else
      log(self.getName().."cardButton() ERROR: unidentified decal on card")
    end
    updateSpellPower()
  end
end

--[[ Called from global on acuity drop by player for this board.
Triggers spell power update if dropped in board's restore or ruin zone. --]]
function acuityDrop(params)
  if env.test.trace then log(self.getName() .. ": acuityDrop()") end
  local acuity_guid = params.guid
  local z = getObjectFromGUID(GD.board.acuity_restore_zone)
  for _,o in pairs(z.getObjects()) do
    if o.getGUID() == acuity_guid then
      updateSpellPower()
      return
    end
  end
  z = getObjectFromGUID(GD.board.acuity_ruin_zone)
  for _,o in pairs(z.getObjects()) do
    if o.getGUID() == acuity_guid then
      updateSpellPower()
      return
    end
  end
end

--[[ Process a given spell card and
return the restore power and ruin power of the card. --]]
function getSpellPower(card)
  if env.test.trace then log(self.getName() .. ": getSpellPower()") end
  assert(card, self.getName().." getSpellPower(): card object is missing")
  if env.test.debug then log(card) end
  if not(card.hasTag("Spell")) then
    if env.test.debug then log(self.getName() .. ": getSpellPower(): Not a spell card, "..card.getGUID()) end
    return
  end
  local spells = Global.getTable("spells")
  local data = spells[tonumber(card.getGMNotes())]
  if env.test.debug then log("data:") end
  if env.test.debug then log(data) end
  if data == nil then
    if env.test.debug then log("ERROR: no data for card "..card.getGUID()) end
    return
  end
  local restore = 0
  local ruin = 0

  --If this is a base spell, calculate restore and ruin power
  if data.base ~= nil then
    if env.test.debug then log("Spell is a base spell") end
    restore = data.base.restore
    ruin = data.base.ruin
    if env.test.debug then log("check for aether") end
    if data.aether ~= nil then
      if env.test.debug then log("this base spell has an Aether mod`") end
      if hasAether() then
        restore = data.aether.restore
        ruin = data.aether.ruin
      end
    end

  --if this is a card count spell, get ruin and restore power based on number of spell cards
  elseif data.count ~= nil then
    if env.test.debug then log("spell is a card count spell") end
    local count = getSpellCount()
    if env.test.debug then log("card count is "..count) end
    if data.aether ~= nil and hasAether() then
      if env.test.debug then log("counting aether * cards") end
      if data.aether.restore ~= nil and data.aether.restore > 0 then
        restore = data.aether.restore * count
      elseif data.aether.ruin ~= nil and data.aether.ruin > 0 then
        ruin = data.aether.ruin * count
      else
        log(self.getName()..": ERROR invalid spell card aether count data, "..card.getGUID())
      end
    else
      if env.test.debug then log("counting count * cards") end
      if data.count.restore ~= nil and data.count.restore > 0 then
        restore = data.count.restore * count
      elseif data.count.ruin ~= nil and data.count.ruin > 0 then
        ruin = data.count.ruin * count
      else
        log(self.getName()..": ERROR invalid spell card count data, "..card.getGUID())
      end
    end

  --if this is an acuity count spell, get ruin or restore based on acuity on cast board
  elseif data.acuity ~= nil then
    if env.test.debug then log("Spell is acuity count spell") end
    local count = getUnusedAcuityCount()
    if data.acuity.restore > 0 then
      restore = count
    elseif data.acuity.ruin > 0 then
      ruin = count
    end
  end
  if env.test.debug then log("core spell restore power: "..restore) end
  if env.test.debug then log("core spell ruin power: "..ruin) end

  --Now check any link spells matching this spell card location
  local pos = 0
  for i=1,5 do
    local c = getCardByTag(spells_local_pos[i], "Spell")
    if c ~= nil then
      if c.getGUID() == card.getGUID() then
        pos = i
        break;
      end
    end
  end
  if env.test.debug then log("Checking for link spell(s) modifiers") end
  local spells = Global.getTable("spells")
  if pos>0 then
    local link_spells = getCardByTag(link_spells_local_pos[pos], "Spell")
    if link_spells ~= nil then
      if env.test.debug then log("Position "..pos.." has link spell(s)") end
      if link_spells.tag == "Deck" then
        if env.test.debug then log("More than one link spell") end
        for _,o in pairs(link_spells.getObjects()) do
          local link_data = spells[tonumber(o.gm_notes)]
          if env.test.debug then log(link_data) end
          if link_data ~= nil and link_data.link ~= nil then
            --TODO: confirm this is a link card and warn if not
            if link_data.link.aether ~= nil and hasAether() then
              restore = restore * link_data.link.aether
              ruin = ruin * link_data.link.aether
            else
              restore = restore * link_data.link.base
              ruin = ruin * link_data.link.base
            end
          end
        end
      elseif link_spells.tag == "Card" then
        local link_data = spells[tonumber(link_spells.getGMNotes())]
        if env.test.debug then log(link_data) end
        if link_data ~= nil and link_data.link ~= nil then
            --TODO: confirm this is a link card and warn if not
            if link_data.link.aether ~= nil and hasAether() then
            restore = restore * link_data.link.aether
            ruin = ruin * link_data.link.aether
          else
            restore = restore * link_data.link.base
            ruin = ruin * link_data.link.base
          end
        end
      end
    end
  end
  if env.test.debug then
    log("Spell "..card.getGUID().." total restore: "..tostring(restore))
    log("Spell "..card.getGUID().." total ruin: "..tostring(ruin))
  end
  return restore, ruin
end
function t_getSpellPower(params)
  assert(params.guid)
  local card = getObjectFromGUID(params.guid)
  return getSpellPower(card)
end

--[[ Support function.  Return a card object with specified tag at specified local location.
NOTE: Location must be local to self, not world!
Returns nil if nothing found.
Parameters:
  pos: Local to self Vector of location to search.
  tag: The tag of the card object to filter on.
  debug: Optional flag, defaults to false.
--]]
function getCardByTag(pos, tag, debug)
  if env.test.trace then log(self.getName() .. ": getCardByTag()") end
  assert(tag)
  assert(type(pos) == "table")
  assert(#pos == 3)
  if debug == nil then debug = false end
  local world_pos = self.positionToWorld(pos)
  local p = {
    origin       = world_pos,
    direction    = {0,1,0},
    type         = 2,
    size         = {0.25,0.25,0.25},
    max_distance = 1,
    debug        = debug,
  }
  local hits = Physics.cast(p)
  local card = nil
  if hits ~= nil then
    for _,h in pairs(hits) do
      if h.hit_object.hasTag(tag) then
        card = h.hit_object
        break
      end
    end
  end
  return card
end
function t_getCardByTag(params)
  assert(params.index)
  assert(params.tag)
  local pos = spells_local_pos[params.index]
  return getCardByTag(pos, params.tag)
end

--[[ Return the count of active spell cards. --]]
function getSpellCount()
  if env.test.trace then log(self.getName() .. ": getSpellCount()") end
  local spell_zone = getObjectFromGUID(GD.board.spells_zone)
  local count = 0
  for _,o in pairs(spell_zone.getObjects()) do
    if o.hasTag("Spell") then count = count + 1 end
  end
  return count
end

--[[ Return true if the player has any Aether. --]]
function hasAether()
  if env.test.trace then log(self.getName() .. ": hasAether()") end
  if self.getName() == "Acranist" then return true end
  local dice_zone = getObjectFromGUID(GD.board.dice_zone)
  local spell_zone = getObjectFromGUID(GD.board.spells_zone)
  for _,o in pairs(dice_zone.getObjects()) do
    if o.hasTag("Dice") then
      if o.getRotationValue() == 3 then return true end
    end
  end
  for _,o in pairs(spell_zone.getObjects()) do
    if o.hasTag("Dice") then
      if o.getRotationValue() == 3 then return true end
    end
  end
  return false
end

--[[ Button handler to updater score --]]
function updateScoreBtn(player, mouse, id)
  if env.test.trace then log(self.getName() .. ": updateScoreBtn() "..player.color) end
  if player.color == GD.board.player_color then
    updateScore()
  end
end

--[[ Calculate current score adn update display --]]
function updateScore()
  if env.test.trace then log(self.getName() .. ": updateScore()") end
  local sigils = { red = 0, blue = 0, green = 0, yellow = 0 }
  local heroics_score = 0
  local prestige_score = 0
  local arcanas_score = 0
  local sigil_score = 0
  GD.board.scoring.spells = {}
  GD.board.scoring.heroics = {}
  GD.board.scoring.arcanas = {}
  local heroics_data = Global.getTable("heroics")
  --Herocis scoring
  local heroics_zone = getObjectFromGUID(GD.board.heroics_zone)
  if heroics_zone != nil then
    local heroics = heroics_zone.getObjects()
    for _,h in pairs(heroics) do
      if h.hasTag("Heroic") then
        if env.test.debug then log("---  Heroic card id: "..h.getGMNotes()) end
        local data = heroics_data[tonumber(h.getGMNotes())]
        if data then
          heroics_score = heroics_score + data.vp
          for _,sigil in ipairs(data.sigils) do sigils[sigil] = sigils[sigil] + 1 end
        else
          log("ERROR: "..self.getName()..": updateScore(): no data found for Heroic card, "..h.getGUID())
        end
      else
        log("WARN: "..self.getName()..": updateScore(): ignoring unknown object found in Heroics stack, "..h.getGUID())
      end
    end
  else
    log("ERROR: "..self.getName()..": heroics zone not found")
  end
  if env.test.debug then log("Heroics score: "..heroics_score) end
  GD.board.scoring.values.heroics = heroics_score
  --count sigils on alteration cards in hand
  local hand = Player[GD.board.player_color].getHandObjects(index)
  local card_data = Global.getTable("alterations")
  for _,c in ipairs(hand) do
    local data = card_data[tonumber(c.getGMNotes())]
    if data then
      for _,sigil in ipairs(data.sigils) do
        sigils[sigil] = sigils[sigil] + 1
      end
    end
  end
  --count sigils on alteration cards in spent pile
  local pos = self.positionToWorld(used_alterations_local_pos)
  local spent = findObject(pos, {"Deck", "Card"}, env.test.debug)
  if spent then
    if spent.tag == "Deck" then
      for _,c in ipars(spent.getObjects()) do
        local data = card_data[tonumber(c.gm_notes)]
        if data then
          for _,sigil in ipairs(data.sigils) do
            sigils[sigil] = sigils[sigil] + 1
          end
        end
      end
    elseif spent.tag == "Card" then
      local data = card_data[tonumber(spent.getGMNotes())]
      if data then
        for _,sigil in ipairs(data.sigils) do
          sigils[sigil] = sigils[sigil] + 1
        end
      end
    end
  end
  --Add sigil for player class board
  if board_sigil == "wild" then
    -- try to make a 3 of a kind first, then a pair or 3+ if possible
    local done = false
    for sigil,count in pairs(sigils) do
      if count == 2 then
        sigils[sigil] = sigils[sigil] + 1
        done = true
        break
      end
    end
    if not(done) then
      for sigil,count in pairs(sigils) do
        if count == 1 or count > 2 then
          sigils[sigil] = sigils[sigil] + 1
          break
        end
      end
    end
  else
    sigils[board_sigil] = sigils[board_sigil] + 1
  end
  --Sigil scoring
  log(sigils)
  for sigil,count in pairs(sigils) do
    GD.board.sigils[sigil] = count
    UI_setAttribute(sigil.."_sigils_text", "text", tostring(count))
    c = math.modf(count/3)
    if c > 0 then
      sigil_score = sigil_score + (3 * c)
    else
      c = math.modf(count/2)
      if c > 0 then
        sigil_score = sigil_score + c
      end
    end
  end
  log("Sigil score: "..sigil_score)
  GD.board.scoring.values.sigils = sigil_score
  --Prestige token scoring
  local prestige_zone = getObjectFromGUID(GD.board.prestige_zone)
  for _,o in pairs(prestige_zone.getObjects()) do
    if o.hasTag("Prestige") then
      prestige_score = prestige_score + 1
    end
  end
  log("Prestige score: "..prestige_score)
  GD.board.scoring.values.prestige = prestige_score
  --Arcana scoring
  local spells = {}
  local arcanas = {}
  local z = getObjectFromGUID(GD.board.spell_arcana_zone)
  for _,o in pairs(z.getObjects()) do
    if o.hasTag("Spell") then
      if o.tag == "Deck" then
        for _,c in pairs(o.getObjects()) do
          spells[c.guid] = JSON.decode(c.gm_notes)
          GD.board.scoring.spells[c.guid] = c.gm_notes
        end
      else
        spells[o.getGUID()] = JSON.decode(o.getGMNotes())           --TODO: fix GMNotes
        GD.board.scoring.spells[o.getGUID()] = o.getGMNotes()       --TODO: fix GMNotes
      end
    elseif o.hasTag("Arcana") then
      table.insert(arcanas, o)
      GD.board.scoring.arcanas[o.getGUID()] = o.getName()
    else
      log("WARN: ignoring object "..o.getGUID().." in spell/arcana pile.")
    end
  end
  log("found "..sizeOf(spells).." spell cards")
  log("found "..#arcanas.." arcana cards")
  local arcana_data
  for _,arcana in pairs(arcanas) do
    if arcana.is_face_down then
      arcana_data = C.arcanas[arcana.getGUID()].face_down.reward
    else
      arcana_data = C.arcanas[arcana.getGUID()].face_up.reward
    end
    log("Scoring arcana: ")
    log(arcana_data)
    local count = 0
    if arcana_data.spell_type == "aether_mod" then
      for _,s in pairs(spells) do
        if s.aether_mod then
          count = count + 1
        end
      end
    elseif arcana_data.spell_type == "not_aether" then
      for _,s in pairs(spells) do
        if not(s.aether_mod) then
          count = count + 1
        end
      end
    elseif arcana_data.spell_type == "slot_count" then
      for _,s in pairs(spells) do
        if s.slots >= 4 then
          count = count + 1
        end
      end
    else
      for _,s in pairs(spells) do
        if arcana_data.spell_type == "any" or
        contains(s.dice, arcana_data.spell_type) then
          count = count + 1
        end
      end
    end
    log("Number spells matching arcana "..arcana.getName().." condition = "..count)
    local n = math.modf(count/arcana_data.count)
    log(arcana.getName().." score is "..(n * arcana_data.vp))
    arcanas_score = arcanas_score + (n * arcana_data.vp)
  end
  --Add in arcana bonus for number of players == 3 or 4
  local player_count = Global.call("getPlayerCount", {})
  if player_count == 3 then
    log("Arcana player count bonus = "..#arcanas)
    arcanas_score = arcanas_score + #arcanas
  elseif player_count == 4 then
    log("Arcana player count bonus = "..(#arcanas * 2))
    arcanas_score = arcanas_score + (#arcanas * 2)
  end
  log("total arcana score including player count bonus: "..arcanas_score)
  GD.board.scoring.values.arcanas = arcanas_score

  local score = heroics_score + sigil_score + prestige_score + arcanas_score
  UI_setAttribute("score_text_id", "text", tostring(score))
end

--[[ Handler for the roll dice button.  --]]
--TODO: add xml UI for this, hide button after rolling, show button when cleanup button is hit  DONE???
function rollAllDiceBtn(player, mouse, id)
  if player.color == GD.board.player_color then
    if env.test.trace then log(self.getName().." rollAllDice()") end
    UI_setAttribute("roll_dice_pnl", "active", "false")
    local z = getObjectFromGUID(GD.board.dice_zone)
    if z ~= nil then
      for _,d in pairs(z.getObjects()) do d.roll() end
      Wait.condition(
        function() updateSpellPower() end,
        function()
          local resting = true
          for _,d in pairs(z.getObjects()) do resting = resting and d.resting end
          return resting
        end
      )
    else
      log(self.getName().." ERROR: no dice zone for guid "..GD.board.dice_zone)
    end
  end
end

--[[ Called from Global when a player randomizes (rolls) one or more die by
  selecting them and hitting the 'r' button or uses the roll context menu.
  Wait on all dice player's dice area to be at rest, then update the spell.
--]]
waiting_on_dice = false
function waitOnDiceRoll()
  if waiting_on_dice then return end
  if env.test.trace then log(self.getName().." waitOnDiceRoll()") end
  waiting_on_dice = true
  local z = getObjectFromGUID(GD.board.dice_zone)
  if z ~= nil then
    Wait.condition(
      function()
        waiting_on_dice = false
        if env.test.verbose then log(self.getName().." all dice resting, update spell") end
        updateSpellPower()
      end,
      function()
        local resting = true
        for _,d in pairs(z.getObjects()) do resting = resting and d.resting end
        return resting
      end
    )
  else
    log(self.getName().." ERROR: no dice zone for guid "..GD.board.dice_zone)
  end
end

--[[ Called from Global when player drops a die.  Ignored if not in player spell or dice zones. --]]
function diceDrop(params)
  if env.test.trace then log(self.getName().." diceDrop()") end
  assert(params.guid)
  if waiting_on_dice then return end
  local found = false
  local zone
  local z = getObjectFromGUID(GD.board.dice_zone)
  for _,o in pairs(z.getObjects()) do
    if o.getGUID() == params.guid then
      found = true
      zone = z
      break
    end
  end
  if not(found) then
    z = getObjectFromGUID(GD.board.spells_zone)
    for _,o in pairs(z.getObjects()) do
      if o.getGUID() == params.guid then
        found = true
        zone = z
        break
      end
    end
  end
  if found then
    waiting_on_dice = true
    local die = getObjectFromGUID(params.guid)
    if die ~= nil then
      Wait.condition(
        function()
          waiting_on_dice = false
          if env.test.verbose then log(self.getName().." all dice resting, update spell") end
          updateSpellPower()
        end,
        function()
          local resting = true
          for _,d in pairs(zone.getObjects()) do resting = resting and d.resting end
          return resting
        end
      )
    else
      log(self.getName().." ERROR: diceDrop(): object for guid "..params.guid.." is nil")
    end
  end
end

--[[ ***** DEVELOPMENT ONLY UTILS --]]

function setGMNote(card, data)
  assert(card)
  assert(data)
  assert(type(data) == "table")
  assert(card.hasTag("Spell"))
  card.setGMNotes(JSON.encode_pretty(variable)(data))
end

function saveLocalPosition(params)
  local o = getObjectFromGUID(params.guid)
  local world_pos = o.getPosition()
  local local_pos = self.positionToLocal(world_pos)
  Notes.setNotes(tostring(local_pos))
end

require("tts-lib/utils")
