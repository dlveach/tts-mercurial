--Board relative positions
heroics_local_pos = {}
heroics_local_pos[1] = { -0.693375, 0.063605, 0.22282 }
heroics_local_pos[2] = { -0.697867, 0.063605, 0.019222 }
heroics_local_pos[3] = { -0.692098, 0.063605, -0.187761 }
heroics_local_pos[4] = { -0.700036, 0.063605, -0.387944 }
heroics_local_pos[5] = { -0.695988, 0.063605, -0.591511 }
spells_local_pos = {}
spells_local_pos[1] = { 1.547296, 0.063605, 0.361437 }
spells_local_pos[2] = { 1.133304, 0.063605, 0.358452 }
spells_local_pos[3] = { 0.719295, 0.063605, 0.3606 }
spells_local_pos[4] = { 0.305298, 0.063605, 0.359327 }
spells_local_pos[5] = { -0.110406, 0.063605, 0.356337 }
link_spells_local_pos = {}
link_spells_local_pos[1] = { 1.548386, 0.063605, 1.119303 }
link_spells_local_pos[2] = { 1.136083, 0.063605, 1.123167 }
link_spells_local_pos[3] = { 0.720385, 0.063605, 1.118466 }
link_spells_local_pos[4] = { 0.304666, 0.063605, 1.120609 }
link_spells_local_pos[5] = { -0.109338, 0.063605, 1.121045 }
enchantment_spells_local_pos = {}
enchantment_spells_local_pos[1] = { -0.57809, 0.063605, 1.123024 }
enchantment_spells_local_pos[2] = { -1.014327, 0.063605, 1.121682 }
enchantment_spells_local_pos[3] = { -1.450565, 0.063605, 1.12034 }
spell_discards_local_pos = { -1.275969, 0.063605, -0.579609 }
arcanas_local_pos = { -1.276696, 0.063605, 0.212467 }
used_alterations_local_pos = { -0.112517, 0.063605, -0.625641 }
card_drop_local_pos = { 1.386483, 0.263604, -0.623906 }

env = {}
C = {}
GD = {}

--[[ Game loading. ]]
function onLoad(saved_data)
  env = Global.getTable("env")
  C = Global.getTable("C")
  self.setLock(true)
  if saved_data ~= "" then
    if env.test.trace then log("Player Board " .. board_name .. " saved load") end
    local restore_data = JSON.decode(saved_data)
    GD = restore_data
    restoreBoardState()
  else
    if env.test.trace then log("Player Board " .. board_name .. " fresh load") end
    GD.initialized = false
  end
  loading = false
end

--[[ Restore this board's state during a load from saved data. ]]
function restoreBoardState()
  if env.test.trace then log(board_name..":restoreBoardState()") end
  if GD.initialized then
    --TODO: anything?
  end
end

--[[ Save game state ]]
function onSave()
  local data_to_save = GD
  local saved_data = JSON.encode(data_to_save)
  if env.test.force_fresh_save then saved_data = "" end
  return saved_data
end

--[[ Called from Global during class board selection after it
Initialize state and UI stuffs.
--]]
function initialize(pdata)
  if env.test.trace then log(board_name..": initialize()") end
  assert(pdata,board_name..": setPlayer() missing player data")
  GD.player_color = pdata.player_color
  GD.initialized = true
  self.tooltip = false
  self.interactable = false
  self.UI.setAttribute("gross_restore_panel", "active", "true")
  self.UI.setAttribute("gross_ruin_panel", "active", "true")
  self.UI.setAttribute("net_restore_panel", "active", "true")
  self.UI.setAttribute("net_ruin_panel", "active", "true")
  self.UI.setAttribute("total_myst_panel", "active", "true")
  self.UI.setAttribute("dice_restore_panel", "active", "true")
  self.UI.setAttribute("dice_ruin_panel", "active", "true")
  self.UI.setAttribute("acuity_restore_panel", "active", "true")
  self.UI.setAttribute("acuity_ruin_panel", "active", "true")
  -- self.UI.setAttribute("edit_acuity_pnl", "active", "true")
  self.UI.setAttribute("prestige_panel", "active", "true")
  self.UI.setAttribute("yellow_sigils_panel", "active", "true")
  self.UI.setAttribute("green_sigils_panel", "active", "true")
  self.UI.setAttribute("red_sigils_panel", "active", "true")
  self.UI.setAttribute("blue_sigils_panel", "active", "true")
  self.UI.setAttribute("wild_sigils_panel", "active", "true")
  -- updateUI(pdata)
end

--[[ Called from Global to refresh UI.
Player data table for update is passed as a parameter.
--]]
function updateUI(pdata)
  if env.test.trace then log(board_name..": updateUI()") end
  assert(pdata,board_name..": setPlayer() missing player data")
  self.UI.setAttribute("edit_acuity_pnl", "active", "true")
  self.UI.setAttribute("gross_restore_txt", "text", tostring(pdata.spell_power.gross_restore))
  self.UI.setAttribute("gross_ruin_txt", "text", tostring(pdata.spell_power.gross_ruin))
  self.UI.setAttribute("net_restore_txt", "text", tostring(pdata.spell_power.net_restore))
  self.UI.setAttribute("net_ruin_txt", "text", tostring(pdata.spell_power.net_ruin))
  self.UI.setAttribute("total_myst_txt", "text", tostring(pdata.spell_power.myst))
  self.UI.setAttribute("dice_restore_txt", "text", tostring(pdata.spell_power.dice.restore))
  self.UI.setAttribute("dice_ruin_txt", "text", tostring(pdata.spell_power.dice.ruin))
  self.UI.setAttribute("acuity_restore_txt", "text", tostring(pdata.spell_power.acuity.restore))
  self.UI.setAttribute("acuity_ruin_txt", "text", tostring(pdata.spell_power.acuity.ruin))
  self.UI.setAttribute("prestige_txt", "text", tostring(pdata.prestige))
  --Sigils
  self.UI.setAttribute("yellow_sigils_txt", "text", tostring(pdata.sigils.yellow))
  self.UI.setAttribute("green_sigils_txt", "text", tostring(pdata.sigils.green))
  self.UI.setAttribute("red_sigils_txt", "text", tostring(pdata.sigils.red))
  self.UI.setAttribute("blue_sigils_txt", "text", tostring(pdata.sigils.blue))
  if pdata.class == "Mystcaller" then
    self.UI.setAttribute("wild_sigils_txt", "text", "1")
  else
    self.UI.setAttribute("wild_sigils_txt", "text", "0")
  end
  if pdata.active then
    self.UI.setAttribute("active_player_pnl", "active", true)
    local state = indexOf(pdata.actions.take,"any") > 0
    if not(state) then state = state and indexOf(pdata.actions.take,"spell") > 0 end
    self.UI.setAttribute("take_alterations_pnl","active",state)
    self.UI.setAttribute("cast_spell_pnl","active",state)
    self.UI.setAttribute("player_done_pnl","active",not(state))
  else
    self.UI.setAttribute("active_player_pnl", "active", false)
    self.UI.setAttribute("take_alterations_pnl","active",false)
    self.UI.setAttribute("cast_spell_pnl","active",false)
    self.UI.setAttribute("player_done_pnl","active",false)
  end
end

--[[ Process a used Alteration card.
Called from Global on card drop outside of hand.
--]]
function placeUsedAlterationCard(params)
  assert(params, board_name..": placeUsedAlterationCard(): missing params")
  if env.test.trace then log(board_name..": playAlteration() "..tostring(params.guid)) end
  local card = getObjectFromGUID(params.guid)
  assert(card, board_name..": placeusedAlterationCard(): missing card object, "..params.guid)
  local used = self.positionToWorld(used_alterations_local_pos)
  used.y = used.y + 3
  card.setLock(false)
  if not(card.is_face_down) then card.flip() end
  card.setPosition(used)    --TODO: check this      --TODO: check this
end

--[[ Place a newly acquired spell card.
For now just place on class board and let user pick best spot.
TODO: algorithm to determine best spot.
--]]
function placeSpellCard(params)
  assert(params, board_name..": placeSpellCard(): missing params")
  if env.test.trace then log(board_name..": placeSpellCard() "..tostring(params.guid)) end

  log("TODO: figure out best place to put new spell card")

  --Just drop on class board for now
  local card = getObjectFromGUID(params.guid)
  assert(card, board_name..": failed to locate card for guid "..tostring(params.guid))
  card.setLock(false)
  if card.is_face_down then card.flip() end
  local pos = self.positionToWorld(card_drop_local_pos)
  pos.y = pos.y + 3
  card.setPosition(pos)
end

--[[ Called from Global after all players have selected a class.
Also may be called during game restore.
If this board is unnassigned, desroy it.
--]]
function cleanupBoard()
  if env.test.trace then log(board_name .. ": cleanupBoard()") end
  if not(GD.initialized) then self.destruct() end
end

--[[ Called from global on spell card drop by player for this board.
    Place the card in the closest valid Spell location.
    Then update the map and return it.
--]]
function locateSpell(params)
  if env.test.trace then log(board_name .. ": locateSpell()") end
  if env.test.debug then log(params) end
  local card = getObjectFromGUID(params.guid)
  assert(card, board_name.." locateSpell() WARN: Player dropped card "..params.guid.." but object is nil now.")
  local map = simpleDeepCopy(params.map)
  local cdata = params.card_data
  local spots = spells_local_pos
  local type = "base_spells"
  if cdata.enchant ~= nil then
    spots = enchantment_spells_local_pos
    type = "enchant_spells"
  elseif cdata.link ~= nil then
    spots = link_spells_local_pos
    type = "link_spells"
  end
  local index = 0
  local shortest = nil
  local pos = Vector(self.positionToLocal(card.getPosition()))
  for i,spot in ipairs(spots) do
    if type == "link_spells" or map[type][i].guid == "" then
      local dist = Vector.sqrDistance(pos, Vector(spot))
      -- log("dist for spot "..tostring(i).." is "..tostring(dist))
      if shortest then
        if dist < shortest then
          shortest = dist
          index = i
        end
      else
        -- log("set shortest first time at spot "..tostring(i))
        shortest = dist
        index = i
      end
    end
  end
  assert(index > 0, board_name..": locateSpell() failed to find a valid spell card location")
  card.setPosition(self.positionToWorld(spots[index]))
  if type == "link_spells" then
    table.insert(map.link_spells[index], {guid=card.getGUID(),id=cdata.id})
  else
    map[type][index].guid = card.getGUID()
    map[type][index].id = cdata.id
  end
  -- log("locateSpell() returning")
  return map
end


--[[ Called from Global when this play
TODO: check this, maybe just activate buttons with player data?
--]]
function enableActivePlayer(state)
  local state = state and true
  if env.test.trace then log(board_name .. ": enableActivePlayer() "..tostring(state)) end
  local color_bar = getObjectFromGUID(C.guids.color_bars[GD.board.player_position])
  UI_setAttribute("next_player_pnl", "active", false)
  UI_setAttribute("cleanup_pnl", "active", state)
  if state then
    color_bar.setInvisibleTo({})
    color_bar.UI.setAttribute("block_panel", "active", "true")
  else
    color_bar.setInvisibleTo(Player.getColors())
    color_bar.UI.setAttribute("block_panel", "active", "false")
  end
  GD.board.active = state
end
function updateState(pdata, active_player)
end

--[[ Handler for the edit acuity spell power dialog.
Dialog is not persistent across save/restore.
Gets data from Global on activation.
Local object UI handler for dialog buttons then update Global data when done.
--]]
function editAcuityHandler(player, button, id)
  if env.test.debug then log(board_name..": editAcuityBtn() "..player.color..", "..id) end
  if player.color ~= GD.player_color then return end
  if id == "edit_acuity_btn" then
    local acuity_spell = Global.call("getAcuitySpell",player.color)
    --setup dialog data struct (not persistent)
    dlg = {
      player_color = player.color,
      acuity = acuity_spell.acuity,
      restore = acuity_spell.restore,
      ruin = acuity_spell.ruin,
    }
    if dlg.acuity < 3 then
      if dlg.restore + dlg.ruin == 0 then
        if env.test.debug then log("not enough acuity") end
        return
      end
    end
    self.UI.setAttribute("edit_acuity_pnl","active",false)
    self.UI.setAttribute("acuity_edit_pnl","active",true)
  elseif id == "dec_restore_acuity_btn" then
    if dlg.restore == 0 then return end
    dlg.acuity = dlg.acuity + 3
    dlg.restore = dlg.restore - 1
  elseif id == "inc_restore_acuity_btn" then
    if dlg.acuity < 3 then return end
    dlg.acuity = dlg.acuity - 3
    dlg.restore = dlg.restore + 1
  elseif id == "dec_ruin_acuity_btn" then
    if dlg.ruin == 0 then return end
    dlg.acuity = dlg.acuity + 4
    dlg.ruin = dlg.ruin - 1
  elseif id == "inc_ruin_acuity_btn" then
    if dlg.acuity < 4 then return end
    dlg.acuity = dlg.acuity - 4
    dlg.ruin = dlg.ruin + 1
  elseif id == "cancel_acuity_btn" then
    acuity_edit = {}
    self.UI.setAttribute("acuity_edit_pnl","active",false)
    self.UI.setAttribute("edit_acuity_pnl","active",true)
    return
  elseif id == "done_acuity_btn" then
    Global.call("updateAcuitySpell",dlg)
    self.UI.setAttribute("acuity_edit_pnl","active",false)
    self.UI.setAttribute("edit_acuity_pnl","active",true)
    return
  end
  self.UI.setAttribute("available_acuity_txt","text",tostring(dlg.acuity))
  self.UI.setAttribute("restore_acuity_txt","text",tostring(dlg.restore))
  self.UI.setAttribute("ruin_acuity_txt","text",tostring(dlg.ruin))
end

--//////////// Button wrappers, local validation then pass through to Global.

function playerDoneBtn(player, button, id)
  if env.test.debug then log(board_name..": playerDoneBtn() "..player.color..", "..id) end
  if player.color ~= GD.player_color then return end
  Global.call("setNextPlayer")
  --TODO: anything else?
end

function castSpellBtn(player, button, id)
  if env.test.debug then log(board_name..": castSpellBtn() "..player.color..", "..id) end
  --TODO; check player color
  --TODO: call global
end

function takeAlterationsBtn(player, button, id)
  if env.test.debug then log(board_name..": takeAlterationsBtn() "..player.color..", "..id) end
  --TODO; check player color
  --TODO: call global
end










--/////////// TODO: move this stuff to Global and/or remove OBE code

function castCleanup()          --TODO: move to global
  if env.test.trace then log(board_name..": castCleanup()") end
  local dice = {}
  local spells = {}
  local mana = {}
  local zone = getObjectFromGUID(GD.board.spells_zone)
  assert(zone, board_name.." ERROR castSpellBtn() no board spell zone.")
  local stuff = zone.getObjects()
  for _,o in pairs(stuff) do
    if o.hasTag("Dice") then table.insert(dice, o)
    elseif o.hasTag("Mana") then table.insert(mana, o)
    elseif o.hasTag("Spell") then
      table.insert(spells, o)
      o.setDecals({})
      o.clearButtons()
    elseif o.hasTag("Acuity") then o.destruct()
    else
      if env.test.debug then log(board_name.." castSpellBtn() Unknown object in zone: "..o.getGUID()) end
      if env.test.debug then log(o.getTags()) end
    end
  end
  action = "cleanup"                      --TODO: oh this is UGLY !!!
  local function place(list)
    if list[1] == nil then return end
    local obj = list[1]
    placeObject(obj)
    table.remove(list, 1)
    Wait.condition(
      function() place(list) end,
      function() return (obj.isDestroyed() or obj.resting) end)
  end
  place(dice)
  place(spells)
  place(mana)
  --delete an  acuity used for spell points
  for _,o in pairs(getObjectFromGUID(GD.board.acuity_ruin_zone).getObjects()) do
    if o.hasTag("Acuity") then o.destruct() end
  end
  for _,o in pairs(getObjectFromGUID(GD.board.acuity_restore_zone).getObjects()) do
    if o.hasTag("Acuity") then o.destruct() end
  end
  --give myst bonus if applicable
  if GD.board.power.myst >= 8 then
    local acuity_bag = getObjectFromGUID(C.guids.acuity_bag)
    if GD.board.power.myst >= 8 and GD.board.power.myst <= 9 then
      print(board_name.." recieves one Acuity for Myst bonus")
      acuity_bag.takeObject({ callback_function = function(obj) placeObject(obj) end })
    elseif GD.board.power.myst >= 10 and GD.board.power.myst <= 11 then
      print(board_name.." recieves two Acuity for Myst bonus")
      local function acuity()
        acuity_bag.takeObject({
          callback_function = function(obj) placeObject(obj) end
        })
      end
      Wait.time(function() acuity() end, .25, 2)
    elseif GD.board.power.myst >=12 then
      print(board_name.." recieves two Acuity and one Prestigefor Myst bonus")
      local function acuity()
        acuity_bag.takeObject({
          callback_function = function(obj) placeObject(obj) end
        })
      end
      Wait.time(function() acuity() end, .25, 2)
      local prestige_bag = getObjectFromGUID(C.guids.prestige_bag)
      acuity_bag.takeObject({ callback_function = function(obj) placeObject(obj) end })
    end
  end
  --reset a bunch of stuff
  GD.board.power.restore.dice = 0
  GD.board.power.restore.acuity = 0
  GD.board.power.restore.cards = 0
  GD.board.power.ruin.dice = 0
  GD.board.power.ruin.acuity = 0
  GD.board.power.ruin.cards = 0
  GD.board.power.myst = 0
  UI_setAttribute("gross_restore_text_id", "text", "0")
  UI_setAttribute("gross_ruin_text_id", "text", "0")
  UI_setAttribute("net_restore_text_id", "text", "0")
  UI_setAttribute("net_ruin_text_id", "text", "0")
  UI_setAttribute("total_myst_text_id", "text", "0")
  UI_setAttribute("acuity_restore_text_id", "text", "0")
  UI_setAttribute("acuity_ruin_text_id", "text", "0")
  UI_setAttribute("score_text_id", "text", "0")
  -- UI_setAttribute("roll_dice_pnl", "active", "true")
end

function placeObjects(list)
  -- log("placeObjects")
  -- log(list)
  if sizeOf(list) == 0 then return end
  for g,o in pairs(list) do
    if o then
      placeObject(o)
      list[g] = nil
      break;
    end
  end
  Wait.frames(function() placeObjects(list) end, 30)  --TODO: move to global    --TODO: OBE
end

--[[ Document --]]
function placeObject(obj)
  if env.test.trace then log(board_name .. ":placeObject()") end
  local p = {
    origin       = {},
    direction    = {0,1,0},
    type         = 2,
    size         = {0.25,0.25,0.25},
    max_distance = 1,
    debug        = false,
  }
  --TODO: refactor common code
  if obj.hasTag("Mana") then
    local mana_acuity_zone = getObjectFromGUID(GD.board.class_board_mana_acuity_zone)
    mana_acuity_zone.setTags({"Mana"})
    local mana = mana_acuity_zone.getObjects()
    -- log("mana count in zone is "..tostring(#mana))
    if #mana == 10 then
      if env.test.debug then log(board_name.." mana full, destroy Mana") end
      if env.game.verbose then print(board_name.." Mana is full, throwing one away.") end
      obj.destroy()
    else
      local index = 1
      local looking = true
      while looking do
        p.origin = self.positionToWorld(mana_local_pos[index])
        local hits = Physics.cast(p)
        -- log(hits)
        local empty = true
        if hits ~= nil then
          for _,h in pairs(hits) do
            if h.hit_object.hasTag("Mana") then empty = false end
          end
          if empty then
            looking = false
            obj.setPosition(self.positionToWorld(mana_local_pos[index]))
            obj.setRotation({0,0,0})
          else
            index = index + 1
            if index > 10 then looking = false end
          end
        else
          log("ERROR: got no hits for mana index "..index) --shouldn't ever happen, table and tile will hit
        end
      end
    end
  elseif obj.hasTag("Acuity") then
    local mana_acuity_zone = getObjectFromGUID(GD.board.class_board_mana_acuity_zone)
    mana_acuity_zone.setTags({"Acuity"})
    local acuity = mana_acuity_zone.getObjects()
    -- log("acuity count in zone is "..tostring(#acuity))
    if #acuity == 10 then
      if env.test.debug then log(board_name.." acuity full, destroy Acuity") end
      if env.game.verbose then print(board_name.." Acuity is full, throwing one away.") end
      obj.destroy()
    else
      local index = 1
      local looking = true
      while looking do
        p.origin = self.positionToWorld(acuity_local_pos[index])
        local hits = Physics.cast(p)
        local empty = true
        if hits ~= nil then
          for _,h in pairs(hits) do
            local o = h.hit_object
            if o.hasTag("Acuity") then empty = false end
          end
          if empty then
            looking = false
            obj.setPosition(self.positionToWorld(acuity_local_pos[index]))
            obj.setRotation({0,0,0})
          else
            index = index + 1
            if index > 10 then looking = false end
          end
        else
          log("ERROR: got no hits for acuity index "..index) --shouldn't ever happen, table and tile will hit
        end
      end
    end
  elseif obj.hasTag("Dice") then
    local pos = scatter(self.positionToWorld(dice_zone_local_pos), {1.25,0,1.5}, {0.1,0,0.1})
    obj.setPositionSmooth(pos, false, true)
  elseif obj.hasTag("Spell") then
    log("action is "..action)
    if action == "drop" then
      log("--- TODO: Spell drop, locate best spell position for spell card?")
      --TODO: global "action" flag is ugly!  find a better way
      local pos = self.positionToWorld(drop_zone_local_pos)
      pos.y = 3
      log(pos)
      obj.setLock(false)
      obj.setPositionSmooth(pos, false, true) --just drop it on player board for now
    elseif action == "cleanup" then
      local pos = Vector(self.positionToWorld(spell_discards_local_pos))
      pos.y = 3
      obj.setPositionSmooth(pos, false, true)
    else
      log(board_name..": ERROR: placeObject() invalid action for spell card")
    end
  elseif obj.hasTag("Arcana") then
    local pos = Vector(self.positionToWorld(spell_discards_local_pos))
    local rot = obj.getRotation()
    rot.y = rot.y + 90
    pos.y = 3
    obj.setPositionSmooth(pos, false, true)
    obj.setRotation(rot)
  elseif obj.hasTag("Heroic") then
    local index = 0
    for i=1,5 do
      local h = getCardByTag(won_heroics_local_pos[i+1], "Heroic")
      if h == nil then
        index = i
        break
      end
    end
    if index == 0 then index = 5 end
    local pos = self.positionToWorld(won_heroics_local_pos[index])
    pos.y = 2
    pos.x = pos.x - 0.2 --HACK: why is snap not working?
    pos.z = pos.z - 0.1 --HACK: why is snap not working?
    obj.setPositionSmooth(pos, false, false)
    Wait.condition(
      function() updateScore() end,
      function() return obj.isDestroyed() or obj.resting end )
  elseif obj.hasTag("Alteration") or obj.hasTag("Artifact") then
    obj.deal(1, GD.board.player_color)
    -- Wait.time(function() updateScore() end, 1)  --This is now done when card enters hand zone
  elseif obj.hasTag("Prestige") then
    local pos = self.positionToWorld(prestige_zone_local_pos)
    obj.setPositionSmooth(pos, false, true)
  else
    log("ERROR: unhandled object")
  end    --TODO: remove OBE code, move to global, major overhaul for spell placement    --TODO: OBE
end

--[[ Button handler to trigger spell power update --]]     --TODO: move to global if needed???
function updateSpellPowerBtn(player, mouse, id)
  local pcol = player.color
  if env.test.trace then log(board_name .. ": updateSpellPowerBtn() "..pcol) end
  log("------ TODO: is this needed?  Does spell card dropping handle everything?")

  -- if player.color == GD.player_color then
  --   updateSpellPower() <<< TODO: move to Global if needed
  -- end
end

--[[ Calculate spell power for this player board and update UI elements --]]     --TODO: move to global
function updateSpellPower()
  if env.test.trace then log(board_name .. ": updateSpellPower()") end
  local total_restore = 0
  local total_ruin = 0
  local total_myst = 0
  GD.board.power.myst = 0

  --update power contribution by unused dice
  GD.board.power.ruin.dice = 0
  GD.board.power.restore.dice = 0
  for _,d in pairs(getUnallocatedDiceValues()) do
    if dice_translation[d] == "ruin" then
      GD.board.power.ruin.dice = GD.board.power.ruin.dice + 1
    elseif dice_translation[d] == "restore" then
      GD.board.power.restore.dice = GD.board.power.restore.dice + 1
    end
  end
  UI_setAttribute("dice_restore_text_id", "text", tostring(GD.board.power.restore.dice))
  UI_setAttribute("dice_ruin_text_id", "text", tostring(GD.board.power.ruin.dice))

  --uppdate power contributed by acuity spaces
  GD.board.power.restore.acuity = 0
  local acuity_restore_zone = getObjectFromGUID(GD.board.acuity_restore_zone)
  local acuity_count = 0
  for _,o in pairs(acuity_restore_zone.getObjects()) do
    if o.hasTag("Acuity") then
      acuity_count = acuity_count + 1
    end
  end
  if acuity_count > 0 then
    GD.board.power.restore.acuity = math.modf(acuity_count/3)
  else
    GD.board.power.restore.acuity = 0
  end
  UI_setAttribute("acuity_restore_text_id", "text", tostring(GD.board.power.restore.acuity))
  GD.board.power.ruin.acuity = 0
  local acuity_ruin_zone = getObjectFromGUID(GD.board.acuity_ruin_zone)
  local ruin_count = 0
  for _,o in pairs(acuity_ruin_zone.getObjects()) do
    if o.hasTag("Acuity") then
      ruin_count = ruin_count + 1
    end
  end
  if ruin_count > 0 then
    GD.board.power.ruin.acuity = math.modf(ruin_count/4)
  else
    GD.board.power.ruin.acuity = 0
  end
  UI_setAttribute("acuity_ruin_text_id", "text", tostring(GD.board.power.ruin.acuity))

  --update power from spell cards
  GD.board.power.restore.cards = 0
  GD.board.power.ruin.cards = 0
  for i=1,5 do
    local card = getCardByTag(spells_local_pos[i], "Spell")
    if card ~= nil then
      --TODO: confirm this is a base spell card & warn if not
      if env.test.debug then log("Getting power for card "..card.getGUID()) end
      local restore, ruin = getSpellPower(card)
      if restore > 0 and ruin > 0 then
        if card.memo ~= nil then
          if card.memo == "Ruin" then
            GD.board.power.ruin.cards = GD.board.power.ruin.cards + ruin
          elseif card.memo == "Restore" then
            GD.board.power.restore.cards = GD.board.power.restore.cards + restore
          else
            log(board_name.." ERROR: unexpected memo value on card "..card.getGUID())
          end
        end
      else
        GD.board.power.restore.cards = GD.board.power.restore.cards + restore
        GD.board.power.ruin.cards = GD.board.power.ruin.cards + ruin
      end
    end
  end

    --calculate totals
  total_restore = total_restore + GD.board.power.restore.dice
  total_restore = total_restore + GD.board.power.restore.acuity
  total_restore = total_restore + GD.board.power.restore.cards
  total_ruin = total_ruin + GD.board.power.ruin.dice
  total_ruin = total_ruin + GD.board.power.ruin.acuity
  total_ruin = total_ruin + GD.board.power.ruin.cards
  --handle any enchantment card effects, in order of position
  local spells = Global.getTable("spells")
  for i=1,3 do
    local card = getCardByTag(enchantment_spells_local_pos[i], "Spell")
    if card ~= nil then
      if env.test.debug then log("Process enchantment for card "..card.getGUID()) end
      local data = spells[tonumber(card.getGMNotes())]
      if env.test.debug then log(data) end
      if data.enchant ~= nil then
        if data.enchant.ruin > 0 then
          total_ruin = total_ruin + (total_restore * data.enchant.ruin)
          total_restore = 0
        elseif data.enchant.restore > 0 then
          total_restore = total_restore + (total_ruin * data.enchant.restore)
          total_ruin = 0
        else
          log(board_name.." ERROR: unexpected enchantment type")
        end
      else
        log(board_name.." WARN: non-enchantment spell in enchantment space.")
        broadcastToColor((board_name.." has a non-enchantment spell in an enchantment space."), GD.board.player_color)
      end
    end
  end
  --check for equilibrium or calculate net if not
  local net_restore = total_restore - total_ruin
  local net_ruin = total_ruin - total_restore
  if total_restore > 0 and total_restore == total_ruin then
    total_myst = total_restore
    --transform net restore/ruin from myst
    if total_myst >=6 and total_myst <=7 then
      net_restore = 15
      net_ruin = 11
    elseif total_myst >=8 and total_myst <=9 then
      net_restore = 21
      net_ruin = 16
    elseif total_myst >=10 and total_myst <=11 then
      net_restore = 28
      net_ruin = 20
    elseif total_myst >= 12 then
      net_restore = 34
      net_ruin = 24
    end
    GD.board.power.myst = total_myst
  else
    if net_restore < 0 then net_restore = 0 end
    if net_ruin < 0 then net_ruin = 0 end
  end
  --update UI
  UI_setAttribute("gross_restore_text_id", "text", tostring(total_restore))
  UI_setAttribute("gross_ruin_text_id", "text", tostring(total_ruin))
  UI_setAttribute("net_restore_text_id", "text", tostring(net_restore))
  UI_setAttribute("net_ruin_text_id", "text", tostring(net_ruin))
  UI_setAttribute("total_myst_text_id", "text", tostring(total_myst))
  Global.call("updateHUD")  --TODO: move to global ???
end

--[[ Create a button on an option spell card to toggle it's type --]]     --TODO: move to global
function createCardButton(card)
  assert(card)
  if card ~= nil then
    params = {
      click_function = "cardButton",
      function_owner = self,
      label          = "",
      position       = {0,1,-1},
      rotation       = {0,180,0},
      width          = 400,
      height         = 200,
      color          = {0,0,0,0},
      hover_color    = {0,0,0,0},
      press_color    = {0,0,0,0},
    }
    card.createButton(params)
  end   --TODO: move to global?
end
function t_createCardButton(params)
  assert(params)
  local card_guid = params.guid
  assert(card_guid)
  local card = getObjectFromGUID(card_guid)
  assert(card)
  createCardButton(card)
end

--[[ Button handler for card type toggle button ]]     --TODO: move to global
-- function cardButton(card, player_color, mouse)
--   local decals = card.getDecals()
--   if decals ~= nil then
--     card.setDecals({})
--     if decals[1].name == "Restore" then
--       card.addDecal(card_decals["Ruin"])
--       card.memo = "Ruin"
--     elseif decals[1].name == "Ruin" then
--       card.addDecal(card_decals["Restore"])
--       card.memo = "Restore"
--     else
--       log(board_name.."cardButton() ERROR: unidentified decal on card")
--     end
--     updateSpellPower()
--   end     --TODO: move to global?
-- end

--[[ Process a given spell card and return the restore power and ruin power of the card. --]]     --TODO: move to global
function getSpellPower(card)
  if env.test.trace then log(board_name .. ": getSpellPower()") end
  assert(card, board_name.." getSpellPower(): card object is missing")
  if env.test.debug then log(card) end
  if not(card.hasTag("Spell")) then
    if env.test.debug then log(board_name .. ": getSpellPower(): Not a spell card, "..card.getGUID()) end
    return
  end
  local spells = Global.getTable("spells")
  local data = spells[tonumber(card.getGMNotes())]
  if env.test.debug then log("data:") end
  if env.test.debug then log(data) end
  if data == nil then
    if env.test.debug then log("ERROR: no data for card "..card.getGUID()) end
    return
  end
  local restore = 0
  local ruin = 0

  --If this is a base spell, calculate restore and ruin power
  if data.base ~= nil then
    if env.test.debug then log("Spell is a base spell") end
    restore = data.base.restore
    ruin = data.base.ruin
    if env.test.debug then log("check for aether") end
    if data.aether ~= nil then
      if env.test.debug then log("this base spell has an Aether mod`") end
      if hasAether() then
        restore = data.aether.restore
        ruin = data.aether.ruin
      end
    end

  --if this is a card count spell, get ruin and restore power based on number of spell cards
  elseif data.count ~= nil then
    if env.test.debug then log("spell is a card count spell") end
    local count = getSpellCount()
    if env.test.debug then log("card count is "..count) end
    if data.aether ~= nil and hasAether() then
      if env.test.debug then log("counting aether * cards") end
      if data.aether.restore ~= nil and data.aether.restore > 0 then
        restore = data.aether.restore * count
      elseif data.aether.ruin ~= nil and data.aether.ruin > 0 then
        ruin = data.aether.ruin * count
      else
        log(board_name..": ERROR invalid spell card aether count data, "..card.getGUID())
      end
    else
      if env.test.debug then log("counting count * cards") end
      if data.count.restore ~= nil and data.count.restore > 0 then
        restore = data.count.restore * count
      elseif data.count.ruin ~= nil and data.count.ruin > 0 then
        ruin = data.count.ruin * count
      else
        log(board_name..": ERROR invalid spell card count data, "..card.getGUID())
      end
    end

  --if this is an acuity count spell, get ruin or restore based on acuity on cast board
  elseif data.acuity ~= nil then
    if env.test.debug then log("Spell is acuity count spell") end
    local count = getUnusedAcuityCount()
    if data.acuity.restore > 0 then
      restore = count
    elseif data.acuity.ruin > 0 then
      ruin = count
    end
  end
  if env.test.debug then log("core spell restore power: "..restore) end
  if env.test.debug then log("core spell ruin power: "..ruin) end

  --Now check any link spells matching this spell card location
  local pos = 0
  for i=1,5 do
    local c = getCardByTag(spells_local_pos[i], "Spell")
    if c ~= nil then
      if c.getGUID() == card.getGUID() then
        pos = i
        break;
      end
    end
  end
  if env.test.debug then log("Checking for link spell(s) modifiers") end
  local spells = Global.getTable("spells")
  if pos>0 then
    local link_spells = getCardByTag(link_spells_local_pos[pos], "Spell")
    if link_spells ~= nil then
      if env.test.debug then log("Position "..pos.." has link spell(s)") end
      if link_spells.tag == "Deck" then
        if env.test.debug then log("More than one link spell") end
        for _,o in pairs(link_spells.getObjects()) do
          local link_data = spells[tonumber(o.gm_notes)]
          if env.test.debug then log(link_data) end
          if link_data ~= nil and link_data.link ~= nil then
            --TODO: confirm this is a link card and warn if not
            if link_data.link.aether ~= nil and hasAether() then
              restore = restore * link_data.link.aether
              ruin = ruin * link_data.link.aether
            else
              restore = restore * link_data.link.base
              ruin = ruin * link_data.link.base
            end
          end
        end
      elseif link_spells.tag == "Card" then
        local link_data = spells[tonumber(link_spells.getGMNotes())]
        if env.test.debug then log(link_data) end
        if link_data ~= nil and link_data.link ~= nil then
            --TODO: confirm this is a link card and warn if not
            if link_data.link.aether ~= nil and hasAether() then
            restore = restore * link_data.link.aether
            ruin = ruin * link_data.link.aether
          else
            restore = restore * link_data.link.base
            ruin = ruin * link_data.link.base
          end
        end
      end
    end
  end
  if env.test.debug then
    log("Spell "..card.getGUID().." total restore: "..tostring(restore))
    log("Spell "..card.getGUID().." total ruin: "..tostring(ruin))
  end
  return restore, ruin    --TODO: move to global
end
function t_getSpellPower(params)
  assert(params.guid)
  local card = getObjectFromGUID(params.guid)
  return getSpellPower(card)
end

--[[ Support function.  Return a card object with specified tag at specified local location.
NOTE: Location must be local to self, not world!
Returns nil if nothing found.
Parameters:
  pos: Local to self Vector of location to search.
  tag: The tag of the card object to filter on.
  debug: Optional flag, defaults to false.
--]]     --TODO: use lib function, move to Global
function getCardByTag(pos, tag, debug)
  if env.test.trace then log(board_name .. ": getCardByTag()") end
  assert(tag)
  assert(type(pos) == "table")
  assert(#pos == 3)
  if debug == nil then debug = false end
  local world_pos = self.positionToWorld(pos)
  local p = {
    origin       = world_pos,
    direction    = {0,1,0},
    type         = 2,
    size         = {0.25,0.25,0.25},
    max_distance = 1,
    debug        = debug,
  }
  local hits = Physics.cast(p)
  local card = nil
  if hits ~= nil then
    for _,h in pairs(hits) do
      if h.hit_object.hasTag(tag) then
        card = h.hit_object
        break
      end
    end
  end
  return card   --TODO: use lib   --TODO: move to global?
end
function t_getCardByTag(params)
  assert(params.index)
  assert(params.tag)
  local pos = spells_local_pos[params.index]
  return getCardByTag(pos, params.tag)
end

--[[ Calculate current score adn update display --]]      --TODO: OBE? move to Global if needed
function updateScore()
  if env.test.trace then log(board_name .. ": updateScore()") end
  local sigils = { red = 0, blue = 0, green = 0, yellow = 0 }
  local heroics_score = 0
  local prestige_score = 0
  local arcanas_score = 0
  local sigil_score = 0
  -- GD.board.scoring.spells = {}
  GD.board.scoring.heroics = {}
  GD.board.scoring.arcanas = {}
  local heroics_data = Global.getTable("heroics")
  --Herocis scoring
  local heroics_zone = getObjectFromGUID(GD.board.heroics_zone)
  local heroics_count = 0
  if heroics_zone != nil then
    local heroics = heroics_zone.getObjects()
    for _,h in pairs(heroics) do
      if h.hasTag("Heroic") then
        heroics_count = heroics_count + 1
        if env.test.debug then log("---  Heroic card id: "..h.getGMNotes()) end
        local data = heroics_data[tonumber(h.getGMNotes())]
        if data then
          heroics_score = heroics_score + data.vp
          for _,sigil in ipairs(data.sigils) do sigils[sigil] = sigils[sigil] + 1 end
        else
          log("ERROR: "..board_name..": updateScore(): no data found for Heroic card, "..h.getGUID())
        end
      else
        log("WARN: "..board_name..": updateScore(): ignoring unknown object found in Heroics stack, "..h.getGUID())
      end
    end
  else
    log("ERROR: "..board_name..": heroics zone not found")
  end
  if env.test.debug then log("Heroics score: "..heroics_score) end
  GD.board.scoring.values.heroics = heroics_score
  GD.board.heroics_count = heroics_count
  --count sigils on alteration cards in hand
  local hand = Player[GD.board.player_color].getHandObjects(index)
  local card_data = Global.getTable("alterations")
  for _,c in ipairs(hand) do
    local data = card_data[tonumber(c.getGMNotes())]
    if data then
      for _,sigil in ipairs(data.sigils) do
        sigils[sigil] = sigils[sigil] + 1
      end
    end
  end
  --count sigils on alteration cards in spent pile
  local pos = self.positionToWorld(used_alterations_local_pos)
  local spent = findObject(pos, {"Deck", "Card"}, env.test.debug)
  if spent then
    if spent.tag == "Deck" then
      for _,c in ipairs(spent.getObjects()) do
        local data = card_data[tonumber(c.gm_notes)]
        if data then
          for _,sigil in ipairs(data.sigils) do
            sigils[sigil] = sigils[sigil] + 1
          end
        end
      end
    elseif spent.tag == "Card" then
      local data = card_data[tonumber(spent.getGMNotes())]
      if data then
        for _,sigil in ipairs(data.sigils) do
          sigils[sigil] = sigils[sigil] + 1
        end
      end
    end
  end
  --Add sigil for player class board
  if board_sigil == "wild" then
    -- Will at least make a pair, worth 1.  Otherwise adds 1 more to one set of 3 or more.  So always adds 1.
    sigil_score = sigil_score + 1
  else
    sigils[board_sigil] = sigils[board_sigil] + 1
  end
  --Sigil scoring
  -- log(sigils)
  for sigil,count in pairs(sigils) do
    GD.board.sigils[sigil] = count
    UI_setAttribute(sigil.."_sigils_text", "text", tostring(count))
    c = math.modf(count/3)
    if c > 0 then
      sigil_score = sigil_score + (3 * c)
    else
      c = math.modf(count/2)
      if c > 0 then
        sigil_score = sigil_score + c
      end
    end
  end
  -- log("Sigil score: "..sigil_score)
  GD.board.scoring.values.sigils = sigil_score
  --Prestige token scoring
  local prestige_zone = getObjectFromGUID(GD.board.prestige_zone)
  for _,o in pairs(prestige_zone.getObjects()) do
    if o.hasTag("Prestige") then
      prestige_score = prestige_score + 1
    end
  end
  -- log("Prestige score: "..prestige_score)
  GD.board.scoring.values.prestige = prestige_score
  --Arcana scoring
  local spell_cards = {}
  local spells = Global.getTable("spells")
  local arcanas = {}
  local z = getObjectFromGUID(GD.board.spell_arcana_zone)
  for _,o in pairs(z.getObjects()) do
    if o.hasTag("Spell") then
      if o.tag == "Deck" then
        for _,c in pairs(o.getObjects()) do
          spell_cards[c.guid] = spells[tonumber(c.gm_notes)]
          -- GD.board.scoring.spells[c.guid] = c.gm_notes
        end
      else
        spell_cards[o.getGUID()] = spells[tonumber(o.getGMNotes())]
        -- GD.board.scoring.spells[o.getGUID()] = o.getGMNotes()
      end
    elseif o.hasTag("Arcana") then
      table.insert(arcanas, o)
      GD.board.scoring.arcanas[o.getGUID()] = o.getName()
    else
      log("WARN: ignoring object "..o.getGUID().." in spell/arcana pile.")
    end
  end
  log("found "..sizeOf(spell_cards).." spell cards")
  log("found "..#arcanas.." arcana cards")
  local arcana_data
  for _,arcana in pairs(arcanas) do
    if arcana.is_face_down then
      arcana_data = C.arcanas[arcana.getGUID()].face_down
    else
      arcana_data = C.arcanas[arcana.getGUID()].face_up
    end
    log("Scoring arcana data: ")
    log(arcana_data)
    local score = arcana_data.base_vp
    local count = 0
    local bonus = arcana_data.bonus
    if bonus.spell_type == "aether_mod" then
      for _,card in pairs(spell_cards) do
        if card.aether_mod then
          count = count + 1
        end
      end
    elseif bonus.spell_type == "not_aether" then
      for _,card in pairs(spell_cards) do
        if not(card.aether_mod) then
          count = count + 1
        end
      end
    elseif bonus.spell_type == "slot_count" then
      for _,card in pairs(spell_cards) do
        if card.slots >= 4 then
          count = count + 1
        end
      end
    else
      for _,card in pairs(spell_cards) do
        if bonus.spell_type == "any" or contains(card.dice, bonus.spell_type) then
          count = count + 1
        end
      end
    end
    log("Number spells matching arcana "..arcana.getName().." condition = "..count..":"..tostring(bonus.spell_type))
    local n = math.modf(count/bonus.count)
    score = score + n * arcana_data.vp
    log(arcana.getName().." score is "..tostring(score))
    arcanas_score = arcanas_score + score
  end

  log("total arcana score: "..arcanas_score)
  GD.board.scoring.values.arcanas = arcanas_score

  log("-------------TODO: fix arcana scoring to final rules -------------------")

  local score = heroics_score + sigil_score + prestige_score + arcanas_score
  GD.board.scoring.total_score = score
  UI_setAttribute("score_text_id", "text", tostring(score))
  Global.call("updateHUD")    --TODO: move to global
end

--[[ ***** DEVELOPMENT ONLY UTILS --]]

function setGMNote(card, data)
  assert(card)
  assert(data)
  assert(type(data) == "table")
  assert(card.hasTag("Spell"))
  card.setGMNotes(JSON.encode_pretty(variable)(data))
end

function saveLocalPosition(params)
  local o = getObjectFromGUID(params.guid)
  local world_pos = o.getPosition()
  local local_pos = self.positionToLocal(world_pos)
  Notes.setNotes(tostring(local_pos))
end

require("tts-lib/utils")
